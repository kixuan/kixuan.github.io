<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅析 JWT</title>
      <link href="/2024/03/20/JWT/"/>
      <url>/2024/03/20/JWT/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对jwt总是一知半解，而且项目打算写个关于JWT登录的点，所以总结关于JWT的知识及面试考察过的点</p><p>参考资料：</p><p><a href="https://blog.csdn.net/kagurawill/article/details/103764296?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-103764296-blog-136887367.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-103764296-blog-136887367.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;utm_relevant_index=1">Cookie、Session、Token、JWT_通俗地讲就是验证当前用户的身份,证明-CSDN博客</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程 - 阮一峰的网络日志</a></p><p><a href="https://cloud.tencent.com/developer/article/2231547">https://cloud.tencent.com/developer/article/2231547</a></p><p><a href="https://developer.aliyun.com/article/995894#slide-0">JWT详细讲解(保姆级教程)-阿里云开发者社区</a></p><p><a href="https://blog.csdn.net/weixin_43973161/article/details/127012976">JWT双令牌(双token)实现登录验证_双token三验证-CSDN博客</a></p></blockquote><h1 id="零、前置知识"><a href="#零、前置知识" class="headerlink" title="零、前置知识"></a>零、前置知识</h1><p>cookie、session、token的区别</p><p>cookie：用于在客户端存储会话信息，并在之后每个请求中都会通过HTTP头部再将cookie发给服务器 ==》对于敏感信息不安全（跨站脚本、跨站请求伪造）</p><p>session：是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中，然后请求服务器的时候只发送Sessionid==》用户量特别大时，服务器容易分配。 </p><p>token：可以存储在客户端或者服务器端，具体取决于实现方式。常见的做法是将 Token 存储在客户端，比如在 localStorage、sessionStorage 或者浏览器的内存中。///无状态///可拓展性强，可以包含任何信息</p><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><ul><li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><p>为什么session比cookie安全？</p><p>可被篡改性：Cookie 存储在客户端，可以在客户端被修改。相比之下，Session 数据通常存储在服务器端，攻击者无法直接修改。</p><p>可被窃取性：同上</p><p>持久性：这意味着即使用户关闭浏览器，这些 Cookie 也会被保存在用户的设备上。长时间的持久性可能增加了攻击者窃取 Cookie 的机会</p><h3 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h3><ul><li>Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。</li><li>而 Token 是访问资源接口（API）时所需要的资源凭证，使服务端无状态化，不会存储会话信息。</li></ul><h1 id="一、出现背景"><a href="#一、出现背景" class="headerlink" title="一、出现背景"></a>一、出现背景</h1><p>在传统的 Web 开发中，为了保持用户的会话状态，通常会使用基于 cookie 和 session 的方式保存相关数据，如用户角色、登陆时间。但也有一些问题，比如跨域资源共享（CORS）和无状态（Stateless）服务。</p><p>如果是服务器集群或者需要CORS的架构，要求session数据库共享</p><p>解决办法：</p><ol><li>session数据持久化——写到数据库或者别的持久层，工程量较大；稳定性不高，持久层挂了就会单点失败</li><li>服务器不保存session数据，数据保存在客户端，每次请求带上发回给服务器</li></ol><p><strong>JSON Web Token（缩写 JWT）是2方案的一个代表，是目前最流行的跨域认证解决方案</strong></p><table><thead><tr><th>基于session的认证流程</th><th>基于JWT的认证流程</th></tr></thead><tbody><tr><td>用户在浏览器中输入用户名和密码，服务器通过密码校验后生成一个session并保存到数据库服务器为用户生成一个sessionId，并将具有sesssionId的cookie放置在用户浏览器中，同时 Cookie 记录此 SessionID 属于哪个域名，在后续的该域名的请求中都将带有这个cookie信息进行访问服务器获取cookie，通过获取cookie中的sessionId查找数据库判断当前请求是否有效</td><td>用户在浏览器中输入用户名和密码，服务器通过密码校验后生成一个token并保存到数据库前端获取到token，存储到cookie或者local storage中，在后续的请求中都将带有这个token信息进行访问服务器获取token值，通过查找数据库判断当前token是否有效</td></tr></tbody></table><h1 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h1><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>JWT 的原理基于三部分组成：Header、Payload 和 Signature。它们通过点（<code>.</code>）连接在一起，形成一个紧凑的字符串，可以通过 URL、POST 参数或 HTTP 头部发送。</p><ol><li>Header：包含了两部分信息：令牌的类型（即JWT），以及所使用的签名算法（例如HMAC SHA256或RSA）。</li><li>Payload：存放着声明（claims），即关于实体（通常是用户）和其他数据的信息。Payload包含了一些预定义的标准声明（如issuer、subject、audience等），同时也可以包含自定义的声明。</li><li>Signature：用于验证消息的完整性的签名部分。它由将编码的 header、payload 和一个秘密（例如，使用 HMAC 算法时的密钥）进行签名生成。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/asynccode" alt="img"></p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><ol><li><code>Header</code>部分是一个 JSON 对象，描述 JWT 的元数据,使用 Base64URL 算法转成字符串</li></ol><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"alg"</span><span class="punctuation">:</span> <span class="string">"HS256"</span><span class="punctuation">,</span>  <span class="comment">// 签名算法</span></span><br><span class="line">    <span class="attr">"typ"</span><span class="punctuation">:</span> <span class="string">"JWT"</span>     <span class="comment">// 令牌类型</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><ol><li><code>Payload</code>:服务器认证以后，生成一个 JSON 对象用来存放实际需要传递的数据，再使用 Base64URL 算法转成字符串</li></ol><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// JWT 规定了7个官方字段供选用，也可以定义私有字段</span></span><br><span class="line">- iss (issuer)：签发人</span><br><span class="line">- exp (expiration time)：过期时间</span><br><span class="line">- sub (subject)：主题</span><br><span class="line">- aud (audience)：受众</span><br><span class="line">- nbf (Not Before)：生效时间</span><br><span class="line">- iat (Issued At)：签发时间</span><br><span class="line">- jti (JWT ID)：编号</span><br><span class="line"></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"姓名"</span><span class="punctuation">:</span> <span class="string">"张三"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"角色"</span><span class="punctuation">:</span> <span class="string">"管理员"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"到期时间"</span><span class="punctuation">:</span> <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><ol><li><code>Signature</code>:通过将 Base64 编码后的 Header 和 Payload 与一个秘密（例如，使用 HMAC 算法时的密钥）进行签名生成的。 指定一个密钥，密钥只有服务器知道，然后使用 Header 里面指定的签名算法alg算出签名</li><li>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。此后，客户端每次与服务器通信，都要带上这个 JWT(也可以放在HTTP请求头信息里的<code>Authorization</code>字段,方便跨域)</li></ol><h1 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h1><p>参考：<a href="https://blog.csdn.net/weixin_43973161/article/details/127012976">JWT双令牌(双token)实现登录验证_双token三验证-CSDN博客</a></p><p>双令牌：无感登录刷新</p><ol><li>access_token  泄露概率比较大</li><li>refresh_token 泄露概率比较小,只有每次access_token  失效时才会使用它,所以二者组合可以很好的避免token泄露带来的安全风险,同时又能保证用户体验</li><li>userService的login方法<ol><li>保存refresh token到数据库</li><li>access token返回给前端</li></ol></li><li>刷新accessToken</li></ol><p>当短时间的token过期，前端需要通过长时间的token来访问后端，并且生成一个短时间的token返回给前端，也就是刷新短时间的token。</p><ol><li>删除refreshToken</li></ol><p>当用户退出的时候我们需要删除数据库中的refreshToken。</p><h1 id="四、相关面试题（来源牛客）"><a href="#四、相关面试题（来源牛客）" class="headerlink" title="四、相关面试题（来源牛客）"></a>四、相关面试题（来源牛客）</h1><h2 id="TODO-为什么token要放在redis"><a href="#TODO-为什么token要放在redis" class="headerlink" title="TODO:为什么token要放在redis"></a>TODO:为什么token要放在redis</h2><h2 id="1-jwt的token怎么生成的-x2F-jwt的参数是什么样的，有什么意义"><a href="#1-jwt的token怎么生成的-x2F-jwt的参数是什么样的，有什么意义" class="headerlink" title="1. jwt的token怎么生成的?/jwt的参数是什么样的，有什么意义"></a>1. jwt的token怎么生成的?/jwt的参数是什么样的，有什么意义</h2><p>由三个部分组成：Header、Payload 和 Signature。其中，Header 和 Payload 部分是基于 Base64 编码的 JSON 对象，而 Signature 是通过对 Header 和 Payload 进行签名生成的。</p><p>+运行流程</p><h2 id="2-jwt-是明文的吗？"><a href="#2-jwt-是明文的吗？" class="headerlink" title="2. jwt 是明文的吗？"></a>2. jwt 是明文的吗？</h2><p>Header 和 Payload 是基于 BaseURL64 编码的 JSON 对象，明文存放的</p><p>Signature 是加密的，但是它主要适用于验证JWT的真实性防止被篡改，不存放信息</p><p>所以整体来说，JWT还是明文的</p><h2 id="3-JWT用到了什么摘要算法"><a href="#3-JWT用到了什么摘要算法" class="headerlink" title="3. JWT用到了什么摘要算法"></a>3. JWT用到了什么摘要算法</h2><p>摘要算法：摘要算法又称哈希算法、散列算法。它通过一个函数，<strong>把任意长度的数据转换为一个长度固定的数据串</strong>（通常用16进制的字符串表示）。</p><p>要注意摘要算法<strong>不是加密算法</strong>，不能用于加密（因为无法通过摘要反推明文），<strong>只能用于防篡改</strong>。</p><p>SHA256是一种哈希算法，用于将任意长度的输入数据转换成固定长度的输出（256 位，即 32 字节）</p><p>工作原理：</p><ol><li>填充数据：首先SHA256 将输入数据填充至满足特定要求的长度，通常在数据末尾添加比特位，以确保数据长度满足要求。</li><li>分块处理：将填充后的数据按照固定长度分割成多个块，每个块的长度为 512 比特。</li><li>初始哈希值：设定初始的 256 比特哈希值，作为计算的起始点。</li><li>迭代运算：对每个块进行迭代运算，结合前一个块的哈希值，计算得到新的哈希值，直到处理完所有块。</li><li>输出结果：将最后一个块计算得到的哈希值作为最终的 SHA256 哈希值输出。</li></ol><p>特点：</p><ul><li><strong>固定长度输出</strong>：SHA256 输出固定长度的哈希值，即使输入数据的长度不同，输出的哈希值长度仍然相同。</li><li><strong>不可逆性</strong>：SHA256 是一种单向哈希函数，即无法通过哈希值反推出原始数据，保证了数据的安全性。</li><li><strong>抗碰撞性</strong>：SHA256 具有较高的抗碰撞性，即使对不同的输入数据计算得到相同的哈希值的可能性极低，保证了数据的唯一性和完整性。</li></ul><h2 id="4-可以使用md5摘要算法吗？"><a href="#4-可以使用md5摘要算法吗？" class="headerlink" title="4. 可以使用md5摘要算法吗？"></a>4. 可以使用md5摘要算法吗？</h2><p>MD5 摘要算法不建议用于 JWT 的签名，因为 MD5 已经被证明不安全，容易受到碰撞攻击。碰撞攻击是指攻击者能够生成两个不同的输入，但产生相同的哈希值。</p><p>为什么选sha256不选md5</p><ol><li>摘要长度：SHA256 生成的摘要长度（256 比特）比 MD5 长度（128 比特）更长，因此具有更大的输出空间，更难以发生碰撞（即两个不同的消息产生相同的摘要）。</li><li>算法结构：SHA256 是基于 Merkle–Damgard 结构的散列函数，而 MD5 是基于 MD4 结构的。SHA256 的算法结构更为复杂，使用了更多的轮次和更复杂的运算，提高了其抵抗碰撞攻击的能力。</li><li>算法安全性：MD5 算法在安全性上存在一些漏洞，如碰撞攻击、预图片攻击等，已经被证明不再安全。而 SHA256 目前尚未出现有效的攻击方法，因此被认为更安全。</li></ol><h2 id="5-了解RAS算法吗？"><a href="#5-了解RAS算法吗？" class="headerlink" title="5. 了解RAS算法吗？"></a>5. 了解RAS算法吗？</h2><p>rsa是一种非对称加密算法，数据可以使用公钥进行加密，然后只有持有相应私钥的一方才能解密该数据。反之，数据也可以使用私钥进行签名，然后任何持有相应公钥的一方都可以验证该签名。</p><p>在JWT的应用：私钥用于生成签名，而公钥用于验证签名。这样即使公钥泄露，攻击者也无法伪造有效的签名，从而确保了 JWT 的安全性。</p><blockquote><p>我趣那不是又能深入到对称加密和非对称加密</p><p>对称加密：相同密钥、快速高效</p><p>非对称加密：不同密钥、安全性较高</p></blockquote><h2 id="6-base64算法？base64的流程是什么？"><a href="#6-base64算法？base64的流程是什么？" class="headerlink" title="6. base64算法？base64的流程是什么？"></a>6. base64算法？base64的流程是什么？</h2><p>Base64 编码算法：Base64 算法将二进制数据编码成文本字符串，但并不对数据进行加密或者隐藏。它的主要目的是将二进制数据转换成纯文本格式，以便于传输或者存储。【24位转32位】</p><ol><li>把数据按照24位（3 字节）为一组进行划分</li><li>转成ASCII编码——转成二进制编码（24位）——每6位一组转成十进制（4个数字）——转成对应的ASCII编码——转成二进制（32位）</li><li>如果输入数据的长度不是 3 的整数倍，则需要添加一定数量的填充字符 “=”，使得每个 24 位的组都能够被正确地转换成四个 Base64 字符。</li></ol><p><a href="https://blog.csdn.net/qq_19782019/article/details/88117150">https://blog.csdn.net/qq_19782019/article/details/88117150</a></p><h2 id="7-双令牌认证方案是怎么实现的"><a href="#7-双令牌认证方案是怎么实现的" class="headerlink" title="7. 双令牌认证方案是怎么实现的"></a>7. 双令牌认证方案是怎么实现的</h2><p>同时使用访问令牌（Access Token）和刷新令牌（Refresh Token）来实现用户认证和无感登录刷新。这种方案可以有效地提高安全性和用户体验，具体实现方式如下：</p><ol><li>认证过程：<ol><li>用户使用用户名和密码等凭据进行登录，服务器验证用户身份并生成 Access Token 和 Refresh Token。</li><li>Access Token 用于访问受保护的资源，通常具有较短的有效期，比如几分钟到几小时。</li><li>Refresh Token 用于获取新的 Access Token，通常具有较长的有效期，比如几天到几个月。</li></ol></li><li>Access Token 过期处理：当 Access Token 过期时，用户需要使用 Refresh Token 来获取新的 Access Token，而无需重新输入用户名和密码。</li><li>Refresh Token 安全性：<ol><li>Refresh Token 通常具有较长的有效期，因此需要确保其安全性，防止被盗用。可以通过以下方式提高其安全性：<ul><li>将 Refresh Token 存储在安全的地方，比如 HTTP-only Cookie 或者安全存储。</li><li>使用 HTTPS 加密传输 Refresh Token，防止被中间人窃取。</li></ul></li></ol></li><li>Access Token 的定期刷新：在获取新的 Access Token 时，可以同时返回新的 Refresh Token，以确保用户持续的访问权限。</li></ol><p>通过双令牌认证方案，用户可以在不影响用户体验的情况下持续访问受保护的资源，并且可以有效地提高安全性，防止令牌被截取或滥用。</p><h2 id="8-为什么需要JWT？-x2F-解决了什么问题？相比之前的-cookie-session-，改用-jwt-有什么好处？"><a href="#8-为什么需要JWT？-x2F-解决了什么问题？相比之前的-cookie-session-，改用-jwt-有什么好处？" class="headerlink" title="8 .为什么需要JWT？/解决了什么问题？相比之前的 cookie + session ，改用 jwt 有什么好处？"></a>8 .为什么需要JWT？/解决了什么问题？相比之前的 cookie + session ，改用 jwt 有什么好处？</h2><p>JWT 和cookie + session功能类似，都是用于身份验证和授权</p><p>优点：</p><ol><li>无状态：服务器不需要再内存中保存用户的会话信息，因为JWT中已经包含了用户的所有必要信息</li><li>跨域支持：因为JWT是在网络请求的头部中传输的，而cookie+session跨域访问需要额外的配置和处理</li><li>可扩展性强：可以包含任意的Json数据，满足不同场景的需求</li><li>性能更好：减少服务器负载，还可以通过缓存或者CDN进行缓存，进一步提升性能</li><li>安全性：数字签名和加密算法</li></ol><h2 id="9-整个JWT是怎么设计的"><a href="#9-整个JWT是怎么设计的" class="headerlink" title="9. 整个JWT是怎么设计的"></a>9. 整个JWT是怎么设计的</h2><ol><li>令牌类型：JWT（JSON Web Token）</li><li>令牌内容：确定令牌中包含的信息，如用户<strong>身份信息、权限信息</strong>、过期时间等。</li><li>令牌签名或加密：使用后SHA256进行签名</li><li>令牌传输： HTTPS 加密通信</li><li>令牌存储：本地存储（如 Local Storage 或者 Session Storage）、HTTP Only Cookie 中</li><li>令牌刷新机制：双令牌认证方案</li><li>令牌管理：好像没有</li></ol><p>Or 见代码实现part</p><h2 id="10-令牌存储-x2F-为什么用redis存jwt"><a href="#10-令牌存储-x2F-为什么用redis存jwt" class="headerlink" title="10. 令牌存储/为什么用redis存jwt"></a>10. 令牌存储/为什么用redis存jwt</h2><p>本地：Local Storage</p><p>服务器：Redis</p><p>提高性能、减轻数据库负担、高可用性、分布式系统、数据持久化</p><h2 id="11-怎么防止别人用你的token干坏事"><a href="#11-怎么防止别人用你的token干坏事" class="headerlink" title="11. 怎么防止别人用你的token干坏事"></a>11. 怎么防止别人用你的token干坏事</h2><p>分两步：防止别人拿到token；防止别人干坏事</p><p> 防止别人拿到token：</p><ol><li>使用安全的<strong>传输</strong>协议：比如使用 HTTPS 协议来加密通信，防止中间人窃取 token。</li><li>限制 token 的<strong>使用</strong>有效期，刷新 token 机制</li><li>使用<strong>签名验证</strong>：在验证 token 时，确保 token 的签名是有效的，并且是由信任的签发者签发的。这可以防止伪造 token 或者篡改 token 内容。</li></ol><p> 防止别人干坏事：</p><ol><li>限制 token 的<strong>使用范围</strong>：限制 token 只能用于特定的 API 路径或者特定的操作</li><li><strong>定期监控</strong> token 的使用情况</li></ol><h2 id="12-使用JWT时，如果一个用户把token给了另外一个用户恶意同时登录怎么处理"><a href="#12-使用JWT时，如果一个用户把token给了另外一个用户恶意同时登录怎么处理" class="headerlink" title="12. 使用JWT时，如果一个用户把token给了另外一个用户恶意同时登录怎么处理 ?"></a>12. 使用JWT时，如果一个用户把token给了另外一个用户恶意同时登录怎么处理 ?</h2><ol><li>限制令牌的使用范围：可以在 JWT 中包含一些额外的声明（Claims），如用户的 IP 地址、用户角色等信息</li><li>实施单点登录（SSO）限制用户同时登录的设备数量</li><li>限制有效期</li><li>定期监控</li></ol><h2 id="13-对比jwt与token"><a href="#13-对比jwt与token" class="headerlink" title="13. 对比jwt与token"></a>13. 对比jwt与token</h2><ul><li>格式：JWT 是一种特定的令牌格式，它使用 JSON 对象作为载荷，并使用签名或加密来保证其完整性和安全性。而 Token 则是一个更广义的概念，可以是任何形式的凭证。</li><li>安全性：JWT 通过签名或加密来保证其安全性，而普通的 Token 可能没有这种安全保障。</li><li>使用场景：JWT 主要用于实现无状态的身份验证和授权，而 Token 可以用于各种场景，包括 OAuth 授权、访问令牌、刷新令牌等。</li></ul><p>总的来说，<strong>JWT 是 Token 的一种特定格式</strong>，它具有一定的安全性和标准化，适用于实现无状态的身份验证和授权。而 Token 则是一个更广义的概念，可以是各种形式的凭证，用于各种身份验证和授权场景。</p><h2 id="14-cookie了解吗"><a href="#14-cookie了解吗" class="headerlink" title="14. cookie了解吗"></a>14. cookie了解吗</h2><p>存储在<strong>客户端</strong>的小型文本文件，用于跟踪用户在网站上的活动，并且在用户访问同一网站时发送回服务器。</p><p>它们经常被用来实现用户认证、会话跟踪、个性化设置等功能。</p><p>由一组名称/值对组成，以及一些可选的属性。</p><blockquote><p>属性：name——表示名称</p><p>expires——过期时间</p><p>path——可以访问路径</p><p>domain——可访问域名</p><p>secure—— 只能通过 HTTPS 连接传输</p><p>HttpOnly——只能通过 HTTP 或 HTTPS 协议访问，而不能通过客户端脚本（如 JavaScript）访问，以防止跨站脚本（XSS）攻击。</p></blockquote><p>使用cookie需要注意安全性：跨站脚本（XSS）攻击和跨站请求伪造（CSRF）</p><h2 id="15-再让你优化项目还能怎么优化"><a href="#15-再让你优化项目还能怎么优化" class="headerlink" title="15. 再让你优化项目还能怎么优化"></a>15. 再让你优化项目还能怎么优化</h2><ol><li>减小 JWT 的大小：只包含必要的信息</li><li>缓存用户信息：减少每次请求都需要解析 JWT 的开销。</li><li>实现 Token 的刷新机制：减少用户频繁登录的次数，提高用户体验。</li><li>限制 Token 的访问权限：可以减少对数据库的访问次数，提高性能。</li><li>使用 CDN 和反向代理：可以使用 CDN（内容分发网络）和反向代理来缓存和分发 JWT Token，减轻服务器的负载，提高响应速度。</li></ol><h2 id="16-如何防止jwt传输途中被截取"><a href="#16-如何防止jwt传输途中被截取" class="headerlink" title="16. 如何防止jwt传输途中被截取"></a>16. 如何防止jwt传输途中被截取</h2><ol><li>使用 HTTPS 加密传输：最有效的方式是通过使用 HTTPS 协议来加密通信。HTTPS 使用了 TLS/SSL 加密技术</li><li>避免在 URL 中传输 JWT：不要将 JWT 直接作为 URL 参数传递，因为 URL 参数可能会被记录在日志中或者在浏览器历史记录中留下痕迹，增加了被截取的风险。而是应该将 JWT 放在 HTTP 头部的 Authorization 字段中进行传输。</li><li>实现 Token 的签名验证：在服务器端对接收到的 JWT 进行签名验证，确保 JWT 的完整性。</li><li>使用短期有效的 JWT</li><li>实现 Token 的刷新机制</li><li>额外的安全层：在 JWT 中添加额外的安全层，如 CSRF Token，防止 CSRF 攻击；或者在敏感操作中使用双因素身份验证等。</li></ol><h2 id="17-JWT缺点"><a href="#17-JWT缺点" class="headerlink" title="17. JWT缺点"></a>17. JWT缺点</h2><ol><li>无法撤销：一旦 JWT 被签发，除非它达到了过期时间，否则它就是有效的。</li><li>体积较大：JWT 包含了一些额外的信息，如标头、声明和签名等</li><li>无法进行会话管理：无法像传统的基于会话的身份验证那样进行会话管理，如主动注销或者强制用户重新验证。</li><li>安全性依赖于密钥安全性</li><li>不适用于敏感信息存储</li></ol><h2 id="18-JWT能够保证安全性吗？"><a href="#18-JWT能够保证安全性吗？" class="headerlink" title="18. JWT能够保证安全性吗？"></a>18. JWT能够保证安全性吗？</h2><p>Or 保证token存储在本地安全？</p><p>JWT 本身并不能完全保证安全性，它只是一种规范和标准，用于生成和传递令牌。安全性取决于如何使用 JWT 以及其他安全措施的配合。如：</p><ol><li>使用安全的存储机制：选择适合的存储机制来存储 Token，如浏览器的本地存储（如 Local Storage 或者 Session Storage）、HTTP Only Cookie 等</li><li>服务端管理好密钥</li><li>定期更新令牌</li><li>限制令牌访问范围</li><li>HTTPS加密传输</li><li>避免在url中传递敏感信息</li><li>避免XSS（跨站脚本）攻击</li></ol><h2 id="19-如何保证token过期刷新"><a href="#19-如何保证token过期刷新" class="headerlink" title="19. 如何保证token过期刷新"></a>19. 如何保证token过期刷新</h2><p>使用刷新令牌：除了访问令牌（Access Token）外，还可以为用户颁发一个刷新令牌（Refresh Token）</p><p>在访问令牌过期之前，每次访问可以通过向服务器发送特定的请求来刷新令牌</p><h2 id="20-无状态登录和有状态登录的区别"><a href="#20-无状态登录和有状态登录的区别" class="headerlink" title="20. 无状态登录和有状态登录的区别"></a>20. 无状态登录和有状态登录的区别</h2><ol><li>无状态登录（Stateless Login）：<ol><li>在无状态登录中，服务器不需要保存用户的会话状态。客户端在之后的每次请求中都会将该 JWT 作为身份凭证发送给服务器，服务器只需要验证 JWT 的有效性，而不需要在服务器端保存任何会话信息。</li><li>由于服务器不保存会话状态，因此无状态登录适用于分布式和跨域应用环境，具有更好的可扩展性和性能。</li></ol></li><li>有状态登录（Stateful Login）：<ol><li>在有状态登录中，服务器需要在服务器端保存用户的会话状态。每次用户进行身份验证时，服务器会将用户的会话信息保存在服务器端，并返回一个会话标识符（Session ID）给客户端。</li><li>客户端在之后的每次请求中都会将会话标识符发送给服务器，服务器通过会话标识符来识别用户的会话状态，从而进行身份验证和授权。</li></ol></li></ol><h2 id="21-退出登录、注册怎么通过JWT实现？"><a href="#21-退出登录、注册怎么通过JWT实现？" class="headerlink" title="21. 退出登录、注册怎么通过JWT实现？"></a>21. 退出登录、注册怎么通过JWT实现？</h2><ol><li>退出登录：退出登录通常意味着销毁客户端保存的 JWT 令牌。<ol><li>客户端发送一个特殊的请求，如注销请求，到服务器端。</li><li>服务器端收到注销请求后，将相应用户的 JWT 令牌加入一个黑名单列表或者删除相应的令牌信息。</li><li>客户端收到服务器的响应后，删除本地存储的 JWT 令牌，使用户被注销。</li></ol></li><li>注册：<ol><li>客户端向服务器发送注册请求，包含新用户的注册信息，如用户名和密码等。</li><li>服务器接收到注册请求后，验证注册信息的合法性，并创建新用户。随后，服务器生成相应用户的 JWT 令牌，并将其返回给客户端。</li><li>客户端收到服务器返回的 JWT 令牌后，将其保存在本地，以便在以后的请求中使用。</li></ol></li></ol><h2 id="22-如果用户更改了密码，如何处理jwt令牌"><a href="#22-如果用户更改了密码，如何处理jwt令牌" class="headerlink" title="22. 如果用户更改了密码，如何处理jwt令牌"></a>22. 如果用户更改了密码，如何处理jwt令牌</h2><p>让令牌失效：</p><ol><li>强制用户重新登录：当用户更改密码后，服务器端直接删除用户之前的所有 JWT 令牌，并要求用户重新登录。</li><li>使用密码加盐：在用户更改密码时，修改用户的密码同时也修改密码的盐值。</li><li>添加版本号或时间戳：在 JWT 的负载中添加一个版本号或者时间戳字段，表示用户的密码版本或者密码修改时间。</li></ol><h2 id="23-怎么让JWT提前失效"><a href="#23-怎么让JWT提前失效" class="headerlink" title="23. 怎么让JWT提前失效"></a>23. 怎么让JWT提前失效</h2><ol><li>设置过期时间（exp）：JWT 的playLoad中包含了一个名为 “exp” 的声明，可以设置</li><li>撤销令牌：维护一个令牌撤销列表，当用户注销或者改变了密码时，将相应的令牌加入到撤销列表中，以使这些令牌失效。</li><li>使用刷新令牌：刷新令牌有更长的有效期，可以获取访问令牌。一旦刷新令牌失效或者被使用，之前颁发的访问令牌就会提前失效。</li></ol><h2 id="24-强行让JWT失效会发生什么事情？"><a href="#24-强行让JWT失效会发生什么事情？" class="headerlink" title="24. 强行让JWT失效会发生什么事情？"></a>24. 强行让JWT失效会发生什么事情？</h2><p>JWT通常被设计为服务器不需要在数据库中存储任何关于令牌的信息</p><p>然而，如果强行让 JWT 失效，通常需要在服务器端维护一个令牌的黑名单或者撤销列表，这就涉及到在数据库或者其他持久化存储中存储令牌信息，违背了 JWT 无状态的初衷。</p><h2 id="25-除了JWT还有没有别的方案，它们之间的优缺点分别是什么"><a href="#25-除了JWT还有没有别的方案，它们之间的优缺点分别是什么" class="headerlink" title="25. 除了JWT还有没有别的方案，它们之间的优缺点分别是什么"></a>25. 除了JWT还有没有别的方案，它们之间的优缺点分别是什么</h2><ol><li>Cookie + session</li><li>OAuth：通常用于实现第三方登录</li><li>JWT：实现无状态的用户身份验证和授权，适用于需要在不同的应用之间传递用户身份信息的情况，如单点登录、跨域认证等。</li></ol><h2 id="26-介绍一下单点登录，jwt怎么实现单点登录？"><a href="#26-介绍一下单点登录，jwt怎么实现单点登录？" class="headerlink" title="26. 介绍一下单点登录，jwt怎么实现单点登录？"></a>26. 介绍一下单点登录，jwt怎么实现单点登录？</h2><p>单点登录（Single Sign-On，简称 SSO）是一种身份认证的机制，允许用户通过一次登录，就能够访问多个相关的系统或服务。</p><p> 在一个认证中心进行登录，获取JWT，然后访问其他服务都将这个JWT作为身份凭证发送给服务端</p><p> 而且JWT可以实现自定义声明，适用于单点登录</p><h2 id="27-跨域是什么，为什么会有跨域问题？"><a href="#27-跨域是什么，为什么会有跨域问题？" class="headerlink" title="27. 跨域是什么，为什么会有跨域问题？"></a>27. 跨域是什么，为什么会有跨域问题？</h2><p>跨域（Cross-Origin）是指在 Web 开发中，当一个域名下的文档或脚本试图去请求另一个域名下的资源时，就会产生跨域问题。</p><p>跨域流程：</p><ol><li>用户登录：用户在任意一个服务器上进行登录，登录成功后，服务器生成 JWT 并将其返回给客户端。</li><li>JWT 传递：客户端收到 JWT 后，将其保存在本地，通常是在浏览器的本地存储（如 Local Storage）或者 Cookie 中。</li><li>跨域请求：用户在其他服务器上进行访问时，客户端将 JWT 放入请求头中（通常是 Authorization 头），发送到另一个服务器。</li><li>JWT 验证：另一个服务器接收到请求后，验证 JWT 的签名和有效期。如果验证通过，则说明用户已经通过认证，可以继续处理请求；否则，返回相应的错误信息。</li><li>响应处理：另一个服务器处理完请求后，可以生成新的 JWT 并返回给客户端，以便客户端在下次请求时继续使用。</li></ol><p>跨域问题产生的原因主要有以下几点：</p><ol><li>同源策略（Same-Origin Policy）：同源策略是浏览器的一项安全策略，限制了一个域下的文档或脚本与另一个域下的资源进行交互。同源策略规定了只有当请求的协议、主机和端口号完全一致时，才允许进行跨域请求，否则就会产生跨域问题。</li><li>安全性考虑：跨域请求可能会带来安全隐患，比如跨站脚本（XSS）攻击和跨站请求伪造（CSRF）攻击等。浏览器为了保护用户的信息安全，因此默认情况下会阻止跨域请求。</li><li>浏览器限制：浏览器出于安全考虑，对跨域请求进行了限制，包括不允许跨域读取 Cookie、不允许跨域访问 DOM 和不允许跨域发送 AJAX 请求等。</li></ol><p>跨域问题会影响到 Web 开发中的很多场景，比如跨域 AJAX 请求、跨域资源共享（CORS）、跨文档消息传递（PostMessage）等。为了解决跨域问题，通常可以采取以下几种方法：</p><ul><li>CORS（Cross-Origin Resource Sharing）：通过服务端设置响应头来允许跨域请求，从而在客户端浏览器上解决跨域问题。<ul><li>使用 @CrossOrigin 注解</li><li>全局配置 CORS<code>public class CorsConfig implements WebMvcConfigurer</code></li><li>通过配置文件配置 CORS</li></ul></li><li>WebSocket：WebSocket 不受同源策略的限制，可以通过建立 WebSocket 连接来实现跨域通信。</li></ul><h2 id="28-企业有多个服务器多个域名怎么实现jwt？除了jwt还有哪些能实现跨域认证"><a href="#28-企业有多个服务器多个域名怎么实现jwt？除了jwt还有哪些能实现跨域认证" class="headerlink" title="28. 企业有多个服务器多个域名怎么实现jwt？除了jwt还有哪些能实现跨域认证"></a>28. 企业有多个服务器多个域名怎么实现jwt？除了jwt还有哪些能实现跨域认证</h2><ol><li>单点登录</li><li>JWT包含域名信息</li><li>使用统一的认证服务器，负责用户身份认证和生成 JWT。所有的服务器都向该认证服务器发送认证请求，验证用户身份后生成 JWT 返回给客户端。</li></ol><p>其他跨域认证方法：</p><p>1.OAuth2.0</p><h2 id="29-场景题：设计一个手机端扫码登录电脑端的的功能"><a href="#29-场景题：设计一个手机端扫码登录电脑端的的功能" class="headerlink" title="29. 场景题：设计一个手机端扫码登录电脑端的的功能"></a>29. 场景题：设计一个手机端扫码登录电脑端的的功能</h2><ol><li>生成登录二维码：<ol><li>在电脑端的登录页面上生成一个登录二维码。</li><li>二维码内容可以是一个唯一的标识符，代表着当前登录会话的标识。</li></ol></li><li>手机端扫码</li><li>验证二维码：<ol><li>手机端扫描到二维码后，将二维码的内容发送到服务器进行验证。</li><li>服务器验证二维码的有效性，并确定该二维码对应的登录会话是否有效。</li></ol></li><li>登录确认：<ol><li>如果二维码有效，服务器返回登录确认信息给手机端。</li><li>手机端接收到确认信息后，提示用户确认登录操作。</li></ol></li><li>登录处理：<ol><li>用户在手机端确认登录操作后，手机端发送登录请求给服务器，携带用户身份信息。</li><li>服务器验证用户身份信息，并在后台完成登录流程。</li></ol></li><li>登录状态同步：<ol><li>服务器在登录成功后，在电脑端和手机端均生成对应的登录状态信息（如登录令牌或者会话标识）。</li><li>电脑端和手机端均保存登录状态信息，以便在后续的操作中进行身份验证和授权。</li></ol></li><li>登录完成：<ol><li>登录完成后，电脑端和手机端均显示登录成功的提示。</li><li>用户可以在电脑端和手机端自由操作，并保持登录状态的同步。</li></ol></li></ol><h2 id="30-其他：websock……"><a href="#30-其他：websock……" class="headerlink" title="30. 其他：websock……"></a>30. 其他：websock……</h2><p>如何自定义登录接口以及jwt过滤器</p><p>websocket 轮询什么的</p><h2 id="扩展：集成-Sa-token-实现角色认证和权限认证，并使用Redis集成进行缓存，添加API签名参数增强"><a href="#扩展：集成-Sa-token-实现角色认证和权限认证，并使用Redis集成进行缓存，添加API签名参数增强" class="headerlink" title="扩展：集成 Sa-token 实现角色认证和权限认证，并使用Redis集成进行缓存，添加API签名参数增强"></a>扩展：集成 Sa-token 实现角色认证和权限认证，并使用Redis集成进行缓存，添加API签名参数增强</h2><p><a href="https://sa-token.cc/doc.html#/up/integ-redis">Sa-Token</a></p><p>oauth2.0 vs sso，jwt 双token</p><p>为什么不选择SpringSecurity 、Shiro</p><ol><li>需求能否被胜任：单点登录, 身份切换, 等等等等, 以及可能产生的需求, auth2, 动态鉴权</li><li>上手难度小：SaToken最简单, Shiro中规中矩, SpringSecurity最繁琐</li><li>友好程度：文档是否友好, demo是否完善, 以及各大论坛博客文章错误内容多不多. 如果是中文的话SaToken更友好, 英文则SpringSecurity</li></ol><p>登录的逻辑，需要从请求发到服务端开始，说清楚springmvc的处理流程，然后在到业务处理，包括方法的返回值都要说清楚。</p><p>API签名参数</p><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/asynccode" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目开发操作笔记</title>
      <link href="/2023/09/22/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/22/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="项目操作"><a href="#项目操作" class="headerlink" title="项目操作"></a>项目操作</h2><ol><li><p>SpringBoot 初始化：</p><ol><li><strong>Spring Initializr 一般 jdk 选 8，版本选 3.0 以下的（报错的话重新初始化）</strong></li><li>常见依赖：SpringWeb、SpringConfigurationProcessor、SpringBootDevTools、mysqlDriver、junit、mybatisFramework、Lombok</li><li>如果是直接下载的整个项目文件的pom.xml版本报错，先右键重新加载成maven文件</li><li>application.yml不是小绿叶而是红色的：<ol><li>找到maven重新刷一遍<img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/image-20240423164720658.png" alt="image-20240423164720658"></li><li>还不行的话看这个：[IDEA创建application.yml不是小绿叶图标解决办法](<a href="https://blog.csdn.net/weixin_43085797/article/details/106333243#:~:text=1%E3%80%81File">https://blog.csdn.net/weixin_43085797/article/details/106333243#:~:text=1、File</a> &gt;&gt;Project Structure 将项目关联到spring中 2、File &gt;&gt;Project,Structure 将项目resources文件变成配置文件夹 选中java文件夹，点击Sources，将java文件夹变成下图所示，这样才能在java这个文件夹里面新建java.class 3、添加application.yml 4、添加启动类 在启动类上加%40SpringBootApplication注解提升没有这个包，点击下载 完美解决，application.yml变成绿叶了)</li></ol></li></ol></li><li><p>常量可以专门放在一个包里面（比如说是 controller、service 都要用的那种）</p><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/image-20240423165243283.png" alt="image-20240423165243283"></p></li><li><p>导包相关操作</p><ol><li><p><code>http://mvnrepository.com/</code>这里面找</p></li><li><p>选择风险点少的，人数多的</p></li><li><p>复制依赖进 pom.xml，再刷新就行【有时需要注意各个包之间的版本关系】</p></li></ol></li><li><p>Test 类增加断言：<code>Assertions.assertEquals(预期值, 实际值);</code></p></li><li><p>封装全局异常处理逻辑关系：<code>ErrorCode</code>定义错误码  –&gt;<code>ResultUtil</code> 利用<code>BaseResponce</code>生成响应对象  –&gt; <code>BusinessException</code> 用于标识业务异常  –&gt;   <code>GlobalExceptionHandler</code> 用于捕获和处理这些异常并返回适当的响应</p></li><li><p><code>throw new RuntimeException("xxx");</code>和<code>return Result.fail(xxx);</code>的区别</p></li><li><blockquote><p>抛出异常会被全局异常处理器捕获，返回fail不会</p></blockquote></li><li><p>用Object数据类型获取session属性值</p><ol><li><p>Object是 Java 中的一个通用数据类型，是所有类的超类。因此，<code>Object</code> 可以用来表示任何 Java 对象。【很牛的功能】</p></li><li><p><code>session.getAttribute("xxx")</code> 方法返回的值是一个通用的 <code>Object</code> 类型，因为会话可以存储各种不同类型的数据</p></li><li><p>如果知道是具体的数据类型也可以进行转换</p></li></ol></li><li><pre><code class="Java">String code = (String) cacheCode; // 将 Object 强制转换为 String<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. 自动装箱和自动拆箱</span><br><span class="line"></span><br><span class="line">   1. 自动装箱（Autoboxing）：将基本数据类型转换为对应的包装类对象。</span><br><span class="line"></span><br><span class="line">   1. 自动拆箱（Unboxing）：将包装类对象转换为对应的基本数据类型。</span><br><span class="line"></span><br><span class="line">   1. ❗尤其注意：如果尝试对一个为null的包装类对象进行自动拆箱，会导致NullPointerException异常，因此在使用自动拆箱时需要谨慎处理可能为null的情况。</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">Integer num = 5; // 自动装箱：将int类型的5自动转换为Integer对象</span><br><span class="line">int intValue = num; // 自动拆箱：将Integer对象num自动转换为int类型</span><br></pre></td></tr></tbody></table></figure></code></pre></li><li><p>巧用泛型写工具类（redis）</p></li><li><p>使用ThreadLocal获取当前登录用户</p></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal 是一个线程级别的变量，它允许你在每个线程中存储和访问不同的数据。</span></span><br><span class="line"><span class="comment">// 使用 ThreadLocal 存储 UserDTO 对象，使得每个线程都可以独立地访问自己的 UserDTO 实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>{tl.set(user);}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>{<span class="keyword">return</span> tl.get();}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>{tl.remove();}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="11"><li>Idea启动多个SpringBoot项目 <a href="https://blog.csdn.net/linxingliang/article/details/129248244">https://blog.csdn.net/linxingliang/article/details/129248244</a></li></ol><h2 id="辅助工具操作（插件-x2F-库）"><a href="#辅助工具操作（插件-x2F-库）" class="headerlink" title="辅助工具操作（插件/库）"></a>辅助工具操作（插件/库）</h2><ol><li><code>MybatisX-Generato</code>r 快速生成 domain、mapper、service 配置</li><li><code>apache common utils</code>库：很好用，比如说判断字符串是否为空<code>StringUtills.isAnyBlank(s1,s2...)</code></li><li><code>mybatisplus</code> 可以默认帮助我们查询出来没有被删的用户：application 配置 + @TableLogic 配置：<a href="https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">逻辑删除 | MyBatis-Plus (baomidou.com)</a></li><li>想输出日志时传入多个参数的log要从@sl4fj导入，不然只能传一个参数</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">log.debug(<span class="string">"发送验证码：{}，到手机：{}"</span>, code, phone);</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><p>TODO:检验数据输入格式是否正确：封装正则表达式  ——&gt; 能不能直接调用个第三方库</p></li><li><p>MyBatis-Plus——LambdaQueryWrapper的使用</p></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// QueryWrapper  最基础的使用方法</span></span><br><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(<span class="string">"name"</span>, name);</span><br><span class="line">List&lt;User&gt; userList= userMapper.selectList(wrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入lambda 避免写类似name的硬编码，代码更加简洁，适用于不需要动态构建查询条件的情况</span></span><br><span class="line">List&lt;User&gt; userList= <span class="built_in">this</span>.lambdaQuery()..eq(User::getName, name).select();</span><br><span class="line"></span><br><span class="line"><span class="comment">// LambdaQueryWrapper  简化lambda的使用，更加灵活，可以根据不同的条件动态添加查询条件。</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().lambda();</span><br><span class="line">wrapper.eq(User::getName, name);;</span><br><span class="line">List&lt;User&gt; userList= userMapper.selectList(wrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再简化</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getName, name);</span><br><span class="line">List&lt;User&gt; userList= userMapper.selectList(wrapper);</span><br></pre></td></tr></tbody></table></figure><p>常见方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> wrapper.eq(<span class="string">"实体类::查询字段"</span>, <span class="string">"条件值"</span>); <span class="comment">//相当于where条件</span></span><br><span class="line"> wrapper.between(<span class="string">"实体类::查询字段"</span>, <span class="string">"区间一"</span>, <span class="string">"区间二"</span>);<span class="comment">//相当于范围内使用的between</span></span><br><span class="line"> wrapper.like(<span class="string">"实体类::查询字段"</span>, <span class="string">"模糊查询的字符"</span>); <span class="comment">//模糊查询like</span></span><br><span class="line"> wrapper.groupBy(<span class="string">"实体类::查询字段"</span>);  <span class="comment">//相当于group by分组</span></span><br><span class="line"> wrapper.in(<span class="string">"实体类::查询字段"</span>, <span class="string">"包括的值,分割"</span>); <span class="comment">//相当于in</span></span><br><span class="line"> wrapper.orderByAsc(<span class="string">"实体类::查询字段"</span>); <span class="comment">//升序</span></span><br><span class="line"> wrapper.orderByDesc(<span class="string">"实体类::查询字段"</span>);<span class="comment">//降序</span></span><br><span class="line"> wrapper.ge(<span class="string">"实体类::查询字段"</span>, <span class="string">"要比较的值"</span>); <span class="comment">//大于等于</span></span><br><span class="line"> wrapper.le(<span class="string">"实体类::查询字段"</span>, <span class="string">"要比较的值"</span>); <span class="comment">//小于等于</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 动态查询，第一个参数必须为true是才添加到查询中</span></span><br><span class="line"> queryWrapper.eq(StringUtils.isNotBlank(phone),User::getPhone,phone);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 此外，MyBatis-Plus还提供了一种链式查询的方式</span></span><br><span class="line">List&lt;User&gt; bannerItems = <span class="keyword">new</span> <span class="title class_">LambdaQueryChainWrapper</span>&lt;&gt;(userMapper)</span><br><span class="line">                       .eq(User::getName, name)</span><br><span class="line">                       .list();</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li><p>BeanUtils.copyProperties使用</p><ol><li><p>需要对应的属性有 <code>getter</code> 和 <code>setter</code> 方法（内部实现时，使用反射拿到 <code>set</code> 和 <code>get</code> 方法，再去获取/设置属性值）</p></li><li><p>如果两个类之间存在名称不相同的属性，则 BeanUtils 不对这些属性进行处理，需要程序员手动处理。</p></li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">BeanUtils.copyProperties(Object source, Object target); </span><br><span class="line">=&gt; BeanUtils.copyProperties(<span class="string">"转换前的类"</span>, <span class="string">"转换后的类"</span>);  </span><br></pre></td></tr></tbody></table></figure><h2 id="idea-操作"><a href="#idea-操作" class="headerlink" title="idea 操作"></a>idea 操作</h2><ol><li>alt+enter 快捷键<ol><li>创建测试，会在 test 文件夹创建测试类</li><li>Genterate all setter with default value，就会调用该对象所有的 set 方法，并可以指定默认值</li></ol></li><li>ctrl 快捷键<ol><li>ctrl+p，会显示该方法或函数所接受的参数信息【我趣好好用，就是这个快捷键单手不太好按，比弹琴跨得还开、、、】</li><li>ctrl+B 快速进入</li><li>fn+shift+f6 重构</li><li>ctrl + alt + t  构建try方法</li></ol></li><li>private static final  可以先输入 prsf，按下 enter 快速生成</li><li>添加快捷输入（像 sout） 设置—编辑器-实时模板—新建模板/快捷指令，类似<code>ResultUtil.success($END$)</code>，$END$就是输入快捷指令后光标在的位置；然后再 define 里面选上 Java</li><li>注意在写接口的时候先写完接受参数再/**＋回车快速生成注释，因为是 java doc 注解类型，可以直接生成参数和返回类</li><li>idea 自带测试工具，生成的测试在临时文件和控制台里面，（主要是不用自己手敲 url 就比 apifox 方便( •̀ ω •́ )y</li><li>在 service 修改了参数之后，点击左侧的 R 可以快速在 serviceimpl 中添加这个参数</li><li>在 serviceimpl 中写好了方法，再加个@Override 就可以直接拉到 service 中</li><li>写控制器函数快速填参：插件 Auto filling Java call arguments，鼠标放在括号中间 alt+enter（虽然 copilot 也会自动提示(●’◡’●)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/image-20240423165045469.png" alt="image-20240423165045469"></p><h2 id="代码操作"><a href="#代码操作" class="headerlink" title="代码操作"></a>代码操作</h2><ol><li>序列化相关操作代码：</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6615735376118984333L</span>;</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><p>注解类</p><ol><li><p><code>@Data</code>注解作用：简化一般实体类的 get, set, toString，construct（构造函数）等的书写，简洁化代码。@Data≈@Getter + @Setter + toString() + equals 等方法</p></li><li><p><code>@RestController</code>注解：这个类里面所有的请求的接口返回值，响应的数据类型都是 application.json</p></li><li><p><code>@RequestBody</code>接收前端传递给后端的 json 字符串中的数据</p></li><li><p><code>@RunWith</code>(SpringRunner.class) 表明 Test 测试类要使用注入的类，比如@Autowired 注入的类，有了@RunWith(SpringRunner.class)这些类才能实例化到 spring 容器中，自动注入才能生效</p></li><li><p><code>@RestController</code> // 这个类里面所有的请求的接口返回值，响应的数据类型都是 application json</p></li><li><p><code>@RequestMapping("/user")</code>//定义请求的总路径</p></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 就把前端url请求中的id赋值给followUserId，isFollow赋值给isFollow</span></span><br><span class="line"><span class="meta">@PutMapping("/{id}/{isFollow}")</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable("id")</span>Long followUserId,<span class="meta">@PathVariable("isFollow")</span>Boolean isFollow)</span>{</span><br><span class="line">    <span class="keyword">return</span>  followService.follow(followUserId,isFollow);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>额额额找个时间补一下<code>LambdaQueryWrapper</code></p></li></ol><h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><ol><li>撤销未push的commit<ol><li><p>Git  –  选择Reset HEAD  –  To Commit 填写 HEAD<del>1（撤销一次，两次的话就HEAD</del>2或者HEAD^^，以此类推），相当于终端输出<code>git reset --soft HEAD^</code></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/image-20240423164858246.png" alt="image-20240423164858246"></p></li></ol></li><li>撤销push的内容（hard和soft的区别）<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 本地修改全部清空</span><br><span class="line">git reset --hard 修订号  // 让本地分支回退到指定修订号</span><br><span class="line">git push origin main（分支名） --force    //将本地强制推送到远程</span><br><span class="line"></span><br><span class="line">//不影响任何本地修改</span><br><span class="line">git reset --soft 修订号  // 让本地分支回退到指定修订号</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="奇怪Bug"><a href="#奇怪Bug" class="headerlink" title="奇怪Bug"></a>奇怪Bug</h2><ol><li>额额额什么笨蛋忘记了测试类加@SpringBootTest，所以一直报错空指针异常</li><li>nginx改了端口号但是访问地址没改</li><li>更离谱的出现了，没开mysql服务就去跑后端，出现的报错是 <code>com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure .The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets </code></li></ol><h2 id="常用库："><a href="#常用库：" class="headerlink" title="常用库："></a>常用库：</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>Guava：谷歌开发的 Java 工具库（<a href="https://github.com/google/guava%EF%BC%89">https://github.com/google/guava）</a></li><li>Apache Commons：各类工具库，比如 commons-lang、commons-io、commons-collections 等（<a href="https://github.com/apache/commons-lang%EF%BC%89">https://github.com/apache/commons-lang）</a></li><li>Hutool：Java 工具集库（<a href="https://github.com/looly/hutool%EF%BC%89">https://github.com/looly/hutool）</a></li><li>Lombok：Java 增强库（<a href="https://github.com/projectlombok/lombok%EF%BC%89">https://github.com/projectlombok/lombok）</a></li><li>Apache HttpComponents Client：HTTP 客户端库（<a href="https://github.com/apache/httpcomponents-client%EF%BC%89">https://github.com/apache/httpcomponents-client）</a></li><li>OkHttp：适用于 JVM、Android 等平台的 Http 客户端（<a href="https://github.com/square/okhttp%EF%BC%89">https://github.com/square/okhttp）</a></li><li>Gson：谷歌的 JSON 处理库（<a href="https://github.com/google/gson%EF%BC%89">https://github.com/google/gson）</a></li><li>Jcommander：Java 命令行参数解析框架（<a href="https://github.com/cbeust/jcommander%EF%BC%89">https://github.com/cbeust/jcommander）</a></li><li>Apache PDFBox：PDF 操作库（<a href="https://github.com/apache/pdfbox%EF%BC%89">https://github.com/apache/pdfbox）</a></li><li>EasyExcel：阿里的 Excel 处理库（<a href="https://github.com/alibaba/easyexcel%EF%BC%89">https://github.com/alibaba/easyexcel）</a></li><li>Apache POI：表格文件处理库（<a href="https://github.com/apache/poi%EF%BC%89">https://github.com/apache/poi）</a></li></ul><p><strong>测试</strong></p><ul><li>JUnit：Java 测试框架（<a href="https://github.com/junit-team/junit4%EF%BC%89">https://github.com/junit-team/junit4）</a> </li><li>Mockito：Java 单元测试 Mock 框架（<a href="https://github.com/mockito/mockito%EF%BC%89">https://github.com/mockito/mockito）</a></li><li>Selenium：浏览器自动化框架（<a href="https://github.com/SeleniumHQ/selenium%EF%BC%89">https://github.com/SeleniumHQ/selenium）</a></li><li>htmlunit：Java 模拟浏览器（<a href="https://github.com/HtmlUnit/htmlunit%EF%BC%89">https://github.com/HtmlUnit/htmlunit）</a></li><li>TestNG：Java 测试框架（<a href="https://github.com/cbeust/testng%EF%BC%89">https://github.com/cbeust/testng）</a></li><li>Jacoco：Java 代码覆盖度库（<a href="https://github.com/jacoco/jacoco">https://github.com/jacoco/jacoco</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><ul><li>cglib：字节码生成库（<a href="https://github.com/cglib/cglib%EF%BC%89">https://github.com/cglib/cglib）</a></li><li>Arthas：Java 诊断工具（<a href="https://github.com/alibaba/arthas%EF%BC%89">https://github.com/alibaba/arthas）</a></li><li>config：针对 JVM 的配置库（<a href="https://github.com/lightbend/config%EF%BC%89">https://github.com/lightbend/config）</a></li><li>Quasar：Java 纤程库（<a href="https://github.com/puniverse/quasar%EF%BC%89">https://github.com/puniverse/quasar）</a></li><li>drools：Java 规则引擎（<a href="https://github.com/kiegroup/drools%EF%BC%89">https://github.com/kiegroup/drools）</a></li><li>Caffeine：Java 高性能缓存库（<a href="https://github.com/ben-manes/caffeine%EF%BC%89">https://github.com/ben-manes/caffeine）</a></li><li>Disruptor：高性能线程间消息传递库（<a href="https://github.com/LMAX-Exchange/disruptor%EF%BC%89">https://github.com/LMAX-Exchange/disruptor）</a></li><li>Knife4j：Swagger 文档增强（<a href="https://doc.xiaominfo.com/%EF%BC%89">https://doc.xiaominfo.com/）</a></li><li>Thumbnailator：Java 缩略图生成库（<a href="https://github.com/coobird/thumbnailator%EF%BC%89">https://github.com/coobird/thumbnailator）</a></li><li>Logback：Java 日志库（<a href="https://github.com/qos-ch/logback%EF%BC%89">https://github.com/qos-ch/logback）</a></li><li>Apache Camel：消息传输集成框架（<a href="https://github.com/apache/camel%EF%BC%89">https://github.com/apache/camel）</a></li><li>Quartz：定时任务调度库（<a href="https://github.com/quartz-scheduler/quartz%EF%BC%89">https://github.com/quartz-scheduler/quartz）</a></li><li>Apache Mahout：机器学习库（<a href="https://github.com/apache/mahout%EF%BC%89">https://github.com/apache/mahout）</a></li><li>Apache OpenNLP：NLP 工具库（<a href="https://github.com/apache/opennlp%EF%BC%89">https://github.com/apache/opennlp）</a></li><li>RxJava：JVM 反应式编程框架（<a href="https://github.com/ReactiveX/RxJava%EF%BC%89">https://github.com/ReactiveX/RxJava）</a></li><li>JProfiler：性能分析库（<a href="https://www.ej-technologies.com/products/jprofiler/overview.html%EF%BC%89">https://www.ej-technologies.com/products/jprofiler/overview.html）</a></li><li>jsoup：HTML 文档解析库（<a href="https://jsoup.org/%EF%BC%89">https://jsoup.org/）</a></li><li>webmagic：Java 爬虫框架（<a href="https://github.com/code4craft/webmagic/%EF%BC%89">https://github.com/code4craft/webmagic/）</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫-1.开发环境配置【完善中...】</title>
      <link href="/2023/06/10/1-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/06/10/1-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第一次装到tesserocr就累了╯︿╰，一开始根本不需要用装这么多  –2023.6.10  13:58:2</p></blockquote><h1 id="请求库的安装"><a href="#请求库的安装" class="headerlink" title="请求库的安装"></a>请求库的安装</h1><h2 id="requests安装"><a href="#requests安装" class="headerlink" title="requests安装"></a>requests安装</h2><ul><li><code>pip3 install requests</code></li><li>用于发送 HTTP 请求和处理响应</li><li>可以方便地进行 GET、POST 等请求，设置请求头、请求参数、处理响应结果等操作。</li><li>验证安装：进入python 输入<code>import requests</code>，如无错误提示即成功</li></ul><h2 id="selenium安装"><a href="#selenium安装" class="headerlink" title="selenium安装"></a>selenium安装</h2><ul><li><code>pip3 install selenium</code></li><li>模拟用户在浏览器中的操作,包括点击、输入、提交表单等</li><li>可以驱动真实的浏览器（如 Chrome、Firefox）来加载动态生成的网页内容，并提取或交互其中的数据。通常与浏览器驱动配合使用，如 ChromeDriver 和 GeckoDriver。</li><li>验证安装：同上</li></ul><h2 id="ChromeDriver-安装"><a href="#ChromeDriver-安装" class="headerlink" title="ChromeDriver 安装"></a>ChromeDriver 安装</h2><ul><li><p>浏览器驱动,用于控制 Chrome  浏览器的行为</p></li><li><p>作用：让 <code>selenium</code> 可以控制和与指定的浏览器进行交互</p></li><li><p><a href="https://sites.google.com/a/chromium.org/chromedriver">https://sites.google.com/a/chromium.org/chromedriver</a>  –exe文件放入环境变量配置</p></li><li><p>GeckoDriver 安装  –适用于 Firefox</p></li><li><p>验证安装：</p><ul><li><p>环境变量：终端输入<code>chromedriver</code></p></li><li><p>使用：  打开浏览器</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br></pre></td></tr></tbody></table></figure></li><li><p>出现闪退计版本出现问题【但是我在其他代码上用又不会闪退🤔–待解决】</p></li></ul></li></ul><h2 id="PhantomJS安装-【不维护了】"><a href="#PhantomJS安装-【不维护了】" class="headerlink" title="PhantomJS安装  【不维护了】"></a>PhantomJS安装  【不维护了】</h2><ul><li><p>无界面的浏览器</p></li><li><p>在后台执行网页加载和操作，无需显示浏览器界面</p></li><li><p><a href="http://phantomjs.org/download.html">http://phantomjs.org/download.html</a>  –放入环境变量配置</p></li><li><p>验证安装</p><ul><li><p>环境变量：终端输入<code>phantomjs</code></p></li><li><p>使用</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.PhantomJS()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.current_url)</span><br></pre></td></tr></tbody></table></figure></li><li><p>报错显示<code>module 'selenium.webdriver' has no attribute 'PhantomJS'</code>    –由于维护困难和性能问题，Selenium 社区决定不再支持 PhantomJS 驱动。</p></li><li><p>推荐使用无头浏览器（如 Chrome 或 Firefox）的 Headless 模式替代。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ChromeOptions 对象，并设置无界面模式</span></span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>)  <span class="comment"># 启用无界面模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Chrome WebDriver，将 ChromeOptions 作为参数传递</span></span><br><span class="line">browser = webdriver.Chrome(options=chrome_options)</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.current_url)</span><br><span class="line"></span><br><span class="line">browser.quit()  <span class="comment"># 关闭浏览器</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="aiohttp的安装"><a href="#aiohttp的安装" class="headerlink" title="aiohttp的安装"></a>aiohttp的安装</h2><ul><li><code>pip3 install aiohttp</code>   +   <code>pip3 install cchardet aiodns</code><ul><li>字符编码检测库 cchardet</li><li>加速 DNS 的解析库 aiodns</li></ul></li><li>基于异步请求的 HTTP 客户端/服务器框架，适用于高性能、高并发的网络请求场景</li><li>在处理大规模异步请求时具有优势，可以加快网络爬虫的速度。</li><li>验证安装：进入python输入<code>import aiohttp</code>，如无错误提示即成功</li></ul><h1 id="解析库的安装"><a href="#解析库的安装" class="headerlink" title="解析库的安装"></a>解析库的安装</h1><h2 id="lxml-的安装"><a href="#lxml-的安装" class="headerlink" title="lxml 的安装"></a>lxml 的安装</h2><ul><li><code>pip3 install lxml</code></li><li>支持 HTML 和 XML 的解析，支持 XPath 解析方式，而且解析效率非常高</li><li>验证安装：进入python 输入<code>import lxml</code>，如无错误提示即成功</li></ul><h2 id="Beautiful-Soup-的安装"><a href="#Beautiful-Soup-的安装" class="headerlink" title="Beautiful Soup 的安装"></a>Beautiful Soup 的安装</h2><ul><li><p><code>pip3 install beautifulsoup4</code></p></li><li><p>HTML 或 XML 的解析库，我们可以用它来方便地从网页中提取数据。它拥有强大的 API 和多样的解析方式</p></li><li><p>验证安装</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  </span><br><span class="line">soup = BeautifulSoup(<span class="string">'&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;'</span>, <span class="string">'lxml'</span>)  </span><br><span class="line"><span class="built_in">print</span>(soup.p.string)</span><br><span class="line"><span class="comment"># 输出hello即成功</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="pyquery-的安装"><a href="#pyquery-的安装" class="headerlink" title="pyquery 的安装"></a>pyquery 的安装</h2><ul><li><code>pip3 install pyquery</code></li><li>强大的网页解析工具，它提供了和 jQuery 类似的语法来解析 HTML 文档，支持 CSS 选择器</li><li>验证安装：进入python输入<code>import pyquery</code>，如无错误提示即成功</li></ul><h2 id="tesserocr-的安装"><a href="#tesserocr-的安装" class="headerlink" title="tesserocr 的安装"></a>tesserocr 的安装</h2><ul><li><a href="http://digi.bib.uni-mannheim.de/tesseract">http://digi.bib.uni-mannheim.de/tesseract</a> 下载不带 dev 的版本   + <code>pip3 install tesserocr pillow</code></li><li>用 OCR 来识别图形验证码</li></ul><h1 id="数据库的安装"><a href="#数据库的安装" class="headerlink" title="数据库的安装"></a>数据库的安装</h1><h2 id="MySQL-的安装"><a href="#MySQL-的安装" class="headerlink" title="MySQL 的安装"></a>MySQL 的安装</h2><p><a href="https://blog.csdn.net/SoloVersion/article/details/123760428">MySQL安装配置教程（超级详细、保姆级）_mysql安装教程_SoloVersion的博客-CSDN博客</a></p><h2 id="MongoDB-的安装"><a href="#MongoDB-的安装" class="headerlink" title="MongoDB 的安装"></a>MongoDB 的安装</h2><h2 id="Redis-的安装"><a href="#Redis-的安装" class="headerlink" title="Redis 的安装"></a>Redis 的安装</h2><h1 id="存储库的安装"><a href="#存储库的安装" class="headerlink" title="存储库的安装"></a>存储库的安装</h1><h2 id="PyMySQL-的安装"><a href="#PyMySQL-的安装" class="headerlink" title="PyMySQL  的安装"></a>PyMySQL  的安装</h2><h2 id="PyMongo-的安装"><a href="#PyMongo-的安装" class="headerlink" title="PyMongo 的安装"></a>PyMongo 的安装</h2><h2 id="redis-py-的安装"><a href="#redis-py-的安装" class="headerlink" title="redis-py 的安装"></a>redis-py 的安装</h2><h2 id="RedisDump-的安装"><a href="#RedisDump-的安装" class="headerlink" title="RedisDump 的安装"></a>RedisDump 的安装</h2><h1 id="Web-库的安装"><a href="#Web-库的安装" class="headerlink" title="Web 库的安装"></a>Web 库的安装</h1><h2 id="Flask-的安装"><a href="#Flask-的安装" class="headerlink" title="Flask 的安装"></a>Flask 的安装</h2><h2 id="Tornado-的安装"><a href="#Tornado-的安装" class="headerlink" title="Tornado 的安装"></a>Tornado 的安装</h2><h1 id="App-爬取相关库的安装"><a href="#App-爬取相关库的安装" class="headerlink" title="App 爬取相关库的安装"></a>App 爬取相关库的安装</h1><h2 id="Charles-的安装"><a href="#Charles-的安装" class="headerlink" title="Charles 的安装"></a>Charles 的安装</h2><h2 id="mitmproxy-的安装"><a href="#mitmproxy-的安装" class="headerlink" title="mitmproxy 的安装"></a>mitmproxy 的安装</h2><h2 id="Appium-的安装"><a href="#Appium-的安装" class="headerlink" title="Appium 的安装"></a>Appium 的安装</h2><h1 id="爬虫框架的安装"><a href="#爬虫框架的安装" class="headerlink" title="爬虫框架的安装"></a>爬虫框架的安装</h1><h2 id="pyspider-的安装"><a href="#pyspider-的安装" class="headerlink" title="pyspider 的安装"></a>pyspider 的安装</h2><h2 id="Scrapy-的安装"><a href="#Scrapy-的安装" class="headerlink" title="Scrapy 的安装"></a>Scrapy 的安装</h2><h2 id="Scrapy-Splash-的安装"><a href="#Scrapy-Splash-的安装" class="headerlink" title="Scrapy-Splash 的安装"></a>Scrapy-Splash 的安装</h2><h2 id="Scrapy-Redis-的安装"><a href="#Scrapy-Redis-的安装" class="headerlink" title="Scrapy-Redis 的安装"></a>Scrapy-Redis 的安装</h2><h1 id="部署相关库的安装"><a href="#部署相关库的安装" class="headerlink" title="部署相关库的安装"></a>部署相关库的安装</h1><h2 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h2><h2 id="Scrapyd-的安装"><a href="#Scrapyd-的安装" class="headerlink" title="Scrapyd 的安装"></a>Scrapyd 的安装</h2><h2 id="Scrapyd-Client-的安装"><a href="#Scrapyd-Client-的安装" class="headerlink" title="Scrapyd-Client 的安装"></a>Scrapyd-Client 的安装</h2><h2 id="Scrapyd-API-的安装"><a href="#Scrapyd-API-的安装" class="headerlink" title="Scrapyd API 的安装"></a>Scrapyd API 的安装</h2><h2 id="Scrapyrt-的安装"><a href="#Scrapyrt-的安装" class="headerlink" title="Scrapyrt 的安装"></a>Scrapyrt 的安装</h2><h2 id="Gerapy-的安装"><a href="#Gerapy-的安装" class="headerlink" title="Gerapy 的安装"></a>Gerapy 的安装</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫-3.基本库的使用【未学完...】</title>
      <link href="/2023/06/10/3-%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/06/10/3-%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-urllib"><a href="#使用-urllib" class="headerlink" title="使用 urllib"></a>使用 urllib</h1><p>首先，了解一下 urllib 库，它是 Python 内置的 HTTP 请求库，也就是说不需要额外安装即可使用。它包含如下 4 个模块。</p><ul><li>request：它是最基本的 HTTP 请求模块，可以用来模拟发送请求。就像在浏览器里输入网址然后回车一样，只需要给库方法传入 URL 以及额外的参数，就可以模拟实现这个过程了。</li><li>error：异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。</li><li>parse：一个工具模块，提供了许多 URL 处理方法，比如拆分、解析、合并等。</li><li>robotparser：主要是用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用得比较少。</li></ul><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h3><ul><li><p>构造方法</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">urllib.request.urlopen(url, data=<span class="literal">None</span>, [timeout,]-, cafile=<span class="literal">None</span>, capath=<span class="literal">None</span>, cadefault=<span class="literal">False</span>, context=<span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>基本使用</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://www.python.org'</span>)</span><br><span class="line"><span class="comment"># 获取返回类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response))</span><br><span class="line"><span class="comment"># 获取返回结果的状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.status)</span><br><span class="line"><span class="comment"># 获取响应头的各数据</span></span><br><span class="line"><span class="built_in">print</span>(response.getheaders())</span><br><span class="line"><span class="comment"># 获取了响应头中的 Server 值，结果是 nginx，意思是服务器是用 Nginx 搭建的。</span></span><br><span class="line"><span class="built_in">print</span>(response.getheader(<span class="string">'Server'</span>))</span><br><span class="line"><span class="comment">#获取读取信息，即网页的源代码</span></span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></tbody></table></figure></li><li><p>data参数<br>将参数转化为字节流编码格式的内容，即 bytes 类型，POST请求方式</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse  </span><br><span class="line"><span class="keyword">import</span> urllib.request  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取hello！xxz，会传送到运行结果的word --POST模拟表单获取</span></span><br><span class="line"><span class="comment">#  urlencode 方法来将参数字典转化为字符串</span></span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode({<span class="string">'word'</span>: <span class="string">'hello'</span>}), encoding=<span class="string">'utf8'</span>)  </span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://httpbin.org/post'</span>, data=data)  </span><br><span class="line"><span class="built_in">print</span>(response.read())</span><br></pre></td></tr></tbody></table></figure></li><li><p>timeout参数</p><p>  用于设置超时时间，单位为秒；如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常  </p><blockquote><p>可以通过设置这个超时时间来控制一个网页如果长时间未响应，就跳过它的抓取</p></blockquote>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line"><span class="keyword">import</span> urllib.request  </span><br><span class="line"><span class="keyword">import</span> urllib.error  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'http://httpbin.org/get'</span>, timeout=<span class="number">0.1</span>)  </span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="comment"># socket.timeout --超时异常</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(e.reason, socket.timeout):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'TIME OUT'</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>其他参数</p><p>context 参数，它必须是 ssl.SSLContext 类型，用来指定 SSL 设置</p><p>……</p><p>详见文档：<a href="https://docs.python.org/3/library/urllib.request.html">urllib.request — 用于打开 URL 的可扩展库 — Python 3.11.4 文档</a></p></li></ul><h3 id="Requset-power"><a href="#Requset-power" class="headerlink" title="Requset[power!]"></a>Requset[power!]</h3><p>如果请求中需要加入 Headers 等信息，就可以利用更强大的 Request 类来构建</p><ul><li><p>Request构造方法</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">urllib</span>.request.Request(url, data=<span class="literal">None</span>, headers={}, origin_req_host=<span class="literal">None</span>, unverifiable=<span class="literal">False</span>, method=<span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure><ul><li><p>url 用于请求 URL，这是必传参数，其他都是可选参数。</p></li><li><p>data 如果要传，必须传 bytes（字节流）类型的。如果它是字典，可以先用 urllib.parse 模块里的 urlencode() 编码。</p></li><li><p>headers 是一个字典，它就是请求头，我们可以在构造请求时通过 headers 参数直接构造，也可以通过调用请求实例的 add_header() 方法添加。</p></li><li><p>unverifiable 表示这个请求是否是无法验证的，默认是 False，意思就是说用户没有足够权限来选择接收这个请求的结果。例如，我们请求一个 HTML 文档中的图片，但是我们没有自动抓取图像的权限，这时 unverifiable 的值就是 True。</p></li><li><p>method 是一个字符串，用来指示请求使用的方法，比如 GET、POST 和 PUT 等。</p></li></ul></li><li><p>初步使用</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse  </span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span>  </span><br><span class="line">headers = {<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>,  </span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'httpbin.org'</span>  </span><br><span class="line">}  </span><br><span class="line"><span class="built_in">dict</span> = {<span class="string">'name'</span>: <span class="string">'Germey'</span>}  </span><br><span class="line"><span class="comment"># data用 urlencode 和 bytes 方法转成字节流</span></span><br><span class="line">data = <span class="built_in">bytes</span>(parse.urlencode(<span class="built_in">dict</span>), encoding=<span class="string">'utf8'</span>)  </span><br><span class="line">req = request.Request(url=url, data=data, headers=headers, method=<span class="string">'POST'</span>)  </span><br><span class="line"><span class="comment"># headers 也可以用 add_header 方法来添加</span></span><br><span class="line"><span class="comment"># req.add_header('User-Agent', 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)')</span></span><br><span class="line">response = request.urlopen(req)  </span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="power"><a href="#power" class="headerlink" title="power!"></a>power!</h3><ul><li><p>Handler</p><p>把它理解为各种处理器，有专门处理登录验证的，有处理 Cookies 的，有处理代理设置的。利用它们，我们几乎可以做到 HTTP 请求中所有的事情</p><p>父类BaseHandler，各种子类：</p><ul><li>HTTPDefaultErrorHandler 用于处理 HTTP 响应错误，错误都会抛出 HTTPError 类型的异常。</li><li>HTTPRedirectHandler 用于处理重定向。</li><li>HTTPCookieProcessor 用于处理 Cookies。</li><li>ProxyHandler 用于设置代理，默认代理为空。</li><li>HTTPPasswordMgr 用于管理密码，它维护了用户名密码的表。</li><li>HTTPBasicAuthHandler 用于管理认证，如果一个链接打开时需要认证，那么可以用它来解决认证问题。</li><li>详情可以参考官方文档： <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler">https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler</a></li></ul></li><li><p>OpenerDirector<br>就是利用 Handler 来构建 Opener</p><ul><li><p>验证  </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#通过代码模拟访问需要验证的页面，并获取验证后的内容</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener  </span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError  </span><br><span class="line"></span><br><span class="line">username = <span class="string">'username'</span>  </span><br><span class="line">password = <span class="string">'password'</span>  </span><br><span class="line">url = <span class="string">'http://localhost:5000/'</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用add_password方法将用户名、密码和URL添加到HTTPPasswordMgrWithDefaultRealm对象中，以建立用户名和密码的映射关系。</span></span><br><span class="line">p = HTTPPasswordMgrWithDefaultRealm()  </span><br><span class="line">p.add_password(<span class="literal">None</span>, url, username, password)  </span><br><span class="line"><span class="comment"># 创建HTTPBasicAuthHandler对象，并将HTTPPasswordMgrWithDefaultRealm对象作为参数传入。这样就建立了一个处理验证的Handler</span></span><br><span class="line">auth_handler = HTTPBasicAuthHandler(p) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用build_opener方法，Opener对象在发送请求时会自动携带验证信息</span></span><br><span class="line">opener = build_opener(auth_handler)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment"># 通过Opener对象的open方法打开指定的URL，完成验证过程。获取到验证后的页面源码内容</span></span><br><span class="line">    result = opener.<span class="built_in">open</span>(url)  </span><br><span class="line">    html = result.read().decode(<span class="string">'utf-8'</span>)  </span><br><span class="line">    <span class="built_in">print</span>(html)  </span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></tbody></table></figure></li><li><p>代理</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 在爬虫中设置代理，以便在访问目标网站时使用指定的代理服务器</span></span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError  </span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过ProxyHandler创建了一个代理处理器，将代理的信息传递给处理器</span></span><br><span class="line"><span class="comment"># 在本地搭建了一个代理，它运行在 9743 端口上。可以添加多个代理，以适应不同协议的请求</span></span><br><span class="line">proxy_handler = ProxyHandler({  </span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'http://127.0.0.1:9743'</span>,  </span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'https://127.0.0.1:9743'</span>  </span><br><span class="line">})  </span><br><span class="line"><span class="comment"># 用build_opener方法将代理处理器与其他可能的处理器（如身份验证处理器）一起构建成一个 Opener。</span></span><br><span class="line"><span class="comment"># opener是用于发送请求的对象</span></span><br><span class="line">opener = build_opener(proxy_handler)  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">'https://www.baidu.com'</span>)  </span><br><span class="line">    <span class="built_in">print</span>(response.read().decode(<span class="string">'utf-8'</span>))  </span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></tbody></table></figure></li><li><p>Coookies</p><ul><li>在爬虫中处理 Cookies</li><li>从网站获取并使用 Cookies</li><li>将 Cookies 保存到文件中以供后续使用</li></ul></li></ul></li></ul><h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><h3 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a>URLError</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/index.htm'</span>)  </span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></tbody></table></figure><p>打开一个不存在的页面，照理来说应该会报错，但是这时我们捕获了 URLError 这个异常，运行结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Not Found</span><br></pre></td></tr></tbody></table></figure><p>程序没有直接报错，而是输出了如上内容，这样通过如上操作，我们就可以避免程序异常终止，同时异常得到了有效处理。</p><h3 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h3><p> URLError 的子类，专门用来处理 HTTP 请求错误，比如认证请求失败等。它有如下 3 个属性。</p><ul><li><p>code：返回 HTTP 状态码，比如 404 表示网页不存在，500 表示服务器内部错误等</p></li><li><p>reason：同父类一样，用于返回错误的原因</p></li><li><p>headers：返回请求头</p></li></ul><p>示例：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/index.htm'</span>)  </span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason, e.code, e.headers, sep=<span class="string">'\n'</span>)</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Not Found</span><br><span class="line">404</span><br><span class="line">Server: nginx/1.4.6 (Ubuntu)</span><br><span class="line">Date: Wed, 03 Aug 2016 08:54:22 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: close</span><br><span class="line">X-Powered-By: PHP/5.5.9-1ubuntu4.14</span><br><span class="line">Vary: Cookie</span><br><span class="line">Expires: Wed, 11 Jan 1984 05:00:00 GMT</span><br><span class="line">Cache-Control: no-cache, must-revalidate, max-age=0</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Link: &lt;https://cuiqingcai.com/wp-json/&gt;; rel="https://api.w.org/"</span><br></pre></td></tr></tbody></table></figure><h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p>因为 URLError 是 HTTPError 的父类，所以可以先选择捕获子类的错误，再去捕获父类的错误</p><p>先捕获 HTTPError，获取它的错误状态码、原因、headers 等信息。如果不是 HTTPError 异常，就会捕获 URLError 异常，输出错误原因。最后，用 else 来处理正常的逻辑。这是一个较好的异常处理写法。</p><p>reason返回字符串</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/index.htm'</span>)  </span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason, e.code, e.headers, sep=<span class="string">'\n'</span>)  </span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Request Successfully'</span>)</span><br></pre></td></tr></tbody></table></figure><p>reason返回对象</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line"><span class="keyword">import</span> urllib.request  </span><br><span class="line"><span class="keyword">import</span> urllib.error  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'https://www.baidu.com'</span>, timeout=<span class="number">0.01</span>)  </span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(e.reason))  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(e.reason, socket.timeout):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'TIME OUT'</span>)</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span><span class="string">'socket.timeout'</span>&gt;</span><br><span class="line"><span class="comment">#reason 属性的结果是 socket.timeout 类，可以用 isinstance 方法来判断它的类型，作出更详细的异常判断。</span></span><br><span class="line">TIME OUT</span><br></pre></td></tr></tbody></table></figure><h2 id="解析链接"><a href="#解析链接" class="headerlink" title="解析链接"></a>解析链接</h2><h3 id="urlparse-解析URL"><a href="#urlparse-解析URL" class="headerlink" title="urlparse  -解析URL"></a>urlparse  -解析URL</h3><ul><li><p>构造方法</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">urllib.parse.urlparse(urlstring, scheme=<span class="string">''</span>, allow_fragments=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><p>  3 个参数：</p><ul><li><p>urlstring：这是必填项，即待解析的 URL。</p></li><li><p>scheme：它是默认的协议（比如 http 或 https 等）。假如这个链接没有带协议信息，会将这个作为默认的协议。</p><blockquote><p>scheme 参数只有在 URL 中不包含 scheme 信息时才生效。如果 URL 中有 scheme 信息，就会返回解析出的 scheme</p></blockquote></li><li><p>allow_fragments：即是否忽略 fragment。如果它被设置为 False，fragment 部分就会被忽略，它会被解析为 path、parameters 或者 query 的一部分，而 fragment 部分为空。</p></li></ul></li><li><p>实现 URL 的识别和分段</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse  </span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">'http://www.baidu.com/index.html;user?id=5#comment'</span>, scheme=<span class="string">'https'</span>, allow_fragments=<span class="literal">False</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result), result)</span><br></pre></td></tr></tbody></table></figure><p>  运行结果如下：</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">'urllib.parse.ParseResult'</span>&gt;</span><br><span class="line">ParseResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html'</span>, params=<span class="string">'user'</span>, query=<span class="string">'id=5#comment'</span>,</span><br><span class="line">fragment=<span class="string">''</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>返回结果是一个 ParseResult 类型的对象，<br>  它包含 6 个部分，分别是 scheme、netloc、path、params、query 和 fragment。可以得出一个标准的链接格式，具体如下： <code>scheme://netloc/path;params?query#fragment</code></p></li><li><p>返回结果 ParseResult 实际上是一个元组<br>  我们可以用索引顺序来获取，也可以用属性名获取。示例如下：</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse  </span><br><span class="line">  </span><br><span class="line">result = urlparse(<span class="string">'http://www.baidu.com/index.html#comment'</span>, allow_fragments=<span class="literal">False</span>)  </span><br><span class="line"><span class="built_in">print</span>(result.scheme, result[<span class="number">0</span>], result.netloc, result[<span class="number">1</span>], sep=<span class="string">'\n'</span>)</span><br></pre></td></tr></tbody></table></figure><p>  分别用索引和属性名获取了 scheme 和 netloc，其运行结果如下：</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http  </span><br><span class="line">http  </span><br><span class="line">www.baidu.com  </span><br><span class="line">www.baidu.com</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="urlunparse-构造URL"><a href="#urlunparse-构造URL" class="headerlink" title="urlunparse  -构造URL"></a>urlunparse  -构造URL</h3><p>有了 urlparse 方法，相应地就有了它的对立方法 urlunparse。它接受的参数是一个可迭代对象，但是它的长度必须是 6，否则会抛出参数数量不足或者过多的问题。先用一个实例看一下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunparse  </span><br><span class="line"></span><br><span class="line">data = [<span class="string">'http'</span>, <span class="string">'www.baidu.com'</span>, <span class="string">'index.html'</span>, <span class="string">'user'</span>, <span class="string">'a=6'</span>, <span class="string">'comment'</span>]  </span><br><span class="line"><span class="built_in">print</span>(urlunparse(data))</span><br></pre></td></tr></tbody></table></figure><p>这里参数 data 用了列表类型。也可以用其他类型，比如元组或者特定的数据结构。运行结果如下： </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://www.baidu.com/index.html;user?a=6#comment</span><br></pre></td></tr></tbody></table></figure><h3 id="urlsplit-解析URL"><a href="#urlsplit-解析URL" class="headerlink" title="urlsplit  -解析URL"></a>urlsplit  -解析URL</h3><p>它不再单独解析 params 这一部分，只返回 5 个结果， params 会合并到 path 中</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlsplit  </span><br><span class="line">result = urlsplit(<span class="string">'http://www.baidu.com/index.html;user?id=5#comment'</span>)  </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：  </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">SplitResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html;user'</span>, query=<span class="string">'id=5'</span>, fragment=<span class="string">'comment'</span>)</span><br></pre></td></tr></tbody></table></figure><p>返回结果是 SplitResult，也是一个元组类型，既可以用属性获取值，也可以用索引来获取</p><h3 id="urlunsplit-构造URL"><a href="#urlunsplit-构造URL" class="headerlink" title="urlunsplit  -构造URL"></a>urlunsplit  -构造URL</h3><p>与 urlunparse 方法类似，它也是将链接各个部分组合成完整链接的方法，传入的参数也是一个可迭代对象，例如列表、元组等，唯一的区别是长度必须为 5。</p><p>示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunsplit  </span><br><span class="line"></span><br><span class="line">data = [<span class="string">'http'</span>, <span class="string">'www.baidu.com'</span>, <span class="string">'index.html'</span>, <span class="string">'a=6'</span>, <span class="string">'comment'</span>]  </span><br><span class="line"><span class="built_in">print</span>(urlunsplit(data))</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下： </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://www.baidu.com/index.html?a=6#comment</span><br></pre></td></tr></tbody></table></figure><h3 id="urljoin-解析URL"><a href="#urljoin-解析URL" class="headerlink" title="urljoin -解析URL"></a>urljoin -解析URL</h3><p>提供一个 base_url（基础链接）作为第一个参数，将新的链接作为第二个参数，该方法会分析 base_url 的 scheme、netloc 和 path 这 3 个内容并对新链接缺失的部分进行补充，最后返回结果。</p><p>示例：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com'</span>, <span class="string">'FAQ.html'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com'</span>, <span class="string">'https://cuiqingcai.com/FAQ.html'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com/about.html'</span>, <span class="string">'https://cuiqingcai.com/FAQ.html'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com/about.html'</span>, <span class="string">'https://cuiqingcai.com/FAQ.html?question=2'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com?wd=abc'</span>, <span class="string">'https://cuiqingcai.com/index.php'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com'</span>, <span class="string">'?category=2#comment'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'www.baidu.com'</span>, <span class="string">'?category=2#comment'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'www.baidu.com#comment'</span>, <span class="string">'?category=2'</span>))</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://www.baidu.com/FAQ.html  </span><br><span class="line">https://cuiqingcai.com/FAQ.html  </span><br><span class="line">https://cuiqingcai.com/FAQ.html  </span><br><span class="line">https://cuiqingcai.com/FAQ.html?question=2  </span><br><span class="line">https://cuiqingcai.com/index.php  </span><br><span class="line">http://www.baidu.com?category=2#comment  </span><br><span class="line">www.baidu.com?category=2#comment  </span><br><span class="line">www.baidu.com?category=2</span><br></pre></td></tr></tbody></table></figure><h3 id="urlencode-转GET请求参数"><a href="#urlencode-转GET请求参数" class="headerlink" title="urlencode  -转GET请求参数"></a>urlencode  -转GET请求参数</h3><p>示例：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode  </span><br><span class="line"></span><br><span class="line">params = {  </span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'germey'</span>,  </span><br><span class="line">    <span class="string">'age'</span>: <span class="number">22</span>  </span><br><span class="line">}  </span><br><span class="line">base_url = <span class="string">'http://www.baidu.com?'</span>  </span><br><span class="line">url = base_url + urlencode(params)  </span><br><span class="line"><span class="built_in">print</span>(url)</span><br></pre></td></tr></tbody></table></figure><p>这里首先声明了一个字典来将参数表示出来，然后调用 urlencode 方法将其序列化为 GET 请求参数。运行结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://www.baidu.com?name=germey&amp;amp;age=22</span><br></pre></td></tr></tbody></table></figure><p>这个方法非常常用。有时为了更加方便地构造参数，我们会事先用字典来表示。要转化为 URL 的参数时，只需要调用该方法即可。</p><h3 id="parse-qs-转字典"><a href="#parse-qs-转字典" class="headerlink" title="parse_qs    -转字典"></a>parse_qs    -转字典</h3><p>利用 parse_qs 方法，就可以将它转回字典，示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs  </span><br><span class="line"></span><br><span class="line">query = <span class="string">'name=germey&amp;amp;age=22'</span>  </span><br><span class="line"><span class="built_in">print</span>(parse_qs(query))</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{<span class="string">'name'</span>: [<span class="string">'germey'</span>], <span class="string">'age'</span>: [<span class="string">'22'</span>]}</span><br></pre></td></tr></tbody></table></figure><h3 id="parse-qsl-转元组"><a href="#parse-qsl-转元组" class="headerlink" title="parse_qsl   -转元组"></a>parse_qsl   -转元组</h3><p>将参数转化为元组组成的列表，示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qsl  </span><br><span class="line"></span><br><span class="line">query = <span class="string">'name=germey&amp;amp;age=22'</span>  </span><br><span class="line"><span class="built_in">print</span>(parse_qsl(query))</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">[(<span class="string">'name'</span>, <span class="string">'germey'</span>), (<span class="string">'age'</span>, <span class="string">'22'</span>)]</span><br></pre></td></tr></tbody></table></figure><h3 id="quote-URL-编码"><a href="#quote-URL-编码" class="headerlink" title="quote  -URL 编码"></a>quote  -URL 编码</h3><p>将内容（中文）转化为 URL 编码的格式</p><p>示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote  </span><br><span class="line"></span><br><span class="line">keyword = <span class="string">' 壁纸 '</span>  </span><br><span class="line">url = <span class="string">'https://www.baidu.com/s?wd='</span> + quote(keyword)  </span><br><span class="line"><span class="built_in">print</span>(url)</span><br></pre></td></tr></tbody></table></figure><p>这里我们声明了一个中文的搜索文字，然后用 quote 方法对其进行 URL 编码，最后得到的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.baidu.com/s?wd=% E5% A3%81% E7% BA% B8</span><br></pre></td></tr></tbody></table></figure><h3 id="unquote-–URL-解码"><a href="#unquote-–URL-解码" class="headerlink" title="unquote  –URL 解码"></a>unquote  –URL 解码</h3><p>进行 URL 解码，示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote  </span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.baidu.com/s?wd=% E5% A3%81% E7% BA% B8'</span>  </span><br><span class="line"><span class="built_in">print</span>(unquote(url))</span><br></pre></td></tr></tbody></table></figure><p>这是上面得到的 URL 编码后的结果，这里利用 unquote 方法还原，结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.baidu.com/s?wd = 壁纸</span><br></pre></td></tr></tbody></table></figure><h2 id="分析Robots"><a href="#分析Robots" class="headerlink" title="分析Robots"></a>分析Robots</h2><h3 id="Robots-协议"><a href="#Robots-协议" class="headerlink" title="Robots 协议"></a>Robots 协议</h3><p>Robots 协议也称作爬虫协议，用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取。它通常是一个叫作 robots.txt 的文本文件，一般放在网站的根目录下。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#其设置为 * 则代表该协议对任何爬取爬虫有效</span></span><br><span class="line">User-agent: *         </span><br><span class="line"><span class="comment">#指定了不允许抓取的目录，比如上例子中设置为 / 则代表不允许抓取所有页面。</span></span><br><span class="line">Disallow: /  </span><br><span class="line"><span class="comment">#Allow一般不会单独使用，用来排除某些限制,表示只可以抓取 public 目录</span></span><br><span class="line">Allow: /public/</span><br></pre></td></tr></tbody></table></figure><h3 id="爬虫名称"><a href="#爬虫名称" class="headerlink" title="爬虫名称"></a>爬虫名称</h3><p>一些常见搜索爬虫的名称及其对应的网站</p><table><thead><tr><th>爬虫名称</th><th>名　　称</th><th>网　　站</th></tr></thead><tbody><tr><td>BaiduSpider</td><td>百度</td><td><a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td>Googlebot</td><td>谷歌</td><td><a href="http://www.google.com/">www.google.com</a></td></tr><tr><td>360Spider</td><td>360 搜索</td><td><a href="http://www.so.com/">www.so.com</a></td></tr><tr><td>YodaoBot</td><td>有道</td><td><a href="http://www.youdao.com/">www.youdao.com</a></td></tr><tr><td>ia_archiver</td><td>Alexa</td><td><a href="http://www.alexa.cn/">www.alexa.cn</a></td></tr><tr><td>Scooter</td><td>altavista</td><td><a href="http://www.altavista.com/">www.altavista.com</a></td></tr></tbody></table><h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h3><p>使用 robotparser 模块来解析 robots.txt</p><ul><li><p>构造方法  (very easy啦</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">urllib.robotparser.RobotFileParser(url=<span class="string">''</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>模块常用方法</p><ul><li>set_url ：用来设置 robots.txt 文件的链接</li><li>read：读取 robots.txt 文件并进行分析，一般为ture</li><li>parse：用来解析 robots.txt 文件</li><li>can_fetch：该方法传入两个参数 User-agent&amp; URL。返回的内容是该搜索引擎是否可以抓取这个 URL，返回结果是 True 或 False</li><li>mtime：返回的是上次抓取和分析 robots.txt 的时间</li><li>modified：将当前时间设置为上次抓取和分析 robots.txt 的时间</li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.robotparser <span class="keyword">import</span> RobotFileParser</span><br><span class="line">rp = RobotFileParser()</span><br><span class="line"><span class="comment">#rp = RobotFileParser('http://www.jianshu.com/robots.txt')</span></span><br><span class="line">rp.set_url(<span class="string">'http://www.jianshu.com/robots.txt'</span>)</span><br><span class="line">rp.read()</span><br><span class="line"><span class="comment">#也可以使用 parse 方法执行读取和分析</span></span><br><span class="line"><span class="comment">#rp.parse(urlopen('http://www.jianshu.com/robots.txt').read().decode('utf-8').split('\n'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用 can_fetch 方法判断了网页是否可以被抓取   True + False</span></span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">'*'</span>, <span class="string">'http://www.jianshu.com/p/b67554025d7d'</span>))</span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">'*'</span>, <span class="string">"http://www.jianshu.com/search?q=python&amp;page=1&amp;type=collections"</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="request和urllib的区别"><a href="#request和urllib的区别" class="headerlink" title="request和urllib的区别"></a>request和urllib的区别</h1><ul><li>urllib 是Python标准库中的模块，不需要安装额外的包</li><li>request是一个三方库，它在<code>urllib</code>的基础上提供了更简洁、更高级的接口和功能。<code>requests</code>库的设计目标是提供更人性化的API，使发送HTTP请求变得更加简单和方便。它支持更多的HTTP功能，例如自动处理重定向、会话管理、上传文件、处理Cookies等</li><li>需要进行HTTP请求的基本操作，学习和使用<code>requests</code>库会更加便捷和高效。如果你对Python标准库感兴趣，或者有特定的需求需要使用<code>urllib</code>的功能，也可以深入学习<code>urllib</code>库。</li><li>需要进行HTTP请求的基本操作，学习和使用<code>requests</code>库会更加便捷和高效。如果你对Python标准库感兴趣，或者有特定的需求需要使用<code>urllib</code>的功能，也可以深入学习<code>urllib</code>库。</li></ul><h1 id="使用-requests"><a href="#使用-requests" class="headerlink" title="使用 requests"></a>使用 requests</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="GET请求方法"><a href="#GET请求方法" class="headerlink" title="GET请求方法:"></a>GET请求方法:</h3><ul><li><p>基本用法 </p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/get'</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r))  </span><br><span class="line"><span class="built_in">print</span>(r.status_code)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.text))  </span><br><span class="line"><span class="built_in">print</span>(r.text)  </span><br><span class="line"><span class="built_in">print</span>(r.cookies)</span><br></pre></td></tr></tbody></table></figure><p>  调用 get 方法得到一个 Response 对象，然后分别输出了 Response 的类型、状态码、响应体的类型、内容以及 Cookies。</p></li><li><p>利用 params 参数附加额外信息</p><p>  请求的链接自动被构造成了：<a href="http://httpbin.org/get?age=22&amp;name=germey">http://httpbin.org/get?age=22&amp;name=germey</a>。</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"></span><br><span class="line">data = {  </span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'germey'</span>,  </span><br><span class="line">    <span class="string">'age'</span>: <span class="number">22</span>  </span><br><span class="line">}  </span><br><span class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=data)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.text))  </span><br><span class="line"><span class="comment">#返回类型是str类型的json格式，使用json方法解析返回结果，得到字典格式，如果返回结果不是JSON格式，会抛出json.decoder.JSONDecodeError异常</span></span><br><span class="line"><span class="built_in">print</span>(r.json())  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.json()))</span><br></pre></td></tr></tbody></table></figure></li><li><p>获取图片、音频和视频文件</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">"https://github.com/favicon.ico"</span>)</span><br><span class="line"><span class="comment">#wb：二进制写的形式打开</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'favicon.ico'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(r.content)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="其他请求方法："><a href="#其他请求方法：" class="headerlink" title="其他请求方法："></a>其他请求方法：</h3><ul><li><p>直接  .请求方法</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>)  </span><br><span class="line">r = requests.put(<span class="string">'http://httpbin.org/put'</span>)  </span><br><span class="line">r = requests.delete(<span class="string">'http://httpbin.org/delete'</span>)  </span><br><span class="line">r = requests.head(<span class="string">'http://httpbin.org/get'</span>)  </span><br><span class="line">r = requests.options(<span class="string">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>POST请求方法示例</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">data = {<span class="string">'name'</span>: <span class="string">'germey'</span>, <span class="string">'age'</span>: <span class="string">'22'</span>}</span><br><span class="line">r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=data)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure><p>运行结果的 form 部分就是提交的数据，这就证明 POST 请求发送成功</p></li></ul><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://www.jianshu.com'</span>)</span><br><span class="line"><span class="comment">#状态码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.status_code), r.status_code)</span><br><span class="line"><span class="comment">#响应头   --CaseInsensitiveDict 类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.headers), r.headers)</span><br><span class="line"><span class="comment">#cookies  --RequestsCookieJar 类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.cookies), r.cookies)</span><br><span class="line"><span class="comment">#URL</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.url), r.url)</span><br><span class="line"><span class="comment">#请求历史</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.history), r.history)</span><br><span class="line"><span class="comment">#状态码查询对象requests.codes</span></span><br><span class="line">exit() <span class="keyword">if</span> <span class="keyword">not</span> r.status_code == requests.codes.ok <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">'Request Successfully'</span>)</span><br></pre></td></tr></tbody></table></figure><p>下面列出了返回码和相应的查询条件：</p><figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line"># 信息性状态码  </span><br><span class="line">100: ('continue',),  </span><br><span class="line">101: ('switching_protocols',),  </span><br><span class="line">102: ('processing',),  </span><br><span class="line">103: ('checkpoint',),  </span><br><span class="line">122: ('uri_too_long', 'request_uri_too_long'),  </span><br><span class="line"></span><br><span class="line"># 成功状态码  </span><br><span class="line">200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\o/', '✓'),  </span><br><span class="line">201: ('created',),  </span><br><span class="line">202: ('accepted',),  </span><br><span class="line">203: ('non_authoritative_info', 'non_authoritative_information'),  </span><br><span class="line">204: ('no_content',),  </span><br><span class="line">205: ('reset_content', 'reset'),  </span><br><span class="line">206: ('partial_content', 'partial'),  </span><br><span class="line">207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),  </span><br><span class="line">208: ('already_reported',),  </span><br><span class="line">226: ('im_used',),  </span><br><span class="line"></span><br><span class="line"># 重定向状态码  </span><br><span class="line">300: ('multiple_choices',),  </span><br><span class="line">301: ('moved_permanently', 'moved', '\\o-'),  </span><br><span class="line">302: ('found',),  </span><br><span class="line">303: ('see_other', 'other'),  </span><br><span class="line">304: ('not_modified',),  </span><br><span class="line">305: ('use_proxy',),  </span><br><span class="line">306: ('switch_proxy',),  </span><br><span class="line">307: ('temporary_redirect', 'temporary_moved', 'temporary'),  </span><br><span class="line">308: ('permanent_redirect',  </span><br><span class="line">      'resume_incomplete', 'resume',), # These 2 to be removed in 3.0  </span><br><span class="line"></span><br><span class="line"># 客户端错误状态码  </span><br><span class="line">400: ('bad_request', 'bad'),  </span><br><span class="line">401: ('unauthorized',),  </span><br><span class="line">402: ('payment_required', 'payment'),  </span><br><span class="line">403: ('forbidden',),  </span><br><span class="line">404: ('not_found', '-o-'),  </span><br><span class="line">405: ('method_not_allowed', 'not_allowed'),  </span><br><span class="line">406: ('not_acceptable',),  </span><br><span class="line">407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),  </span><br><span class="line">408: ('request_timeout', 'timeout'),  </span><br><span class="line">409: ('conflict',),  </span><br><span class="line">410: ('gone',),  </span><br><span class="line">411: ('length_required',),  </span><br><span class="line">412: ('precondition_failed', 'precondition'),  </span><br><span class="line">413: ('request_entity_too_large',),  </span><br><span class="line">414: ('request_uri_too_large',),  </span><br><span class="line">415: ('unsupported_media_type', 'unsupported_media', 'media_type'),  </span><br><span class="line">416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),  </span><br><span class="line">417: ('expectation_failed',),  </span><br><span class="line">418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),  </span><br><span class="line">421: ('misdirected_request',),  </span><br><span class="line">422: ('unprocessable_entity', 'unprocessable'),  </span><br><span class="line">423: ('locked',),  </span><br><span class="line">424: ('failed_dependency', 'dependency'),  </span><br><span class="line">425: ('unordered_collection', 'unordered'),  </span><br><span class="line">426: ('upgrade_required', 'upgrade'),  </span><br><span class="line">428: ('precondition_required', 'precondition'),  </span><br><span class="line">429: ('too_many_requests', 'too_many'),  </span><br><span class="line">431: ('header_fields_too_large', 'fields_too_large'),  </span><br><span class="line">444: ('no_response', 'none'),  </span><br><span class="line">449: ('retry_with', 'retry'),  </span><br><span class="line">450: ('blocked_by_windows_parental_controls', 'parental_controls'),  </span><br><span class="line">451: ('unavailable_for_legal_reasons', 'legal_reasons'),  </span><br><span class="line">499: ('client_closed_request',),  </span><br><span class="line"></span><br><span class="line"># 服务端错误状态码  </span><br><span class="line">500: ('internal_server_error', 'server_error', '/o\\', '✗'),  </span><br><span class="line">501: ('not_implemented',),  </span><br><span class="line">502: ('bad_gateway',),  </span><br><span class="line">503: ('service_unavailable', 'unavailable'),  </span><br><span class="line">504: ('gateway_timeout',),  </span><br><span class="line">505: ('http_version_not_supported', 'http_version'),  </span><br><span class="line">506: ('variant_also_negotiates',),  </span><br><span class="line">507: ('insufficient_storage',),  </span><br><span class="line">509: ('bandwidth_limit_exceeded', 'bandwidth'),  </span><br><span class="line">510: ('not_extended',),  </span><br><span class="line">511: ('network_authentication_required', 'network_auth', 'network_authentication')</span><br></pre></td></tr></tbody></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#rb -只读二进制打开文件</span></span><br><span class="line">files = {<span class="string">'file'</span>: <span class="built_in">open</span>(<span class="string">'favicon.ico'</span>, <span class="string">'rb'</span>)}</span><br><span class="line"><span class="comment">#post方法--提交数据</span></span><br><span class="line"><span class="comment">#将打开的文件favicon.ico作为文件对象传递给requests.post()方法，以进行文件上传。</span></span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, files=files)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="comment">#返回响应，里面包含 files 这个字段</span></span><br></pre></td></tr></tbody></table></figure><h3 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h3><ul><li><p>获取cookies</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">  r = requests.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">  <span class="built_in">print</span>(r.cookies)</span><br><span class="line">  <span class="comment">#用items方法转化成元组 ，遍历输出每一个cookies的名称和值</span></span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> r.cookies.items():</span><br><span class="line">      <span class="built_in">print</span>(key + <span class="string">'='</span> + value)</span><br><span class="line">  ````</span><br><span class="line"></span><br><span class="line">- 设置cookies并维持登录状态</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">  headers = {</span><br><span class="line">      <span class="string">'Cookie'</span>: <span class="string">'q_c1=31653b264a074fc9a57816d1ea93ed8b|1474273938000|1474273938000; d_c0="AGDAs254kAqPTr6NW1U3XTLFzKhMPQ6H_nc=|1474273938"; __utmv=51854390.100-1|2=registration_date=20130902=1^3=entry_date=20130902=1;a_t="2.0AACAfbwdAAAXAAAAso0QWAAAgH28HQAAAGDAs254kAoXAAAAYQJVTQ4FCVgA360us8BAklzLYNEHUd6kmHtRQX5a6hiZxKCynnycerLQ3gIkoJLOCQ==";z_c0=Mi4wQUFDQWZid2RBQUFBWU1DemJuaVFDaGNBQUFCaEFsVk5EZ1VKV0FEZnJTNnp3RUNTWE10ZzBRZFIzcVNZZTFGQmZn|1474887858|64b4d4234a21de774c42c837fe0b672fdb5763b0'</span>,</span><br><span class="line">      <span class="string">'Host'</span>: <span class="string">'www.zhihu.com'</span>,</span><br><span class="line">      <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span>,</span><br><span class="line">  }</span><br><span class="line">  r = requests.get(<span class="string">'https://www.zhihu.com'</span>, headers=headers)</span><br><span class="line">  <span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用Cookies参数设置Cookies的方法</p><p>新建一个 RequestCookieJar 对象–&gt;将复制下来的 cookies 利用 split 方法分割–&gt;利用 set 方法设置好每个 Cookie 的 key 和 value–&gt;通过调用 requests 的 get() 方法并传递给 cookies 参数【可以但没必要？】</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookies = <span class="string">'q_c1=31653b264a074fc9a57816d1ea93ed8b|1474273938000|1474273938000; d_c0="AGDAs254kAqPTr6NW1U3XTLFzKhMPQ6H_nc=|1474273938"; __utmv=51854390.100-1|2=registration_date=20130902=1^3=entry_date=20130902=1;a_t="2.0AACAfbwdAAAXAAAAso0QWAAAgH28HQAAAGDAs254kAoXAAAAYQJVTQ4FCVgA360us8BAklzLYNEHUd6kmHtRQX5a6hiZxKCynnycerLQ3gIkoJLOCQ==";z_c0=Mi4wQUFDQWZid2RBQUFBWU1DemJuaVFDaGNBQUFCaEFsVk5EZ1VKV0FEZnJTNnp3RUNTWE10ZzBRZFIzcVNZZTFGQmZn|1474887858|64b4d4234a21de774c42c837fe0b672fdb5763b0'</span></span><br><span class="line">jar = requests.cookies.RequestsCookieJar()</span><br><span class="line">headers = {</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'www.zhihu.com'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies.split(<span class="string">';'</span>):</span><br><span class="line">    key, value = cookie.split(<span class="string">'='</span>, <span class="number">1</span>)</span><br><span class="line">    jar.<span class="built_in">set</span>(key, value)</span><br><span class="line">r = requests.get(<span class="string">'http://www.zhihu.com'</span>, cookies=jar, headers=headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h3><p>会话维持是指在进行多个请求时，保持相同的会话状态，而不是每个请求都创建一个新的会话。</p><p>解决问题：：第一个请求使用<code>post</code>方法登录了一个网站，然后想要获取登录后的个人信息，你再次使用<code>get</code>方法请求个人信息页面。实际上，这相当于在两个独立的会话中操作，它们并不相关，所以无法成功获取个人信息。</p><p>有一种解决方法是在每次请求时手动设置相同的Cookies，但这样做非常麻烦。我们有更简单的解决方法，那就是使用<code>Session</code>对象。</p><p><code>Session</code>对象可以方便地维护一个会话，并自动处理Cookies的问题。通过创建一个<code>Session</code>对象，我们可以在同一个会话中发送多个请求，会话对象会自动处理Cookies的传递和存储。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line"><span class="comment">#请求了一个测试网址，设置一个cookie名称叫作 number，内容是 123456789</span></span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line"><span class="comment">#随后又请求了http://httpbin.org/cookies，此网址可以获取当前的 Cookies</span></span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure><p>运行结果：(运行的好慢，建议直接点进网址)</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "cookies": {"number": "123456789"}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="SSL-证书验证"><a href="#SSL-证书验证" class="headerlink" title="SSL 证书验证"></a>SSL 证书验证</h3><p>当发送 HTTP 请求的时候，requests 会提供验证SSL 证书功能。通过<code>verify</code>参数控制是否验证证书，默认情况下<code>verify</code>为<code>True</code>，会自动验证证书。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line"><span class="comment">#当禁用证书验证或出现其他安全相关警告时，禁用urllib3库的警告信息来忽略警告</span></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">response = requests.get(<span class="string">'https://www.12306.cn'</span>, verify=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br></pre></td></tr></tbody></table></figure><p>指定本地证书用作客户端证书：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">'https://www.12306.cn'</span>, cert=(<span class="string">'/path/server.crt'</span>, <span class="string">'/path/key'</span>))</span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br></pre></td></tr></tbody></table></figure><h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><ul><li><p>proxies参数</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = {<span class="string">'https'</span>: <span class="string">'http://user:password@10.10.1.10:3128/'</span>,}</span><br><span class="line">requests.get(<span class="string">'https://www.taobao.com'</span>, proxies=proxies)</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用 HTTP Basic Auth</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">proxies = {<span class="string">'https'</span>: <span class="string">'http://user:password@10.10.1.10:3128/'</span>,}</span><br><span class="line">requests.get(<span class="string">'https://www.taobao.com'</span>, proxies=proxies)</span><br></pre></td></tr></tbody></table></figure></li><li><p>SOCKS 协议的代理  <code>pip3 install "requests[socks]" </code></p> <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">   </span><br><span class="line">proxies = {</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'socks5://user:password@host:port'</span>,</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'socks5://user:password@host:port'</span></span><br><span class="line">}</span><br><span class="line">requests.get(<span class="string">'https://www.taobao.com'</span>, proxies=proxies)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><p>timeout参数</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#timeout=(5, 30)  连接+读取分别指定时间</span></span><br><span class="line">r = requests.get(<span class="string">'https://www.taobao.com'</span>, timeout=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></tbody></table></figure><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://localhost:5000'</span>, auth=(<span class="string">'username'</span>, <span class="string">'password'</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></tbody></table></figure><p>OAuth 认证   <code>pip3 install requests_oauthlib</code></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests_oauthlib <span class="keyword">import</span> OAuth1</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://api.twitter.com/1.1/account/verify_credentials.json'</span></span><br><span class="line">auth = OAuth1(<span class="string">'YOUR_APP_KEY'</span>, <span class="string">'YOUR_APP_SECRET'</span>,</span><br><span class="line">              <span class="string">'USER_OAUTH_TOKEN'</span>, <span class="string">'USER_OAUTH_TOKEN_SECRET'</span>)</span><br><span class="line">requests.get(url, auth=auth)</span><br></pre></td></tr></tbody></table></figure><h3 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h3><p>目的：</p><ol><li>请求定制化：可以设置请求的URL、请求方法、请求数据、请求头、超时时间等各种参数，以满足具体的需求</li><li>请求队列调度：可以将多个<code>Prepared Request</code>对象放入队列中，并按照一定的策略进行调度和发送，实现批量处理请求、并发请求、异步请求等功能，提高请求的效率和性能</li><li>会话状态保持：在一个会话中，你可以发送多个请求，并共享会话级别的参数，如cookies、认证信息等。这对于模拟登录、进行会话管理以及处理需要会话保持的操作非常有用</li></ol><p>构造<code>Prepared Request</code>对象  –  发送<code>Prepared Request</code></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">data = {<span class="string">'name'</span>: <span class="string">'germey'</span>}</span><br><span class="line">headers = {<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span></span><br><span class="line">}</span><br><span class="line">s = Session()</span><br><span class="line">req = Request(<span class="string">'POST'</span>, url, data=data, headers=headers)</span><br><span class="line"><span class="comment">#调用 Session 的 prepare_request 方法将其转换为一个 Prepared Request 对象   --  将请求表示为数据结构</span></span><br><span class="line">prepped = s.prepare_request(req)</span><br><span class="line"><span class="comment">#发送`Prepared Request`</span></span><br><span class="line">r = s.send(prepped)</span><br><span class="line"><span class="comment">#获取请求结果</span></span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">{</span><span class="punctuation">}</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">"data"</span><span class="punctuation">:</span> <span class="string">""</span><span class="punctuation">,</span><span class="attr">"files"</span><span class="punctuation">:</span> <span class="punctuation">{</span><span class="punctuation">}</span><span class="punctuation">,</span><span class="attr">"form"</span><span class="punctuation">:</span> <span class="punctuation">{</span><span class="attr">"name"</span><span class="punctuation">:</span><span class="string">"germey"</span><span class="punctuation">}</span><span class="punctuation">,</span><span class="attr">"headers"</span><span class="punctuation">:</span> <span class="punctuation">{</span><span class="attr">"Accept"</span><span class="punctuation">:</span><span class="string">"*/*"</span><span class="punctuation">,</span><span class="attr">"Accept-Encoding"</span><span class="punctuation">:</span><span class="string">"gzip, deflate"</span><span class="punctuation">,</span><span class="attr">"Connection"</span><span class="punctuation">:</span><span class="string">"close"</span><span class="punctuation">,</span><span class="attr">"Content-Length"</span><span class="punctuation">:</span><span class="string">"11"</span><span class="punctuation">,</span><span class="attr">"Content-Type"</span><span class="punctuation">:</span><span class="string">"application/x-www-form-urlencoded"</span><span class="punctuation">,</span><span class="attr">"Host"</span><span class="punctuation">:</span><span class="string">"httpbin.org"</span><span class="punctuation">,</span><span class="attr">"User-Agent"</span><span class="punctuation">:</span><span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36"</span><span class="punctuation">}</span><span class="punctuation">,</span><span class="attr">"json"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">"origin"</span><span class="punctuation">:</span><span class="string">"182.32.203.166"</span><span class="punctuation">,</span><span class="attr">"url"</span><span class="punctuation">:</span><span class="string">"http://httpbin.org/post"</span><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="常用的匹配规则"><a href="#常用的匹配规则" class="headerlink" title="常用的匹配规则"></a>常用的匹配规则</h2><table><thead><tr><th>模　　式</th><th>描　　述</th></tr></thead><tbody><tr><td>\w</td><td>匹配字母、数字及下划线</td></tr><tr><td>\W</td><td>匹配不是字母、数字及下划线的字符</td></tr><tr><td>\s</td><td>匹配任意空白字符，等价于 [\t\n\r\f]</td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于 [0-9]</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\A</td><td>匹配字符串开头</td></tr><tr><td>\Z</td><td>匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td></tr><tr><td>\z</td><td>匹配字符串结尾，如果存在换行，同时还会匹配换行符</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>^</td><td>匹配一行字符串的开头</td></tr><tr><td>$</td><td>匹配一行字符串的结尾</td></tr><tr><td>.</td><td>匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符</td></tr><tr><td>[…]</td><td>用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k</td></tr><tr><td>[^…]</td><td>不在 [] 中的字符，比如 [^abc] 匹配除了 a、b、c 之外的字符</td></tr><tr><td>*</td><td>匹配 0 个或多个表达式</td></tr><tr><td>+</td><td>匹配 1 个或多个表达式</td></tr><tr><td>?</td><td>匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td>{n}</td><td>精确匹配 n 个前面的表达式</td></tr><tr><td>{n, m}</td><td>匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式</td></tr><tr><td>a</td><td>b</td></tr><tr><td>( )</td><td>匹配括号内的表达式，也表示一个组</td></tr></tbody></table><h2 id="match-：从头找"><a href="#match-：从头找" class="headerlink" title="match ：从头找"></a>match ：从头找</h2><h3 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h3><p>如果匹配，就返回匹配成功的结果；如果不匹配，就返回 None</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">'^Hello\s\d\d\d\s\d{4}\s\w{10}'</span>, content)</span><br><span class="line"><span class="comment">#^ 是匹配字符串的开头，也就是以 Hello 开头</span></span><br><span class="line"><span class="comment">#\s 匹配空白字符</span></span><br><span class="line"><span class="comment">#\d 匹配数字 \d{4}匹配 4 个数字</span></span><br><span class="line"><span class="comment">#\w{10} 匹配 10 个字母及下划线</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">#SRE_Match 对象的group方法：匹配的内容</span></span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br><span class="line"><span class="comment">#span方法：匹配的范围</span></span><br><span class="line"><span class="built_in">print</span>(result.span())</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">41</span></span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">25</span>), <span class="keyword">match</span>=<span class="string">'Hello 123 4567 World_This'</span>&gt;</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This</span><br><span class="line">(<span class="number">0</span>, <span class="number">25</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="通用匹配-x2F"><a href="#通用匹配-x2F" class="headerlink" title="通用匹配(./*)"></a>通用匹配(./*)</h3><p>.(点)匹配任意字符</p><p><em>(星)匹配前面的字符*<em>无限次</em></em></p><p>组合在一起就可以匹配任意字符( •̀ ω •́ )y</p><h3 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h3><p>.*：贪婪匹配，匹配尽可能多字符</p><p>.*?：非贪婪匹配，匹配尽量少字符</p><p>在做匹配的时候字符串中间尽量使用非贪婪匹配，以避免出现匹配结果缺失的情况</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table><thead><tr><th>修饰符</th><th>描　　述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使。匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据 Unicode 字符集解析字符。这个标志影响 \w、\W、\b 和 \B</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td></tr></tbody></table><p>在网页匹配中，较为常用的有 re.S 和 re.I</p><h3 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配 \"></a>转义匹配 \</h3><h2 id="search-：找一个"><a href="#search-：找一个" class="headerlink" title="search ：找一个"></a>search ：找一个</h2><p>在匹配时会扫描整个字符串，然后<strong>返回第一个成功匹配的结果</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'</span></span><br><span class="line">result = re.search(<span class="string">'Hello.*?(\d+).*?Demo'</span>, content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></tbody></table></figure><h2 id="findall-：找全部"><a href="#findall-：找全部" class="headerlink" title="findall ：找全部"></a>findall ：找全部</h2><p>返回列表类型，遍历获得每组内容</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">results = re.findall(<span class="string">'&lt;li.*?href="(.*?)".*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html, re.S)</span><br><span class="line"><span class="built_in">print</span>(results)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(results))  </span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:  </span><br><span class="line">    <span class="built_in">print</span>(result)  </span><br><span class="line">    <span class="built_in">print</span>(result[<span class="number">0</span>], result[<span class="number">1</span>], result[<span class="number">2</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="sub-：删除"><a href="#sub-：删除" class="headerlink" title="sub ：删除"></a>sub ：删除</h2><p>删除匹配到的文本</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#删掉数字</span></span><br><span class="line">content = <span class="string">'54aK54yr5oiR54ix5L2g'</span></span><br><span class="line">content = re.sub(<span class="string">'\d+'</span>, <span class="string">''</span>, content)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></tbody></table></figure><h2 id="compile-：复用"><a href="#compile-：复用" class="headerlink" title="compile ：复用"></a>compile ：复用</h2><p>将正则字符串编译成正则表达式对象，相当于做了一层封装，以便服用</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content1 = <span class="string">'2016-12-15 12:00'</span></span><br><span class="line">content2 = <span class="string">'2016-12-17 12:55'</span></span><br><span class="line">content3 = <span class="string">'2016-12-22 13:21'</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">'\d{2}:\d{2}'</span>)</span><br><span class="line">result1 = re.sub(pattern, <span class="string">''</span>, content1)</span><br><span class="line">result2 = re.sub(pattern, <span class="string">''</span>, content2)</span><br><span class="line">result3 = re.sub(pattern, <span class="string">''</span>, content3)</span><br><span class="line"><span class="built_in">print</span>(result1, result2, result3)</span><br></pre></td></tr></tbody></table></figure><h2 id="方法技巧"><a href="#方法技巧" class="headerlink" title="方法技巧"></a>方法技巧</h2><p><strong>在做匹配的时候，字符串中间尽量使用非贪婪匹配</strong></p><p>match：<strong>更适合用来检测某个字符串是否符合某个正则表达式的规则</strong></p><p>search：<strong>匹配方便</strong></p><p>findall：<strong>要提取多个内容时</strong></p><h1 id="案例：抓取猫眼电影排行"><a href="#案例：抓取猫眼电影排行" class="headerlink" title="案例：抓取猫眼电影排行"></a>案例：抓取猫眼电影排行</h1><p>先浅写一个思路</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>提取出猫眼电影 TOP100 的电影名称、时间、评分、图片等信息，提取的站点 URL 为 <a href="http://maoyan.com/board/4">http://maoyan.com/board/4</a>，提取的结果会以文件形式保存下来。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><a href="http://maoyan.com/board/4?offset=10">http://maoyan.com/board/4?offset=10</a>   的offset 代表偏移量值</p><h2 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.获取首页代码内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_one_page</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        headers = {</span><br><span class="line">            <span class="string">'Cookie'</span>: <span class="string">''</span>,</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                          <span class="string">'Chrome/73.0.3683.86 Safari/537.36'</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建Chrome浏览器的实例</span></span><br><span class="line">        driver = webdriver.Chrome()</span><br><span class="line">        driver.get(url)</span><br><span class="line">        <span class="comment"># 等待页面加载完成</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 获取页面内容</span></span><br><span class="line">        content = driver.page_source</span><br><span class="line">        driver.quit()</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment">#     response = requests.get(url, headers=headers)</span></span><br><span class="line">    <span class="comment">#     if response.status_code == 200:</span></span><br><span class="line">    <span class="comment">#         return response.text</span></span><br><span class="line">    <span class="comment"># except RequestException:</span></span><br><span class="line">    <span class="comment">#     return None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.正则获取相关内容，并进行格式处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_one_page</span>(<span class="params">html</span>):</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(</span><br><span class="line">        <span class="string">'&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>,</span><br><span class="line">        re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> {<span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">               <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">               <span class="string">'title'</span>: item[<span class="number">2</span>],</span><br><span class="line">               <span class="string">'actor'</span>: item[<span class="number">3</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">               <span class="string">'time'</span>: item[<span class="number">4</span>].strip()[<span class="number">5</span>:],</span><br><span class="line">               <span class="string">'score'</span>: item[<span class="number">5</span>] + item[<span class="number">6</span>]</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.写进文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_to_file</span>(<span class="params">content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'result.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">type</span>(json.dumps(content)))</span><br><span class="line">        f.write(json.dumps(content, ensure_ascii=<span class="literal">False</span>) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用main方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">offset</span>):</span><br><span class="line">    url = <span class="string">'http://maoyan.com/board/4?offset='</span> + <span class="built_in">str</span>(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">        write_to_file(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页爬取</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        main(offset=i * <span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 速度过快，则会无响应</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>存在的问题：</p><ol><li><p>首页验证码登录  –请求头添加cookies</p></li><li><p>添加了反爬虫-验证拼图-暂未解决</p><p>用selenium打开浏览器，进行了11-50页面的滑动验证，能保证代码继续运行，但是11-50的数据没有获得【？】</p><p>运行结果：<img src="/img/image-20230612220406176.png" alt="image-20230612220406176"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫-2.爬虫基础</title>
      <link href="/2023/06/10/2-%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/06/10/2-%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-基本原理"><a href="#HTTP-基本原理" class="headerlink" title="HTTP 基本原理"></a>HTTP 基本原理</h1><h2 id="URI-amp-URL"><a href="#URI-amp-URL" class="headerlink" title="URI&amp;URL"></a>URI&amp;URL</h2><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><ul><li>用于标识和定位资源的字符串序列</li><li>它是一种标准化的命名方式，用于唯一地标识一个资源，包括但不限于文件、网页、API 端点等</li><li>URI 是一个广义的概念，包括两个子集：URL 和 URN。</li></ul><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><ul><li>是 URI 的一种常见形式。它是一种特定格式的字符串，用于描述一个资源的位置（或地址）</li><li>提供了一种标准的方式来访问网络上的资源，例如网页、图片、文件等</li><li>例子：<code>https://www.example.com/index.html?id=12345</code><ul><li>协议是 HTTPS。</li><li>主机名是 <a href="http://www.example.com./">www.example.com。</a></li><li>路径是 /index.html。</li><li>查询参数是 id=12345。</li></ul></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>URI 和 URL 的区别在于 URI 是一个更广泛的概念，包含了所有用于标识和定位资源的方式。</li><li>而 URL 则是 URI 的一种具体实现形式。URL 提供了一种特定的语法和格式，用于指定资源的位置和访问方式</li></ul><h2 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h2><ul><li>网页的源代码 HTML 就可以称作超文本</li></ul><h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>协议类型</p></li><li><p>HTTP：超文本传输协议</p></li><li><p>HTTPS：HTTP 的安全版  ，HTTP 下加入 SSL 层</p></li></ul><h3 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h3><p>在浏览器中输入URL，回车之后浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来<br><img src="/img/image-20230610142848095.png" alt="image-20230610142848095"></p><p>网络请求具体含义<br><img src="/img/image-20230610143146951.png" alt="image-20230610143146951"></p><ul><li>第一列 Name：请求的名称，一般会将 URL 的最后一部分内容当作名称。</li><li>第二列 Status：响应的状态码，这里显示为 200，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。</li><li>第三列 Type：请求的文档类型。这里为 xhr，是一种在Web浏览器中进行异步数据传输的技术。它允许网页通过JavaScript发送HTTP请求并接收服务器返回的数据，而无需刷新整个页面</li><li>第四列 Initiator：请求源。用来标记请求是由哪个对象或进程发起的。</li><li>第五列 Size：从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示 from cache。</li><li>第六列 Time：发起请求到获取响应所用的总时间。</li><li>第七列 Waterfall：网络请求的可视化瀑布流。</li></ul><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><ul><li><p>GET      获取数据（访问网址</p></li><li><p>POST    发送数据（表单提取、上传文件</p></li><li><p>区别</p><ul><li>GET 请求中的参数包含在 URL 里面，数据可以在 URL 中看到</li><li>POST 请求的 URL 不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中</li><li>GET 请求提交的数据最多只有 1024 字节，而 POST 方式没有限制。</li></ul></li><li><p>其他请求方法</p><table><thead><tr><th>方　　法</th><th>描　　述</th></tr></thead><tbody><tr><td>GET</td><td>请求页面，并返回页面内容</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>CONNECT</td><td>把服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>本表参考：<a href="http://www.runoob.com/http/http-methods.html">http://www.runoob.com/http/http-methods.html</a>。</p></li></ul><h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址"></a>请求网址</h3><p>即统一资源定位符 URL，它可以唯一确定我们想请求的资源。</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>用来说明服务器要使用的附加信息，请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p><ul><li>Accept：指定客户端可以接受的响应内容的类型。服务器可以根据该头信息来确定发送何种类型的响应。</li><li>Accept-Language：指定客户端可接受的语言类型。</li><li>Accept-Encoding：指定客户端可接受的内容编码。</li><li>Host：用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。</li></ul><ul><li>User-Agent：可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。</li><li>Content-Type：指定请求或响应中的主体内容的类型。常见的值有text/plain、text/html、application/json等，用于指定文本、HTML、JSON等数据格式。更多对应关系可以查看此对照表：<a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a>。</li><li>Authorization：用于在请求中发送身份验证凭据，例如用户名和密码。常用于需要身份验证的请求，如访问受保护的资源。</li><li>Cookie：也常用复数形式 Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是 Cookies 的功劳。Cookies 里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上 Cookies 并将其发送给服务器，服务器通过 Cookies 识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li><li>Location：在重定向响应中使用，指定新的URL地址，用于将客户端重定向到其他位置。</li><li>Cache-Control：指定请求或响应的缓存行为，控制缓存的存储、验证和过期等策略。</li><li>Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。</li><li>Server：在服务器的响应中发送服务器的名称和版本信息。</li></ul><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>一般承载的内容是 POST 请求中的表单数据，对于 GET 请求请求体则为空。</p><p>请求体的格式：请求体可以使用多种格式来传输数据，常见Content-Type 和 POST 提交数据方式的关系包括：</p><ul><li>表单数据（Form Data）：使用<code>application/x-www-form-urlencoded</code>格式，类似于HTML表单的数据提交方式。</li><li>JSON数据：使用<code>application/json</code>格式，常用于发送结构化的数据对象。</li><li>文件上传：使用<code>multipart/form-data</code>格式，用于发送二进制文件数据。</li><li>XML数据：使用<code>text/xml</code>格式</li></ul><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>常见的错误代码及错误原因【感觉不用记这么多，找个简版的】</p><table><thead><tr><th>状态码</th><th>说　　明</th><th>详　　情</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换</td></tr><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一个源</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，内容被重置</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分请求</td></tr><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作</td></tr><tr><td>301</td><td>永久移动</td><td>请求的网页已永久移动到新位置，即永久重定向</td></tr><tr><td>302</td><td>临时移动</td><td>请求的网页暂时跳转到其他页面，即暂时重定向</td></tr><tr><td>303</td><td>查看其他位置</td><td>如果原来的请求是 POST，重定向目标文档应该通过 GET 提取</td></tr><tr><td>304</td><td>未修改</td><td>此次请求返回的网页未修改，继续使用上次的资源</td></tr><tr><td>305</td><td>使用代理</td><td>请求者应该使用代理访问该网页</td></tr><tr><td>307</td><td>临时重定向</td><td>请求的资源临时从其他位置响应</td></tr><tr><td>400</td><td>错误请求</td><td>服务器无法解析该请求</td></tr><tr><td>401</td><td>未授权</td><td>请求没有进行身份验证或验证未通过</td></tr><tr><td>403</td><td>禁止访问</td><td>服务器拒绝此请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的网页</td></tr><tr><td>405</td><td>方法禁用</td><td>服务器禁用了请求中指定的方法</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容响应请求的网页</td></tr><tr><td>407</td><td>需要代理授权</td><td>请求者需要使用代理授权</td></tr><tr><td>408</td><td>请求超时</td><td>服务器请求超时</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突</td></tr><tr><td>410</td><td>已删除</td><td>请求的资源已永久删除</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件</td></tr><tr><td>413</td><td>请求实体过大</td><td>请求实体过大，超出服务器的处理能力</td></tr><tr><td>414</td><td>请求 URI 过长</td><td>请求网址过长，服务器无法处理</td></tr><tr><td>415</td><td>不支持类型</td><td>请求格式不被请求页面支持</td></tr><tr><td>416</td><td>请求范围不符</td><td>页面无法提供请求的范围</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足期望请求标头字段的要求</td></tr><tr><td>500</td><td>服务器内部错误</td><td>服务器遇到错误，无法完成请求</td></tr><tr><td>501</td><td>未实现</td><td>服务器不具备完成请求的功能</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求</td></tr><tr><td>505</td><td>HTTP 版本不支持</td><td>服务器不支持请求中所用的 HTTP 协议版本</td></tr></tbody></table><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>简要说明一些常用的头信息。</p><ul><li>Date：标识响应产生的时间。</li><li>Last-Modified：指定资源的最后修改时间。</li><li>Content-Encoding：指定响应内容的编码。</li><li>Server：包含服务器的信息，比如名称、版本号等。</li><li>Content-Type：文档类型，指定返回的数据类型是什么，如 text/html 代表返回 HTML 文档，application/x-javascript 则代表返回 JavaScript 文件，image/jpeg 则代表返回图片。</li><li>Set-Cookie：设置 Cookies。响应头中的 Set-Cookie 告诉浏览器需要将此内容放在 Cookies 中，下次请求携带 Cookies 请求。</li><li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>网页的源代码，也就是响应体的内容，它是解析的目标</p><h1 id="Web网页基础"><a href="#Web网页基础" class="headerlink" title="Web网页基础"></a>Web网页基础</h1><h2 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h2><ul><li>HTML</li><li>CSS</li><li>JavaScript</li></ul><h2 id="网页的结构"><a href="#网页的结构" class="headerlink" title="网页的结构"></a>网页的结构</h2><p>就是HTML的结构啦</p><p><code>&lt;html&gt; </code> –<code>&lt;head&gt;</code> –<code>&lt;title&gt;</code>   ……</p><h2 id="节点树及节点间的关系"><a href="#节点树及节点间的关系" class="headerlink" title="节点树及节点间的关系"></a>节点树及节点间的关系</h2><p>通过 HTML DOM（针对 HTML 文档的标准模型），树中的所有节点均可通过 JavaScript 访问，所有 HTML 节点元素均可被修改，也可以被创建或删除。</p><p>节点树<br><img src="/img/image-20230610150803831.png" alt="image-20230610150803831"></p><p>节点树及节点间的关系<br><img src="/img/image-20230610150819021.png" alt="image-20230610150819021"></p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>在 CSS 中，我们使用 CSS 选择器来定位节点</p><p>CSS 选择器的其他语法规则</p><table><thead><tr><th>选　择　器</th><th>例　　子</th><th>例子描述</th></tr></thead><tbody><tr><td>.class</td><td>.intro</td><td>选择 class=”intro” 的所有节点</td></tr><tr><td>#id</td><td>#firstname</td><td>选择 id=”firstname” 的所有节点</td></tr><tr><td>*</td><td>*</td><td>选择所有节点</td></tr><tr><td>element</td><td>p</td><td>选择所有 p 节点</td></tr><tr><td>element,element</td><td>div,p</td><td>选择所有 div 节点和所有 p 节点</td></tr><tr><td>element element</td><td>div p</td><td>选择 div 节点内部的所有 p 节点</td></tr><tr><td>element&gt;element</td><td>div&gt;p</td><td>选择父节点为 div 节点的所有 p 节点</td></tr><tr><td>element+element</td><td>div+p</td><td>选择紧接在 div 节点之后的所有 p 节点</td></tr><tr><td>[attribute]</td><td>[target]</td><td>选择带有 target 属性的所有节点</td></tr><tr><td>[attribute=value]</td><td>[target=blank]</td><td>选择 target=”blank” 的所有节点</td></tr><tr><td>[attribute~=value]</td><td>[title~=flower]</td><td>选择 title 属性包含单词 flower 的所有节点</td></tr><tr><td>:link</td><td>a:link</td><td>选择所有未被访问的链接</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有已被访问的链接</td></tr><tr><td>:active</td><td>a:active</td><td>选择活动链接</td></tr><tr><td>:hover</td><td>a:hover</td><td>选择鼠标指针位于其上的链接</td></tr><tr><td>:focus</td><td>input:focus</td><td>选择获得焦点的 input 节点</td></tr><tr><td>:first-letter</td><td>p:first-letter</td><td>选择每个 p 节点的首字母</td></tr><tr><td>:first-line</td><td>p:first-line</td><td>选择每个 p 节点的首行</td></tr><tr><td>:first-child</td><td>p:first-child</td><td>选择属于父节点的第一个子节点的所有 p 节点</td></tr><tr><td>:before</td><td>p:before</td><td>在每个 p 节点的内容之前插入内容</td></tr><tr><td>:after</td><td>p:after</td><td>在每个 p 节点的内容之后插入内容</td></tr><tr><td>:lang(language)</td><td>p:lang</td><td>选择带有以 it 开头的 lang 属性值的所有 p 节点</td></tr><tr><td>element1~element2</td><td>p~ul</td><td>选择前面有 p 节点的所有 ul 节点</td></tr><tr><td>[attribute^=value]</td><td>a[src^=”https”]</td><td>选择其 src 属性值以 https 开头的所有 a 节点</td></tr><tr><td>[attribute$=value]</td><td>a[src$=”.pdf”]</td><td>选择其 src 属性以.pdf 结尾的所有 a 节点</td></tr><tr><td>[attribute*=value]</td><td>a[src*=”abc”]</td><td>选择其 src 属性中包含 abc 子串的所有 a 节点</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择属于其父节点的首个 p 节点的所有 p 节点</td></tr><tr><td>:last-of-type</td><td>p:last-of-type</td><td>选择属于其父节点的最后 p 节点的所有 p 节点</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择属于其父节点唯一的 p 节点的所有 p 节点</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择属于其父节点的唯一子节点的所有 p 节点</td></tr><tr><td>:nth-child(n)</td><td>p:nth-child</td><td>选择属于其父节点的第二个子节点的所有 p 节点</td></tr><tr><td>:nth-last-child(n)</td><td>p:nth-last-child</td><td>同上，从最后一个子节点开始计数</td></tr><tr><td>:nth-of-type(n)</td><td>p:nth-of-type</td><td>选择属于其父节点第二个 p 节点的所有 p 节点</td></tr><tr><td>:nth-last-of-type(n)</td><td>p:nth-last-of-type</td><td>同上，但是从最后一个子节点开始计数</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>选择属于其父节点最后一个子节点的所有 p 节点</td></tr><tr><td>:root</td><td>:root</td><td>选择文档的根节点</td></tr><tr><td>:empty</td><td>p:empty</td><td>选择没有子节点的所有 p 节点（包括文本节点）</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动的 #news 节点</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择每个启用的 input 节点</td></tr><tr><td>:disabled</td><td>input:disabled</td><td>选择每个禁用的 input 节点</td></tr><tr><td>:checked</td><td>input:checked</td><td>选择每个被选中的 input 节点</td></tr><tr><td>:not(selector)</td><td>:not</td><td>选择非 p 节点的所有节点</td></tr><tr><td>::selection</td><td>::selection</td><td>选择被用户选取的节点部分</td></tr></tbody></table><h1 id="爬虫的基本原理"><a href="#爬虫的基本原理" class="headerlink" title="爬虫的基本原理"></a>爬虫的基本原理</h1><h2 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h2><p>获取网页源代码 – 分析网页源代码 –数据保存</p><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>向网站的服务器发送一个请求(urllib、requests )–&gt;返回的响应体便是网页源代码(解析Body)</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>采用正则表达式提取(万能but比较复杂且容易出错)</p><p>根据网页节点属性、CSS 选择器或 XPath 来提取(Beautiful Soup、pyquery、lxml )</p><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>可以简单保存为 TXT 文本或 JSON 文本</p><p>也可以保存到数据库，如 MySQL 和 MongoDB 等</p><p>也可保存至远程服务器，如借助 SFTP 进行操作等</p><h3 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h3><p>在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行</p><h2 id="能抓怎样的数据"><a href="#能抓怎样的数据" class="headerlink" title="能抓怎样的数据"></a>能抓怎样的数据</h2><p>HTML 源代码 –常规网页</p><p>JSON 字符串– API 接口</p><p>二进制数据–图片、视频和音频等</p><p>各种扩展名的文件</p><h2 id="JavaScript-渲染页面"><a href="#JavaScript-渲染页面" class="headerlink" title="JavaScript 渲染页面"></a>JavaScript 渲染页面</h2><p>JavaScript 则会改变 HTML 中的节点，向其添加内容，最后得到完整的页面</p><p>但是在用 urllib 或 requests 等库请求当前页面时，我们得到的只是这个 HTML 代码，它不会帮助我们去继续加载这个 JavaScript 文件，这样也就看不到浏览器中的内容了</p><p>因此，使用基本 HTTP 请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，我们可以分析其后台 Ajax 接口，也可使用 Selenium、Splash 这样的库来实现模拟 JavaScript 渲染</p><h1 id="会话和-Cookies"><a href="#会话和-Cookies" class="headerlink" title="会话和 Cookies"></a>会话和 Cookies</h1><h2 id="静态网页和动态网页"><a href="#静态网页和动态网页" class="headerlink" title="静态网页和动态网页"></a>静态网页和动态网页</h2><p>静态网页：这种网页的内容是 HTML 代码编写的，文字、图片等内容均通过写好的 HTML 代码来指定。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据 URL 灵活多变地显示内容等。</p><p>动态网页：可以动态解析 URL 中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的 HTML，而是可能由 JSP、PHP、Python 等语言编写的，其功能比静态网页强大和丰富太多了</p><h2 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h2><p> 指HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话在服务端，也就是网站的服务器，用来保存用户的会话信息</p><p>会话对象用来存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在会话对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据</p><p>Cookies 在客户端，也可以理解为浏览器端，有了 Cookies，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别 Cookies 并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的响应。</p><p>Cookie属性</p><ul><li>Name，即该 Cookie 的名称。Cookie 一旦创建，名称便不可更改</li><li>Value，即该 Cookie 的值。如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码。</li><li>Max Age，即该 Cookie 失效的时间，单位秒，也常和 Expires 一起使用，通过它可以计算出其有效时间。Max Age 如果为正数，则该 Cookie 在 Max Age 秒之后失效。如果为负数，则关闭浏览器时 Cookie 即失效，浏览器也不会以任何形式保存该 Cookie。</li><li>Path，即该 Cookie 的使用路径。如果设置为 /path/，则只有路径为 /path/ 的页面可以访问该 Cookie。如果设置为 /，则本域名下的所有页面都可以访问该 Cookie。</li><li>Domain，即可以访问该 Cookie 的域名。例如如果设置为 .zhihu.com，则所有以 zhihu.com，结尾的域名都可以访问该 Cookie。</li><li>Size 字段，即此 Cookie 的大小。</li><li>Http 字段，即 Cookie 的 httponly 属性。若此属性为 true，则只有在 HTTP Headers 中会带有此 Cookie 的信息，而不能通过 document.cookie 来访问此 Cookie。</li><li>Secure，即该 Cookie 是否仅被使用安全协议传输。安全协议。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。</li></ul><p>会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效</p><p>持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。</p><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>代理网络用户去取得网络信息</p><p>此时本机不是直接向 Web 服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给 Web 服务器，接着由代理服务器再把 Web 服务器返回的响应转发给本机。–实现IP伪装</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>突破自身 IP 访问限制，访问一些平时不能访问的站点。</li><li>访问一些单位或团体内部资源，如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类 FTP 下载上传，以及各类资料查询共享等服务。</li><li>提高访问速度，通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li><li>隐藏真实 IP，上网者也可以通过这种方法隐藏自己的 IP，免受攻击，对于爬虫来说，我们用代理就是为了隐藏自身 IP，防止自身的 IP 被封锁。</li></ul><h2 id="爬虫代理"><a href="#爬虫代理" class="headerlink" title="爬虫代理"></a>爬虫代理</h2><p>由于爬虫爬取速度过快，在爬取过程中可能遇到同一个 IP 访问过于频繁的问题，此时网站就会让我们输入验证码登录或者直接封锁 IP，这样会给爬取带来极大的不便。</p><p>使用代理隐藏真实的 IP，让服务器误以为是代理服务器在请求自己。这样在爬取过程中通过不断更换代理，就不会被封锁，可以达到很好的爬取效果。</p><h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><h3 id="1-根据协议区分"><a href="#1-根据协议区分" class="headerlink" title="1. 根据协议区分"></a>1. 根据协议区分</h3><p>根据代理的协议，代理可以分为如下类别：</p><ul><li>FTP 代理服务器，主要用于访问 FTP 服务器，一般有上传、下载以及缓存功能，端口一般为 21、2121 等。</li><li>HTTP 代理服务器，主要用于访问网页，一般有内容过滤和缓存功能，端口一般为 80、8080、3128 等。</li><li>SSL/TLS 代理，主要用于访问加密网站，一般有 SSL 或 TLS 加密功能（最高支持 128 位加密强度），端口一般为 443。</li><li>RTSP 代理，主要用于 Realplayer 访问 Real 流媒体服务器，一般有缓存功能，端口一般为 554。</li><li>Telnet 代理，主要用于 telnet 远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为 23。</li><li>POP3/SMTP 代理，主要用于 POP3/SMTP 方式收发邮件，一般有缓存功能，端口一般为 110/25。</li><li>SOCKS 代理，只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为 1080。SOCKS 代理协议又分为 SOCKS4 和 SOCKS5，SOCKS4 协议只支持 TCP，而 SOCKS5 协议支持 TCP 和 UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说，SOCK4 能做到的 SOCKS5 都可以做到，但 SOCKS5 能做到的  SOCK4 不一定能做到。</li></ul><h3 id="2-根据匿名程度区分"><a href="#2-根据匿名程度区分" class="headerlink" title="2. 根据匿名程度区分"></a>2. 根据匿名程度区分</h3><p>根据代理的匿名程度，代理可以分为如下类别。</p><ul><li>高度匿名代理，高度匿名代理会将数据包原封不动的转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的 IP 是代理服务器的 IP。</li><li>普通匿名代理，普通匿名代理会在数据包上做一些改动，服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实 IP。代理服务器通常会加入的 HTTP 头有 HTTP_VIA 和 HTTP_X_FORWARDED_FOR。</li><li>透明代理，透明代理不但改动了数据包，还会告诉服务器客户端的真实 IP。这种代理除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</li><li>间谍代理，间谍代理指组织或个人创建的，用于记录用户传输的数据，然后进行研究、监控等目的代理服务器。</li></ul><h2 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h2><ul><li>使用网上的免费代理，最好使用高匿代理，使用前抓取下来筛选一下可用代理，也可以进一步维护一个代理池。</li><li>使用付费代理服务，互联网上存在许多代理商，可以付费使用，质量比免费代理好很多。</li><li>ADSL 拨号，拨一次号换一次 IP，稳定性高，也是一种比较有效的解决方案。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2023/06/08/Maven/"/>
      <url>/2023/06/08/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>理解并实现分模块开发</li><li>能够使用聚合工程快速构建项目</li><li>能够使用继承简化项目配置能够根据需求配置生成、开发、测试环境，并在各个环境间切换运行</li><li>了解Maven的私服</li></ul><h1 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h1><p>项目中的每一层都可以单独维护，也可以很方便被别人使用</p><ul><li>步骤<ol><li>创建新模块、放入内容</li><li>在原模块的pom.xml添加依赖</li><li>将新模块install到maven的本地仓库</li><li>注意新模块(如Dao)的pom.xml也要添加相关依赖</li></ol></li></ul><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><ul><li>依赖的优先级</li><li>可选依赖<code>optional</code> 不被别人用</li><li>排除依赖 <code>exclusions</code> 不用别人</li></ul><h1 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h1><ul><li><p>聚合</p><p>  将多个模块组织成一个整体，同时进行项目构建</p><ul><li>步骤<ol><li>创建一个空的maven项目</li><li>将项目的打包方式改为pom</li><li>pom.xml添加所要管理的项目(modules)</li></ol></li></ul></li><li><p>继承</p><p>  描述的是两个工程间的关系，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</p><ul><li>步骤<ol><li>创建一个Maven项目、打包方式为pom</li><li>在子项目中设置其父工程</li><li>优化子项目共有依赖导入问题<code>&lt;parent&gt;&amp;&lt;dependencyManagement&gt;</code></li></ol></li></ul></li></ul><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><ul><li>步骤<ol><li>父工程中定义属性  <code>—.properties</code></li><li><code>jdbc.properties</code>文件中引用属性</li><li>设置maven过滤文件范围  <code>&lt;filtering&gt;</code></li><li>修改依赖的versio <code>${spring.version}</code></li></ol></li></ul><h1 id="多环境配置与应用"><a href="#多环境配置与应用" class="headerlink" title="多环境配置与应用"></a>多环境配置与应用</h1><ul><li>步骤<ol><li>父工程配置多个环境,并指定默认激活环境 <code>—.properties</code></li><li>执行安装查看env_dep环境是否生效</li><li>切换默认环境为生产环境</li></ol></li><li>跳过测试<ol><li>IDEA—Toggle <code>Skip Test</code>Mode</li><li>pom.xml <code>&lt;skipTests&gt;false&lt;/skipTests&gt;</code></li><li><code>mvn 指令 -D skipTests</code></li></ol></li></ul><h1 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h1><p>公司内部搭建的用于存储Maven资源的服务器</p><p>没搞，感觉目前用不上</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="/2023/06/08/MybatisPlus/"/>
      <url>/2023/06/08/MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>基于MyBatisPlus完成标准Dao的增删改查功能</li><li>掌握MyBatisPlus中的分页及条件查询构建</li><li>掌握主键ID的生成策略</li><li>了解MyBatisPlus的代码生成器</li></ul><h1 id="入门步骤"><a href="#入门步骤" class="headerlink" title="入门步骤"></a>入门步骤</h1><ol><li>建表</li><li>建SpringBoot</li><li>pom.xml补全依赖</li><li>添加MP的相关配置信息  <code>application.yml</code></li><li>根据数据库表创建实体类</li><li>创建Dao接口</li><li>编写引导类   <code>Mybatisplus01QuickstartApplication</code></li><li>编写测试类</li></ol><h1 id="标准数据层开发"><a href="#标准数据层开发" class="headerlink" title="标准数据层开发"></a>标准数据层开发</h1><ul><li>增  <code>userDao.insert(user);</code></li><li>删   <code>userDao.deleteById(1L);</code></li><li>改   <code>userDao.updateById(user);</code></li><li>查<ul><li>查单个  <code>User user = userDao.selectById(2L);</code></li><li>查全部  <code>List&lt;User&gt; userList = userDao.selectList(null);</code></li><li>查分页  <code>userDao.selectPage(page,null);</code></li></ul></li><li>Lombko简化POJO实体类开发<ul><li>添加依赖</li><li>@Setter、@Getter、@ToString、@EqualsAndHashCode、@Data、@NoArgsConstructor、@AllArgsConstructor</li></ul></li></ul><h1 id="DQL编程控制"><a href="#DQL编程控制" class="headerlink" title="DQL编程控制"></a>DQL编程控制</h1><ul><li>条件查询方式<ul><li>QueryWrapper</li><li>QueryWrapper+lambda</li><li>LambdaQueryWrapper</li><li>单条件/多条件/null查询</li></ul></li><li>查询投影<ul><li>查询指定字段<code>lqw.select(User::getId,User::getName,User::getAge);</code></li><li>聚合查询<code>lqw.select("count() as count");</code></li><li>分组查询  <code>lqw.groupBy("tel");</code></li></ul></li><li>查询条件设定<ul><li>等值查询   <code>.eq(User::getName, "Jerry”)</code></li><li>范围查询   <code>.between(User::getAge, 10, 30);</code></li><li>模糊查询   <code>.likeLeft(User::getName, "J");</code></li><li>排序查询    <code>.orderBy(true,false, User::getId);</code></li></ul></li><li>字段映射与表名映射<ul><li>@TableFiled   <code>value\exit\true\select</code></li><li>@TableName  <code>value</code>    /—配置文件新增table-prefix</li></ul></li></ul><h1 id="DML编程控制"><a href="#DML编程控制" class="headerlink" title="DML编程控制"></a>DML编程控制</h1><ul><li>id生成策略控制<ul><li>@TableId   AUTO\INPUT\ASSING_ID\ASSING_UUID</li><li>简化配置    — 配置文件新增id-type</li></ul></li><li>多记录操作<ul><li><code>.deleteBatchIds(list);</code></li><li><code>.selectBatchIds(list);</code></li></ul></li><li>逻辑删除<ul><li>@TABLELOGIC    <code>value\deval</code></li></ul></li><li>乐观锁<ul><li>数据库&amp;模型类添加对应属性</li><li>添加拦截器</li><li>测试类<code>updateById</code></li></ul></li></ul><h1 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h1><ul><li>创建代码生成类—不用写<code>controller</code>,<code>service</code>，<code>mapper</code>和<code>entity</code>的基础框架辽！</li><li>代码地址：<code>https://mp.baomidou.com/guide/generator.html</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Day03  — AOP</title>
      <link href="/2023/06/08/SpringDay03%20%E2%80%94%20AOP/"/>
      <url>/2023/06/08/SpringDay03%20%E2%80%94%20AOP/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h1><ul><li>(Aspect Oriented Programming)面向切面编程，<strong>在不改原有代码的前提下对其进行增强  — 代理模式</strong></li><li>代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的</li><li>连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行</li><li>切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述</li><li>通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法</li><li>切面（Aspect）：描述通知与切入点的对应关系</li><li>目标对象（Target）：被代理的原始对象成为目标对象</li><li>通知类：定义通知的类</li></ul><h1 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>创建项目</li><li>添加spring依赖</li><li>添加Dao&amp;DaoImpl类</li><li>spring的配置类</li><li>编写app运行类</li></ol><h2 id="新增依赖"><a href="#新增依赖" class="headerlink" title="新增依赖"></a>新增依赖</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="定义通知类和通知-—-gt-定义切入点-—-gt-制作切面-—-gt-将通知类配给容器并标识其为切面类"><a href="#定义通知类和通知-—-gt-定义切入点-—-gt-制作切面-—-gt-将通知类配给容器并标识其为切面类" class="headerlink" title="定义通知类和通知 —> 定义切入点 —>  制作切面  —> 将通知类配给容器并标识其为切面类"></a>定义通知类和通知 —&gt; 定义切入点 —&gt;  制作切面  —&gt; 将通知类配给容器并标识其为切面类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>   <span class="comment">// 标注一个类为Spring容器的Bean</span></span><br><span class="line"><span class="meta">@Aspect</span>      <span class="comment">//告诉spring当成aop处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义通知类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> {</span><br><span class="line">    <span class="comment">//定义切入点   -- 只增强updata方法</span></span><br><span class="line">    <span class="meta">@Pointcut("execution(void com.itheima.dao.BookDao.update())")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//制作切面  --  描述通知和切入点之间的关系</span></span><br><span class="line">    <span class="meta">@Before("pt()")</span></span><br><span class="line">    <span class="comment">//定义通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="开启注解格式AOP功能"><a href="#开启注解格式AOP功能" class="headerlink" title="开启注解格式AOP功能"></a>开启注解格式AOP功能</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>   <span class="comment">//告诉spring这是注解开发 -- 去找@Aspect，进去识别@Pointcut</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        **bookDao.update();**</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h1><p>（好像不重要）</p><h2 id="Spring容器启动"><a href="#Spring容器启动" class="headerlink" title="Spring容器启动"></a>Spring容器启动</h2><ul><li>加载bean<ul><li>需要被增强的类，如:BookServiceImpl</li><li>通知类，如:MyAdvice</li></ul></li></ul><h2 id="读取所有切面配置中的切入点"><a href="#读取所有切面配置中的切入点" class="headerlink" title="读取所有切面配置中的切入点"></a>读取所有切面配置中的切入点</h2><h2 id="初始化bean"><a href="#初始化bean" class="headerlink" title="初始化bean"></a>初始化bean</h2><pre><code> * 匹配失败，创建原始对象 * 匹配成功，创建原始对象（目标对象）的代理对象</code></pre><h2 id="获取bean执行方法"><a href="#获取bean执行方法" class="headerlink" title="获取bean执行方法"></a>获取bean执行方法</h2><h1 id="AOP配置管理"><a href="#AOP配置管理" class="headerlink" title="AOP配置管理"></a><strong>AOP配置管理</strong></h1><h2 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h2><ul><li><code>*</code> ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">execution（public * com.itheima.*.UserService.find*(*))</span><br></pre></td></tr></tbody></table></figure><ul><li><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">execution（public User com..UserService.findById(..))</span><br></pre></td></tr></tbody></table></figure><ul><li>书写技巧<br>1. 按<strong>标准规范</strong>开发<br>2. 查询操作的返回值建议使用<em>匹配<br>3. 减少使用..的形式描述包<br>4. <strong>对接口进行描述</strong>，使用<em>表示模块名，例如UserService的匹配描述为</em>Service<br>5. 方法名书写保留动词，例如get，使用</em>表示名词，例如getById匹配描述为getBy*<br>6. 参数根据实际情况灵活调整</li></ul><h2 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h2><h2 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h2><pre><code>`@Before("pt()")`</code></pre><h2 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h2><pre><code>`@After("pt()")`</code></pre><h2 id="环绕通知-重点"><a href="#环绕通知-重点" class="headerlink" title="环绕通知(重点)"></a>环绕通知(重点)</h2><pre><code>`@Around("pt()")`</code></pre><ul><li><p>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用</p></li><li><p>环绕通知可以隔离原始方法的调用执行</p></li><li><p>环绕通知返回值设置为Object类型</p></li><li><p>环绕通知中可以对原始方法调用过程中出现的异常进行处理</p></li><li><p>返回后通知(了解)   <code>@AfterReturning("pt2()")</code></p></li><li><p>抛出异常后通知(了解)    <code>@AfterThrowing</code></p><p><img src="/img/%E5%90%84%E9%80%9A%E7%9F%A5%E5%AF%B9%E5%BA%94%E4%BD%8D%E7%BD%AE.png" alt="image-20230608112904274"></p></li></ul><h2 id="业务层接口执行效率"><a href="#业务层接口执行效率" class="headerlink" title="业务层接口执行效率"></a><strong>业务层接口执行效率</strong></h2><h2 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a><strong>AOP通知获取数据</strong></h2><h1 id="AOP事务管理"><a href="#AOP事务管理" class="headerlink" title="AOP事务管理"></a>AOP事务管理</h1><ul><li>在数据层或<strong>业务层</strong>保障一系列的数据库操作同成功同失败</li></ul><h2 id="转账案例-需求分析"><a href="#转账案例-需求分析" class="headerlink" title="转账案例-需求分析"></a><strong>转账案例-需求分析</strong></h2><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li><strong>准备数据库</strong></li></ol><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database spring_db <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">use spring_db;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_account(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">35</span>),</span><br><span class="line">money <span class="keyword">double</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_account <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tom'</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_account <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Jerry'</span>,<span class="number">1000</span>);</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>创建项目导入jar包</strong></li></ol><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>根据表创建模型类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="comment">//setter...getter...toString...方法略    </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li><strong>创建Dao接口</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> {</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update("update tbl_account set money = money + #{money} where name = #{name}")</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param("name")</span> String name, <span class="meta">@Param("money")</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update("update tbl_account set money = money - #{money} where name = #{name}")</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param("name")</span> String name, <span class="meta">@Param("money")</span> Double money)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><strong>创建Service接口和实现类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> {</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li><strong>添加jdbc.properties文件</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/spring_db?useSSL=false</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li><strong>创建JdbcConfig配置类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> {</span><br><span class="line">    <span class="meta">@Value("${jdbc.driver}")</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value("${jdbc.url}")</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value("${jdbc.username}")</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value("${jdbc.password}")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="8"><li><strong>创建MybatisConfig配置类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>{</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">"com.itheima.domain"</span>);</span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">"com.itheima.dao"</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ol start="9"><li><strong>创建SpringConfig配置类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="meta">@PropertySource("classpath:jdbc.properties")</span></span><br><span class="line"><span class="meta">@Import({JdbcConfig.class,MybatisConfig.class})</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="10"><li>编写测试类</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransfer</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    accountService.transfer(<span class="string">"Tom"</span>,<span class="string">"Jerry"</span>,<span class="number">100D</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/img/%E6%9C%80%E7%BB%88%E5%88%9B%E5%BB%BA%E5%A5%BD%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="image-20230608113114611"></p><p> 最终项目结构如上</p><h2 id="实现事务管理具体步骤"><a href="#实现事务管理具体步骤" class="headerlink" title="实现事务管理具体步骤"></a>实现事务管理具体步骤</h2><h2 id="需要被事务管理的方法上添加注解-Transactional"><a href="#需要被事务管理的方法上添加注解-Transactional" class="headerlink" title="需要被事务管理的方法上添加注解@Transactional"></a>需要被事务管理的方法上添加注解<code>@Transactional</code></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> {</span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">        **<span class="meta">@Transactional</span>**</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> {</span><br><span class="line">            accountDao.outMoney(out,money);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            accountDao.inMoney(in,money);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="在JdbcConfig类中配置事务管理器"><a href="#在JdbcConfig类中配置事务管理器" class="headerlink" title="在JdbcConfig类中配置事务管理器"></a>在JdbcConfig类中配置事务管理器</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//配置事务管理器，mybatis使用的是jdbc事务</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>{</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="在SpringConfig的配置类中开启事务注解-EnableTransactionManagement"><a href="#在SpringConfig的配置类中开启事务注解-EnableTransactionManagement" class="headerlink" title="在SpringConfig的配置类中开启事务注解  @EnableTransactionManagement"></a>在SpringConfig的配置类中开启事务注解  <code>@EnableTransactionManagement</code></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="meta">@PropertySource("classpath:jdbc.properties")</span></span><br><span class="line"><span class="meta">@Import({JdbcConfig.class,MybatisConfig.class})</span></span><br><span class="line"><span class="comment">//开启注解式事务驱动</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行测试类"><a href="#运行测试类" class="headerlink" title="运行测试类"></a>运行测试类</h2><h2 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h2><ul><li><code>@Transactional</code>参数</li></ul><p><img src="/img/@transactional%E5%8F%82%E6%95%B0.png" alt="Untitled"></p><h2 id="转账业务追加日志"><a href="#转账业务追加日志" class="headerlink" title="转账业务追加日志"></a>转账业务追加日志</h2><h2 id="创建日志表"><a href="#创建日志表" class="headerlink" title="创建日志表"></a>创建日志表</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_log(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">info <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">createDate datetime</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h2 id="添加LogDao接口"><a href="#添加LogDao接口" class="headerlink" title="添加LogDao接口"></a>添加LogDao接口</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogDao</span> {</span><br><span class="line">    <span class="meta">@Insert("insert into tbl_log (info,createDate) values(#{info},now())")</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String info)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="添加LogService接口与实现类"><a href="#添加LogService接口与实现类" class="headerlink" title="添加LogService接口与实现类"></a>添加LogService接口与实现类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogService</span> {</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,Double money )</span> {</span><br><span class="line">    logDao.log(<span class="string">"转账操作由"</span>+out+<span class="string">"到"</span>+in+<span class="string">",金额："</span>+money);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="在转账的业务中添加记录日志"><a href="#在转账的业务中添加记录日志" class="headerlink" title="在转账的业务中添加记录日志"></a>在转账的业务中添加记录日志</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 转账操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span><span class="keyword">throws</span> IOException ;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> {</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> {</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            accountDao.outMoney(out,money);</span><br><span class="line">            accountDao.inMoney(in,money);</span><br><span class="line">            }<span class="keyword">finally</span> {</span><br><span class="line">            logService.log(out,in,money);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><ul><li>事务协调员对事务管理员所携带事务的处理态度</li><li>转账失败后，所有的事务都回滚，导致日志没有记录下来 — 让log方法单独是一个事务</li><li><strong>修改logService改变事务的传播行为</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">    <span class="comment">//propagation设置事务属性：传播行为设置为当前操作需要新事务</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,Double money )</span> {</span><br><span class="line">        logDao.log(<span class="string">"转账操作由"</span>+out+<span class="string">"到"</span>+in+<span class="string">",金额："</span>+money);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/06/08/SpringBoot/"/>
      <url>/2023/06/08/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>掌握基于SpringBoot框架的程序开发步骤</li><li>熟练使用SpringBoot配置信息修改服务器</li><li>配置基于SpringBoot的完成SSM整合项目开发</li></ul><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ul><li><p>新建项目步骤</p><ol><li>新建模块 <code>Spring Initializr</code></li><li>创建controller</li><li>启动！</li></ol></li><li><p>Spring和SpringBoot对比<br>  <img src="/img/Spring%E5%92%8CSpringBoot%E5%AF%B9%E6%AF%94.png" alt="Untitled"></p></li><li><p>快速启动步骤</p><ol><li><code>packge</code>指令</li><li>进入jar包所在位置，在命令提示符中输入如下命令 <code>jar -jar 包名.jar</code></li></ol></li></ul><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><ul><li><p>yml</p><ul><li>类型</li><li>语法规则</li><li>读取配置数据</li><li>多环境配置</li></ul></li><li><p>配置文件分类</p><ul><li>1级：classpath：application.yml</li><li>2级：classpath：config/application.yml</li><li>3级：file ：application.yml</li><li>4级：file ：config/application.yml</li></ul></li></ul><h1 id="整合junit"><a href="#整合junit" class="headerlink" title="整合junit"></a>整合junit</h1><ol><li>在测试类上添加 <code>SpringBootTest</code> 注解</li><li>使用 <code>@Autowired</code> 注入要测试的资源</li><li>定义测试方法进行测试</li></ol><h1 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h1><ol><li>创建模块</li><li>定义实体类</li><li>定义Dao接口</li><li>定义测试类</li><li>编写配置  <code>application.yml</code></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/06/08/SpringMVC/"/>
      <url>/2023/06/08/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a><strong>主要内容</strong></h1><ul><li>SpringMVC简介</li><li><strong>请求与响应</strong></li><li><strong>REST风格</strong></li><li><strong>SSM整合(注解版)</strong></li><li>拦截器</li></ul><h1 id="SpringMVC的制作过程"><a href="#SpringMVC的制作过程" class="headerlink" title="SpringMVC的制作过程"></a><strong>SpringMVC的制作过程</strong></h1><ol><li>创建maven项目，补全目录结构</li><li>导入jar包，添加SpringMVC需要的依赖与servlet；配置Tomcat环境</li><li>创建Controller类：声明bean、提供方法处理请求、设置访问路径、设置当前操作返回值</li><li>创建springmvc的配置类，加载controller对应的bean</li><li>使用servlet容器启动的配置类替换web.xml</li><li>启动项目、浏览器访问</li></ol><ul><li><p>相关注解</p><p>  <strong>@Controller：</strong> 设定SpringMVC的核心控制器bean【Controller类处】</p><p>  <strong>@RequestMapping：</strong> 设置当前控制器方法请求访问路径【Controller类具体方法前：(”/save”)】</p><p>  <strong>@ResponseBody：</strong> 设置当前控制器方法响应内容为当前返回值【Controller类具体方法前】</p></li></ul><h1 id="设置springmvc和spring的加载范围"><a href="#设置springmvc和spring的加载范围" class="headerlink" title="设置springmvc和spring的加载范围"></a>设置springmvc和spring的加载范围</h1><ul><li><p>SpringMVC加载其相关bean(表现层bean),也就是controller包下的类</p></li><li><p>Spring控制的bean</p><ul><li>业务bean(Service)</li><li>功能bean(DataSource,SqlSessionFactoryBean,MapperScannerConfigurer等)</li></ul></li><li><p>相关注解</p><p>  <strong>@ComponentScan</strong>：设置spring配置类扫描路径【类上方，属性：excludeFilters&amp;includeFilters&amp;type】</p>  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan({"com.itheima.service","comitheima.dao"})</span></span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value="com.itheima",</span></span><br><span class="line"><span class="meta">    excludeFilters=@ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">        type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">        classes = Controller.class  //过滤的注解类型</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="springmvc更简单的配置类"><a href="#springmvc更简单的配置类" class="headerlink" title="springmvc更简单的配置类"></a><strong>springmvc更简单的配置类</strong></h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> {</span><br><span class="line">        <span class="comment">//加载spring配置类</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]{SpringConfig.class};</span><br><span class="line">    }</span><br><span class="line">        <span class="comment">//加载指定(springmvcc)配置类</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]{SpringMvcConfig.class};</span><br><span class="line">    }</span><br><span class="line">        <span class="comment">//设置由springmvc控制器处理的请求映射路径</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"/"</span>};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a><strong>请求与响应</strong></h1><ul><li><p>区分访问不同controller相同名字的方法</p><ol><li>在访问路径前加controller区分</li><li>在类前面新增@RequestMapping(“/方法名”)</li></ol></li><li><p>接收页面传递的参数</p><ul><li><p>GET/POST  —发送单/多个参数</p><ul><li>直接在方法处接受参数</li><li>普通、POJO、嵌套POJO、数组、集合</li></ul></li><li><p>解决请求乱码问题</p><ul><li>GET：修改pom.xml</li><li>POST:配置过滤器</li></ul></li><li><p>形参与地址参数名不一致</p><p>  使用**@RequestParam**注解</p></li><li><p>接收日期/时间类型</p><p>  使用@DateTimeFormat注解</p></li></ul></li><li><p>相关注解</p><ol><li><strong>@REQUESTPARAM：</strong> 绑定请求参数与处理器方法形参间的关系【方法具体参数处】</li><li><strong>@ENABLEWEBMVC：</strong> 开启SpringMVC多项辅助功能【配置类定义上方】</li><li><strong>@RequestBody：</strong> 将请求中请求体所包含的数据传递给请求参数、设置当前控制器返回值作为响应体【方法形参定义前面】</li><li><strong>@DateTimeFormat</strong> ：设定日期时间型数据格式【方法具体参数处】</li></ol></li></ul><h1 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a><strong>REST风格</strong></h1><p>使用<strong>行为动作</strong>区分对资源进行了何种操作：查询(GET)新增(POST)修改(PUT)删除(DELETE)</p><p>页面访问：SpringMVC需要将静态资源进行放行</p><ul><li><p>相关注解</p><p>  <strong>@RestController：</strong> 等同于@Controller与@ResponseBody两个注解组合功能</p><p>  <strong>@GetMapping @PostMapping @PutMapping @DeleteMapping：</strong> 设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作【注意delete和get后面要有具体id】</p></li></ul><h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a><strong>SSM整合</strong></h1><blockquote><p>李老师大好人，就是把之前所有的代码都理了一遍</p></blockquote><ul><li><p>整合配置</p><ol><li>创建web项目</li><li>添加依赖</li><li>创建项目包结构</li><li>创建ssm+jdbc-config配置类</li></ol></li><li><p>功能模块开发</p><ol><li>table</li><li>domain</li><li>Dao</li><li>Service</li><li>Controller</li></ol></li><li><p>单元/PostMan测试</p></li><li><p>事务管理</p><ol><li>SpringConfig</li><li>jdbcConfig</li><li>BookService</li></ol></li><li><p><strong>统一结果封装</strong></p><ol><li>Result类</li><li>Code类</li><li>修改Controller类的返回值</li></ol></li><li><p><strong>统一异常处理</strong></p><ol><li>创建异常处理器类</li><li>搞个异常测试一下</li></ol></li><li><p>相关注解</p><p>  <strong>@RestControllerAdvice：</strong> 为Rest风格开发的控制器类做增强</p><p>  <strong>@ExceptionHandler：</strong> 设置指定异常的处理方案</p></li></ul><h1 id="前后台协议联调"><a href="#前后台协议联调" class="headerlink" title="前后台协议联调"></a>前后台协议联调</h1><ol><li>将静态资源进行放行</li><li>根据不同业务进行不同操作</li></ol><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><ul><li>开发步骤<ol><li>创建拦截器类interceptor</li><li>配置拦截器类SpringMvcConfig</li><li>修改拦截器拦截规则</li><li>配置多个拦截器</li></ol></li><li>拦截器参数<ul><li>request、response、<strong>handler、</strong> modelAndView</li></ul></li></ul><blockquote><p>一般环境准备步骤</p><ol><li>创建一个Web的Maven项目</li><li>pom.xml添加Spring依赖</li><li>创建对应的配置类（config）</li><li>编写controller、domain</li><li>（启动一下看是否能正常运行）</li></ol></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>探索日记</title>
      <link href="/2023/06/07/%E6%85%A2%E6%85%A2%E5%A1%AB%E5%9D%91/"/>
      <url>/2023/06/07/%E6%85%A2%E6%85%A2%E5%A1%AB%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>感觉还有好多可以慢慢探索的地方<br>暑假找时间直接把幕布上面的笔记全部换成md文件放上去<br>看看字数能不能破20k O(∩_∩)O （破了的那天要去吃麦当劳庆祝一下<br>那这篇就专门用来撰写我的探索日记<br>暑假争取<br>第一周：把SSM和JavaWeb整理出来<br>第二周：瑞吉+刷LeetCode<br>第三周：Redis + SpringBoot<br>再以后的时间以后再说( •̀ ω •́ )y （因为现在还有期末考试这个b东西o(≧口≦)o</p><ul><li><p>博客内容</p><ul><li>java</li><li>mysql</li><li>python</li><li>微博</li><li>图库</li><li>音乐</li><li>观影感</li><li>碎碎念</li><li>…</li></ul></li><li><p>博客美化</p><ul><li>3d人物 </li><li>评论</li><li>音乐播放器</li><li>头图加载动态图</li><li>博客时间线</li><li>分类 / 标签</li><li>…</li></ul></li></ul><hr><blockquote><p>2024 - 04 - 23</p></blockquote><p>好久没打开过自己的博客了</p><p>这一年来一直沉迷于各种在线文档笔记，像飞书、语雀</p><p>更加多元化的样式和多平台的同步确实更适合记录</p><p>昨天写编译原理作业的时候偶然闯进了一位华师学长的博客</p><p>这里除了技术，更多的是生活所思所想</p><p>巧的是还从蛛丝马迹中发现了他之前也是北中的</p><p>突然想起自己一开始搭建博客就是因为在学瑞吉外卖的时候找到了一位</p><p>然后惊奇地发现他的学习路线几乎和我一摸一样，时间点也刚好在我一年前</p><p>继续逛下去发现他居然也会打游戏打到腱鞘炎、因为测试数据的锅找了半天的bug</p><p>……</p><p>我不知道在哪里记录自己的迷茫和期待</p><p>那就从这里开始吧</p><p>一个人学难免麻木，幸好世界上有这么多我可以共鸣的人</p><p>春天总是在干一些充满希望的事情</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Day02  —  注解开发</title>
      <link href="/2023/06/07/Spring-Day2%20%E2%80%94%20%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
      <url>/2023/06/07/Spring-Day2%20%E2%80%94%20%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="IOC-x2F-DI配置管理第三方bean"><a href="#IOC-x2F-DI配置管理第三方bean" class="headerlink" title="IOC/DI配置管理第三方bean"></a>IOC/DI配置管理第三方bean</h1><h2 id="案例：配置Druid"><a href="#案例：配置Druid" class="headerlink" title="案例：配置Druid"></a>案例：配置Druid</h2><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>创建maven项目</li><li>pom.xml添加依赖 <code>spring-context</code></li><li>resources下添加 <code>applicationContext.xml</code></li><li>编写运行类 <code>ApplicationContext ctx</code></li></ol><h2 id="pom-xml导入-druid-依赖"><a href="#pom-xml导入-druid-依赖" class="headerlink" title="pom.xml导入 druid 依赖"></a><strong>pom.xml导入 <code>druid</code> 依赖</strong></h2><h2 id="配置类配置第三方bean"><a href="#配置类配置第三方bean" class="headerlink" title="配置类配置第三方bean"></a><strong>配置类配置第三方bean</strong></h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--管理DruidDataSource对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring_db"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"950827"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="从IOC容器中获取对应的bean对象"><a href="#从IOC容器中获取对应的bean对象" class="headerlink" title="从IOC容器中获取对应的bean对象"></a><strong>从IOC容器中获取对应的bean对象</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) ctx.getBean(<span class="string">"dataSource"</span>);</span><br><span class="line">    System.out.println(dataSource);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>对于新的技术，不知道具体的坐标该如何查找?<ol><li>百度</li><li>从mvn的仓库<code>https://mvnrepository.com/</code>中进行搜索</li></ol></li><li>报的错为<strong>ClassNotFoundException</strong>，具体的类为<code>com.mysql.jdbc.Driver</code>错误的原因是缺少mysql的驱动包<ol><li>在pom.xml把驱动包引入即可</li></ol></li></ol><h2 id="加载properties文件"><a href="#加载properties文件" class="headerlink" title="加载properties文件"></a>加载properties文件</h2><p>原因： 属性写在Spring的配置文件中不利于后期维护<br>​                           —&gt; <strong>将这些值提取到一个外部的properties配置文件中</strong></p><p>具体步骤：</p><h2 id="resources下创建一个jdbc-properties文件"><a href="#resources下创建一个jdbc-properties文件" class="headerlink" title="resources下创建一个jdbc.properties文件"></a>resources下创建一个jdbc.properties文件</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></tbody></table></figure><h2 id="开启context命名空间、加载properties配置文件、完成属性注入"><a href="#开启context命名空间、加载properties配置文件、完成属性注入" class="headerlink" title="开启context命名空间、加载properties配置文件、完成属性注入"></a><strong>开启<code>context</code>命名空间、加载properties配置文件、完成属性注入</strong></h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line">**<span class="comment">&lt;!--开启context命名空间--&gt;</span>**</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载properties配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"jdbc.properties"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--**完成属性注入**--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"${jdbc.driver}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${jdbc.username}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="多个property文件需要加载时"><a href="#多个property文件需要加载时" class="headerlink" title="多个property文件需要加载时"></a>多个property文件需要加载时</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"jdbc.properties,jdbc2.properties"</span> <span class="attr">system-properties-mode</span>=<span class="string">"NEVER"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"*.properties"</span> <span class="attr">system-properties-mode</span>=<span class="string">"NEVER"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:*.properties"</span> <span class="attr">system-properties-mode</span>=<span class="string">"NEVER"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:*.properties"</span> <span class="attr">system-properties-mode</span>=<span class="string">"NEVER"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h1 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h1><p> 简单的理解为<code>ApplicationContext</code></p><h2 id="容器的创建方式"><a href="#容器的创建方式" class="headerlink" title="容器的创建方式"></a>容器的创建方式</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//类路径下的XML配置文件    掌握</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//文件系统下的XML配置文件  了解</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">"D:\\workspace\\spring\\spring_10_container\\src\\main\\resources\\applicationContext.xml"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="bean的三种获取方式"><a href="#bean的三种获取方式" class="headerlink" title="bean的三种获取方式"></a>bean的三种获取方式</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方式一   getBean("名称"):需要类型转换</span></span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">"bookDao"</span>);</span><br><span class="line"><span class="comment">//方式二    getBean("名称",类型.class):多了一个参数</span></span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">"bookDao"</span>，BookDao.class);</span><br><span class="line"><span class="comment">//方式三    容器中不能有多个该类的bean对象</span></span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br></pre></td></tr></tbody></table></figure><h2 id="容器类层次结构"><a href="#容器类层次结构" class="headerlink" title="容器类层次结构"></a>容器类层次结构</h2><ul><li><strong>容器的最上级的父接口为 BeanFactory</strong></li></ul><h2 id="BeanFactory-—额额不太懂"><a href="#BeanFactory-—额额不太懂" class="headerlink" title="BeanFactory  —额额不太懂"></a>BeanFactory  —额额不太懂</h2><h2 id="使用BeanFactory来创建IOC容器"><a href="#使用BeanFactory来创建IOC容器" class="headerlink" title="使用BeanFactory来创建IOC容器"></a>使用BeanFactory来创建IOC容器</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForBeanFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">//创建了一个bf的IOC容器</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resources);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用BeanFactory创建的容器是<strong>延迟加载</strong></li><li>使用ApplicationContext创建的容器是<strong>立即加载</strong></li><li>具体BeanFactory如何创建只需要了解即可</li></ul><h1 id="IOC-x2F-DI注解开发"><a href="#IOC-x2F-DI注解开发" class="headerlink" title="IOC/DI注解开发"></a>IOC/DI注解开发</h1><h2 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a><strong>注解开发定义bean</strong></h2><ol><li>环境准备</li><li>删除原XML配置的<code>&lt;bean&gt;</code>标签</li><li>Dao上添加<code>@Component</code>注解</li><li>配置Spring的注解包扫描 <code>@ComponentScan</code></li><li>ServiceImpl类上也添加<code>@Component</code></li><li>运行行为类测试</li></ol><p><img src="/img/XML%E4%B8%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="XML与注解配置的对应关系"></p><p><code>@Controller</code> 、<code>@Service</code>、<code>@Repository</code></p><h2 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h2><ul><li>将配置文件applicationContext.xml删除掉，使用类来替换</li></ul><h2 id="【❗更新】环境准备"><a href="#【❗更新】环境准备" class="headerlink" title="【❗更新】环境准备"></a>【❗更新】环境准备</h2><ol><li>创建maven</li><li>pom.xml</li><li><strong>springconfig【刚学的注解开发定义bean】</strong></li><li>添加类</li></ol><h2 id="创建一个配置类SpringConfig-、标识该类为配置类、用注解替换包扫描配置"><a href="#创建一个配置类SpringConfig-、标识该类为配置类、用注解替换包扫描配置" class="headerlink" title="创建一个配置类SpringConfig 、标识该类为配置类、用注解替换包扫描配置"></a>创建一个配置类<code>SpringConfig</code> 、标识该类为配置类、用注解替换包扫描配置</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//将其标识为一个配置类,替换`applicationContext.xml`</span></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="comment">//替换`&lt;context:component-scan base-package=""/&gt;`</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建运行类并执行"><a href="#创建运行类并执行" class="headerlink" title="创建运行类并执行"></a>创建运行类并执行</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">"bookDao"</span>);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        System.out.println(bookService);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注解开发bean的作用范围和生命周期管理"><a href="#注解开发bean的作用范围和生命周期管理" class="headerlink" title="注解开发bean的作用范围和生命周期管理"></a>注解开发bean的作用范围和生命周期管理</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Scope("prototype")</span>   <span class="comment">//@Scope设置bean的作用范围</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"book dao save ..."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//在构造方法之后执行，替换 init-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"init ..."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//在销毁方法之前执行,替换 destroy-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"destroy ..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注解对应关系图</strong><img src="/img/%E6%B3%A8%E8%A7%A3%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="Untitled"></p><h1 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h1><h2 id="bean和service的关系"><a href="#bean和service的关系" class="headerlink" title="bean和service的关系"></a>bean和service的关系</h2><ul><li>之前的配置文件application配置好的bean和service的关系还没用注解开发，所以bookDao对象为Null,调用其save方法就会报<strong>空指针异常</strong>。</li><li>解决办法：在BookServiceImpl类的bookDao属性上添加<code>@Autowired</code>注解<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">        <span class="comment">//  public void setBookDao(BookDao bookDao) {</span></span><br><span class="line">        <span class="comment">//        this.bookDao = bookDao;</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"book service save ..."</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="按照名称注入"><a href="#按照名称注入" class="headerlink" title="按照名称注入"></a>按照名称注入</h2><ul><li>如果Dao接口类有多个实现类，解决方案:<code>按照名称注入</code></li></ul><h2 id="DaoImpl文件"><a href="#DaoImpl文件" class="headerlink" title="DaoImpl文件"></a>DaoImpl文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//起别名</span></span><br><span class="line"><span class="meta">@Repository("bookDao")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"book dao save ..."</span> );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">    <span class="meta">@Repository("bookDao2")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"book dao save ...2"</span> );</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ServiceImpl文件"><a href="#ServiceImpl文件" class="headerlink" title="ServiceImpl文件"></a>ServiceImpl文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier("bookDao1")</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"book service save ..."</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="简单数据类型注入"><a href="#简单数据类型注入" class="headerlink" title="简单数据类型注入"></a>简单数据类型注入</h2><h2 id="DaoImpl文件-1"><a href="#DaoImpl文件-1" class="headerlink" title="DaoImpl文件"></a>DaoImpl文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Repository("bookDao")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    **<span class="keyword">private</span> String name;**</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"book dao save ..."</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ServiceImpl文件-1"><a href="#ServiceImpl文件-1" class="headerlink" title="ServiceImpl文件"></a>ServiceImpl文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Repository("bookDao")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    **<span class="meta">@Value("itheima")</span>**</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"book dao save ..."</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h2><h2 id="resource下准备properties文件"><a href="#resource下准备properties文件" class="headerlink" title="resource下准备properties文件"></a>resource下准备properties文件</h2><h2 id="springconfig加载properties配置文件"><a href="#springconfig加载properties配置文件" class="headerlink" title="springconfig加载properties配置文件"></a>springconfig加载properties配置文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="comment">//如果要指定多个配置文件，不支持使用通配符*</span></span><br><span class="line"><span class="comment">//1.@PropertySource({"jdbc.properties","xxx.properties"})</span></span><br><span class="line"><span class="comment">//2.@PropertySource({"classpath:jdbc.properties"})</span></span><br><span class="line"><span class="meta">@PropertySource("jdbc.properties")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="DaoImpl读取配置文件中的内容"><a href="#DaoImpl读取配置文件中的内容" class="headerlink" title="DaoImpl读取配置文件中的内容"></a>DaoImpl读取配置文件中的内容</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Repository("bookDao")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    **<span class="meta">@Value("${name}")</span>**</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"book dao save ..."</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="IOC-x2F-DI注解开发管理第三方bean"><a href="#IOC-x2F-DI注解开发管理第三方bean" class="headerlink" title="IOC/DI注解开发管理第三方bean"></a>IOC/DI注解开发管理第三方bean</h1><pre><code>- 第三方的类都是在jar包中，我们没有办法在类上面添加注解？</code></pre><h2 id="案例：注解开发管理第三方bean"><a href="#案例：注解开发管理第三方bean" class="headerlink" title="案例：注解开发管理第三方bean"></a>案例：注解开发管理第三方bean</h2><h2 id="导入对应的jar包"><a href="#导入对应的jar包" class="headerlink" title="导入对应的jar包"></a><strong>导入对应的jar包</strong></h2><h2 id="在配置类中添加一个方法、添加-Bean注解"><a href="#在配置类中添加一个方法、添加-Bean注解" class="headerlink" title="在配置类中添加一个方法、添加@Bean注解"></a><strong>在配置类中添加一个方法、添加<code>@Bean</code>注解</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">    **<span class="meta">@Bean</span>**</span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        ds.setUrl(<span class="string">"jdbc:mysql://localhost:3306/spring_db"</span>);</span><br><span class="line">        ds.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        ds.setPassword(<span class="string">"950827"</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="从IOC容器中获取对象并打印"><a href="#从IOC容器中获取对象并打印" class="headerlink" title="从IOC容器中获取对象并打印"></a><strong>从IOC容器中获取对象并打印</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="引入外部配置类"><a href="#引入外部配置类" class="headerlink" title="引入外部配置类"></a><strong>引入外部配置类</strong></h2><h2 id="新建一个JdbcConfig配置类"><a href="#新建一个JdbcConfig配置类" class="headerlink" title="新建一个JdbcConfig配置类"></a>新建一个<code>JdbcConfig</code>配置类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        ds.setUrl(<span class="string">"jdbc:mysql://localhost:3306/spring_db"</span>);</span><br><span class="line">        ds.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        ds.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="在Spring配置类中引入-import"><a href="#在Spring配置类中引入-import" class="headerlink" title="在Spring配置类中引入 @import"></a><strong>在Spring配置类中引入 <code>@import</code></strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan("com.itheima.config")</span></span><br><span class="line"><span class="comment">//@Import参数需要的是一个数组，可以引入多个配置类</span></span><br><span class="line"><span class="meta">@Import({JdbcConfig.class})</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注解开发实现为第三方bean注入资源"><a href="#注解开发实现为第三方bean注入资源" class="headerlink" title="注解开发实现为第三方bean注入资源"></a>注解开发实现为第三方bean注入资源</h2><h2 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><p> —— 使用<code>@Value</code>注解引入值</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> {</span><br><span class="line">    <span class="meta">@Value("com.mysql.jdbc.Driver")</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value("jdbc:mysql://localhost:3306/spring_db")</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value("root")</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value("password")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><h3 id="在SpringConfig中扫描BookDao"><a href="#在SpringConfig中扫描BookDao" class="headerlink" title="在SpringConfig中扫描BookDao"></a>在SpringConfig中扫描BookDao</h3><p>—— <code>@ComponentScan("com.itheima.dao")</code></p><h3 id="在JdbcConfig类的方法上添加参数"><a href="#在JdbcConfig类的方法上添加参数" class="headerlink" title="在JdbcConfig类的方法上添加参数"></a><strong>在JdbcConfig类的方法上添加参数</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao bookDao)</span>{</span><br><span class="line">    <span class="comment">//在这里！</span></span><br><span class="line">    **System.out.println(bookDao);**</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(driver);</span><br><span class="line">    ds.setUrl(url);</span><br><span class="line">    ds.setUsername(userName);</span><br><span class="line">    ds.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h1><p><img src="/img/%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93.png" alt="Untitled"></p><h1 id="spring整合！-–整合Mybatis"><a href="#spring整合！-–整合Mybatis" class="headerlink" title="spring整合！  –整合Mybatis"></a>spring整合！  –整合Mybatis</h1><h2 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h2><h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database spring_db <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">use spring_db;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_account(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">35</span>),</span><br><span class="line">    money <span class="keyword">double</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h2 id="创建项目导入jar包"><a href="#创建项目导入jar包" class="headerlink" title="创建项目导入jar包**"></a>创建项目导入jar包**</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="根据表创建模型类"><a href="#根据表创建模型类" class="headerlink" title="根据表创建模型类"></a><strong>根据表创建模型类</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Double money;</span><br><span class="line">        <span class="comment">//setter...getter...toString...方法略    </span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="创建Dao接口"><a href="#创建Dao接口" class="headerlink" title="创建Dao接口"></a><strong>创建Dao接口</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert("insert into tbl_account(name,money)values(#{name},#{money})")</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete("delete from tbl_account where id = #{id} ")</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update("update tbl_account set name = #{name} , money = #{money} where id = #{id} ")</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select("select * from tbl_account")</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select("select * from tbl_account where id = #{id} ")</span></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建Service接口和实现类"><a href="#创建Service接口和实现类" class="headerlink" title="创建Service接口和实现类"></a><strong>创建Service接口和实现类</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入依赖</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> {</span><br><span class="line">    accountDao.save(account);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>{</span><br><span class="line">    accountDao.update(account);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> {</span><br><span class="line">    accountDao.delete(id);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(Integer id)</span> {</span><br><span class="line">    <span class="keyword">return</span> accountDao.findById(id);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="添加jdbc-properties文件"><a href="#添加jdbc-properties文件" class="headerlink" title="添加jdbc.properties文件"></a><strong>添加jdbc.properties文件</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/spring_db?useSSL=false</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></tbody></table></figure><h2 id="添加Mybatis核心配置文件"><a href="#添加Mybatis核心配置文件" class="headerlink" title="添加Mybatis核心配置文件"></a><strong>添加Mybatis核心配置文件</strong></h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取外部properties配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--别名扫描的包路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.itheima.domain"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${jdbc.driver}"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${jdbc.username}"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--映射文件扫描包路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.itheima.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="编写应用程序"><a href="#编写应用程序" class="headerlink" title="编写应用程序"></a><strong>编写应用程序</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">// 1. 创建SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 2. 加载SqlMapConfig.xml配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml.bak"</span>);</span><br><span class="line">        <span class="comment">// 3. 创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        <span class="comment">// 4. 获取SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 5. 执行SqlSession对象执行查询，获取结果User</span></span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> sqlSession.getMapper(AccountDao.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountDao.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a><strong>运行程序</strong></h2><h2 id="正式整合！"><a href="#正式整合！" class="headerlink" title="正式整合！"></a>正式整合！</h2><h2 id="项目中导入整合需要的jar包"><a href="#项目中导入整合需要的jar包" class="headerlink" title="项目中导入整合需要的jar包"></a>项目中导入整合需要的jar包</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring操作数据库需要该jar包--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring与Mybatis整合的jar包</span></span><br><span class="line"><span class="comment">这个jar包mybatis在前面，是Mybatis提供的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>**mybatis-spring**<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="创建Spring的主配置类"><a href="#创建Spring的主配置类" class="headerlink" title="创建Spring的主配置类"></a><strong>创建Spring的主配置类</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//配置类注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//包扫描，主要扫描的是项目中的AccountServiceImpl类【有注解@Service】</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建数据源的配置类"><a href="#创建数据源的配置类" class="headerlink" title="创建数据源的配置类**"></a>创建数据源的配置类**</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> {</span><br><span class="line">    <span class="meta">@Value("${jdbc.driver}")</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value("${jdbc.url}")</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value("${jdbc.username}")</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value("${jdbc.password}")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建Mybatis配置类并配置SqlSessionFactory"><a href="#创建Mybatis配置类并配置SqlSessionFactory" class="headerlink" title="创建Mybatis配置类并配置SqlSessionFactory**"></a>创建Mybatis配置类并配置SqlSessionFactory**</h2><p>— 代替Mybatis核心配置文件</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> {</span><br><span class="line"><span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="comment">//引用注解 -- 直接在函数参数那放一个</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>{</span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    <span class="comment">//设置模型类的别名扫描</span></span><br><span class="line">    ssfb.setTypeAliasesPackage(<span class="string">"com.itheima.domain"</span>);</span><br><span class="line">    <span class="comment">//设置数据源</span></span><br><span class="line">    ssfb.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> ssfb;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">    msc.setBasePackage(<span class="string">"com.itheima.dao"</span>);</span><br><span class="line">    <span class="keyword">return</span> msc;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="主配置类中读properties并引入数据源配置类、Mybatis配置类"><a href="#主配置类中读properties并引入数据源配置类、Mybatis配置类" class="headerlink" title="主配置类中读properties并引入数据源配置类、Mybatis配置类"></a><strong>主配置类中读properties并引入数据源配置类、Mybatis配置类</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line">**<span class="meta">@PropertySource("classpath:jdbc.properties")</span></span><br><span class="line"><span class="meta">@Import({JdbcConfig.class,MybatisConfig.class})</span>**</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Day01—  IOC&amp;DI</title>
      <link href="/2023/06/05/Spring-Day1/"/>
      <url>/2023/06/05/Spring-Day1/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Day1-—-IOC-amp-DI"><a href="#Spring-Day1-—-IOC-amp-DI" class="headerlink" title="Spring-Day1   —  IOC&amp;DI"></a>Spring-Day1   —  IOC&amp;DI</h1><h2 id="学什么"><a href="#学什么" class="headerlink" title="学什么"></a>学什么</h2><p> 简化开发: Spring框架中提供了两个大的核心技术</p><ul><li>IOC</li><li>AOP</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="IOC-amp-IOC容器-amp-Bean"><a href="#IOC-amp-IOC容器-amp-Bean" class="headerlink" title="IOC &amp; IOC容器 &amp; Bean"></a>IOC &amp; IOC容器 &amp; Bean</h3><ul><li>IOC（Inversion of Control）控制反转</li><li>不自己new对象，交给容器new – 解耦</li><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为Bean</li></ul><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><ul><li>（Dependency Injection）依赖注入</li><li>建立容器中对象与对象之间的绑定关系</li><li>service运行需要依赖dao对象</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="解耦BookDao"><a href="#解耦BookDao" class="headerlink" title="解耦BookDao"></a>解耦<strong>BookDao</strong></h3><ol><li><p>pom.xml添加依赖</p></li><li><p>添加案例中需要的类</p></li><li><p>添加spring配置文件applicationContext.xml   </p>  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--1.导入spring的坐标spring-context--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.配置bean--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">    注意class不要写成接口类而是实现类，因为bean要找对象</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>获取IOC容器、从容器中获取对象进行方法调用</p><pre><code>   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>); </span><br><span class="line"><span class="comment">//getBean() 方法获取的 Bean 的标识符（id 或 name 属性的值），返回的是一个通用的 Object 类型，我们需要将其转换为 BookService 类型</span></span><br><span class="line"><span class="comment">//        BookDao bookDao = (BookDao) ctx.getBean("bookDao");</span></span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">"bookService"</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> </code></pre></li><li><p>运行程序测试</p></li></ol><h3 id="解耦BookService"><a href="#解耦BookService" class="headerlink" title="解耦BookService"></a>解耦<strong>BookService</strong></h3><ol><li><p>去除BookServiceImpl中的new，为属性提供setter方法</p>  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> {</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"book service save ..."</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> {</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改配置完成注入</p>  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">        name属性表示配置哪一个具体的属性/对象名称</span></span><br><span class="line"><span class="comment">        ref属性表示参照哪一个bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bookDao"</span> <span class="attr">ref</span>=<span class="string">"bookDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>运行程序</p></li></ol><h2 id="关于bean"><a href="#关于bean" class="headerlink" title="关于bean"></a>关于<strong>bean</strong></h2><h3 id="bean的基础配置"><a href="#bean的基础配置" class="headerlink" title="bean的基础配置"></a>bean的基础配置</h3><h4 id="配置别名-name"><a href="#配置别名-name" class="headerlink" title="配置别名   name"></a>配置别名   <code>name</code></h4> <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">name</span>=<span class="string">"service service4 bookEbi"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bookDao"</span> <span class="attr">ref</span>=<span class="string">"bookDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="配置范围（是否为单例）-scode"><a href="#配置范围（是否为单例）-scode" class="headerlink" title="配置范围（是否为单例）  scode"></a>配置范围（是否为单例）  <code>scode</code></h4> <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookDao"</span> <span class="attr">name</span>=<span class="string">"dao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="bean的实例化"><a href="#bean的实例化" class="headerlink" title="bean的实例化"></a>bean的实例化</h3><h4 id="构造方法实例化-—-无参构造方法"><a href="#构造方法实例化-—-无参构造方法" class="headerlink" title="构造方法实例化   —  无参构造方法"></a>构造方法实例化   —  无参构造方法</h4><p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果</p><h4 id="静态工厂实例化-—-了解即可"><a href="#静态工厂实例化-—-了解即可" class="headerlink" title="静态工厂实例化   — 了解即可"></a>静态工厂实例化   — 了解即可</h4><h4 id="实例工厂化-—-额额不太懂"><a href="#实例工厂化-—-额额不太懂" class="headerlink" title="实例工厂化   —  额额不太懂"></a>实例工厂化   —  <strong>额额不太懂</strong></h4><ol><li>准备一个Dao和DaoImpl类</li><li>创建一个工厂类OrderDaoFactory并提供一个普通方法  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> {</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li>创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; {</span><br><span class="line"><span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line"><span class="comment">//替代UseDaoFactory的getUserDao方法</span></span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//返回所创建类的Class对象</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getObjectType() {</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li></ul><ol><li><p>配置文件添加</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.factory.UserDaoFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>编写AppForInstanceUser运行类，在类中通过工厂获取对象</p> <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">        <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><h4 id="bean对象从创建到销毁的整体过程"><a href="#bean对象从创建到销毁的整体过程" class="headerlink" title="bean对象从创建到销毁的整体过程"></a>bean对象从创建到销毁的整体过程</h4><ul><li><p>初始化容器</p><ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)</li><li>4.执行bean初始化方法</li></ul></li><li><p>使用bean</p><ul><li>执行业务操作</li></ul></li><li><p>关闭/销毁容器</p><ul><li>执行bean销毁方法</li></ul></li><li><p>代码实现</p><ul><li>1.init＆destory</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//添加两个接口`InitializingBean`， `DisposableBean`并实现接口中的两个方法`afterPropertiesSet`和`destroy`</span></span><br><span class="line"><span class="comment">//这样就不用在配置文件里面配置`init-method`和`destroy-method`</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean {</span><br><span class="line">        <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> {</span><br><span class="line">           <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"book service save ..."</span>);</span><br><span class="line">           bookDao.save(); </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">           System.out.println(<span class="string">"service destroy"</span>);</span><br><span class="line">         }</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">           System.out.println(<span class="string">"service init"</span>);</span><br><span class="line">         }</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure><ul><li>2.close  —执行destroy方法的内容</li></ul>  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//ApplicationContext中没有close方法，需要将ApplicationContext更换成ClassPathXmlApplicationContext</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line"><span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//运行程序，就能执行destroy方法的内容</span></span><br><span class="line">ctx.close();</span><br></pre></td></tr></tbody></table></figure><ul><li><p>3.注册钩子关闭容器    —  执行destroy方法的内容</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="DI-1"><a href="#DI-1" class="headerlink" title="DI"></a>DI</h2><h3 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h3><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><ul><li>简单类型<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><strong>引用类型</strong><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><ul><li>简单类型<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">index</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li>引用类型<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">index</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><ul><li>不用写配置文件了</li><li>类型</li></ul><h4 id="按类型（常用）"><a href="#按类型（常用）" class="headerlink" title="按类型（常用）"></a><strong>按类型（常用）</strong></h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="按名称-—-有多个相同类型的对象"><a href="#按名称-—-有多个相同类型的对象" class="headerlink" title="按名称   —   有多个相同类型的对象"></a>按名称   —   有多个相同类型的对象</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="按构造方法"><a href="#按构造方法" class="headerlink" title="按构造方法"></a>按构造方法</h4><h3 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h3><h4 id="数组类型数据"><a href="#数组类型数据" class="headerlink" title="数组类型数据"></a>数组类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"array"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="注入List类型数据"><a href="#注入List类型数据" class="headerlink" title="注入List类型数据"></a>注入List类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>chuanzhihui<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="注入Set类型数据"><a href="#注入Set类型数据" class="headerlink" title="注入Set类型数据"></a>注入Set类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="注入Map类型数据"><a href="#注入Map类型数据" class="headerlink" title="注入Map类型数据"></a>注入Map类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"country"</span> <span class="attr">value</span>=<span class="string">"china"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"henan"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"kaifeng"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="注入Properties类型数据"><a href="#注入Properties类型数据" class="headerlink" title="注入Properties类型数据"></a>注入Properties类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"country"</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"province"</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"city"</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/04/hello-world/"/>
      <url>/2023/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
