<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Feed 流系统的架构设计方案</title>
      <link href="/posts/feed/"/>
      <url>/posts/feed/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Feed-流系统的架构设计方案"><a href="#Feed-流系统的架构设计方案" class="headerlink" title="Feed 流系统的架构设计方案"></a>Feed 流系统的架构设计方案</h1><h2 id="Feed流概述"><a href="#Feed流概述" class="headerlink" title="Feed流概述"></a><strong>Feed流概述</strong></h2><h3 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a><strong>定义与特点</strong></h3><p>Feed流是持续更新展示给用户的信息流（某种意义上来说，你可以一直向下滑动，而后获取到信息的应用都属于feed流），具有千人千面的个性化特点，如手机App中的猜你喜欢、关注和好友动态等。</p><p>与传统信息获取渠道（报纸电视）相比，Feed流可根据用户行为聚合信息（最核心的能力），以信息流方式提供给用户，降低获取信息难度，提升用户体验。</p><h3 id="分类方式"><a href="#分类方式" class="headerlink" title="分类方式"></a><strong>分类方式</strong></h3><ul><li><strong>按信息源聚合依据</strong>：<ul><li>无需依赖关系（如抖音推荐页，适用于信息探测）</li><li>单向依赖关系（如微博关注页，适用于信息订阅）</li><li>双向依赖关系（如微信朋友圈，适用于熟人社交）</li></ul></li><li><strong>按展示逻辑</strong>：<ul><li>权重推荐（如抖音推荐页）</li><li>时间顺序展示（如微信朋友圈、微博关注页）</li></ul></li><li>本质上可总结为依据隐含兴趣推荐信息按权重排序展示和依据用户关系拉取信息按时间顺序展示两类Feed流。<ul><li><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/-173444568952321.png" alt="img"></li></ul></li></ul><blockquote><p>注意：微博热榜很多人也算成了 Feed 流，但是严格意义上来说，他是一个信息流。所有人看到的热榜数据都是一样的，这缺失了信息聚合的特征。所以，本质上热榜的底层模型应该是排行榜，而非 Feed 流。这里不将它归为一类。</p></blockquote><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a><strong>发展历程</strong></h3><p>起源于RSS系统。RSS是一种更为传统的信息获取方式，它依赖于网站的更新；而Feed则更加现代和个性化，它依赖于用户关注的人或者团体的活动。</p><h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a><strong>术语解释</strong></h3><table><thead><tr><th>名称</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>Feed</td><td>Feed 流中的每一条状态或消息为 Feed，比朋友圈中的一个状态、微博中的一条微博</td><td></td></tr><tr><td>Feed 流</td><td>Feed流本质上是数据流，核心逻辑是服务端系统将 “多个发布者的信息内容” 通过 “关注收藏屏蔽等关系” 推送给 “多个接收者”。常见的，比如微博上的超话，新版本的微信公众号订阅消息，抖音里的视频流等等</td><td>三大特点：少部分人发布；基于订阅行为关联关系；大多数人读取信息</td></tr><tr><td>Timeline</td><td>Timeline是一种Feed流，微博，朋友圈都是Timeline类型的Feed流</td><td>又叫时间轴</td></tr><tr><td>关注页Timeline</td><td>展示其他人Feed消息的页面，比如朋友圈，微博的首页等。</td><td>又叫做收件箱，每个用户能看到的消息都会被存储到收件箱中</td></tr><tr><td>个人页Timeline</td><td>展示自己发送过的Feed消息的页面，比如微信中的相册，微博的个人页等</td><td>又叫做发件箱，自己发布的消息都会被记录到自己的发件箱中。别人的收件箱内的消息，也是从他的各个关注人的发件箱内同步过来的。</td></tr><tr><td>写扩散</td><td>一种消息同步方式，用户发布消息后，消息被记录到用户的发件箱中，此时立刻将发件箱内的消息同步给所有用户的收件箱。</td><td>又叫做推模式</td></tr><tr><td>读扩散</td><td>一种消息同步方式，用户发布消息后，消息被记录到用户的发件箱中。而消息的接收方此时没有收到消息。接收方按需（查看收件箱）拉取消息（所有关注人发件箱的消息），完成消息同步。</td><td>又叫做拉模式</td></tr></tbody></table><h2 id="Feed流模型架构"><a href="#Feed流模型架构" class="headerlink" title="Feed流模型架构"></a><strong>Feed流模型架构</strong></h2><h3 id="依赖用户关系的时间顺序Feed流"><a href="#依赖用户关系的时间顺序Feed流" class="headerlink" title="依赖用户关系的时间顺序Feed流"></a><strong>依赖用户关系的时间顺序Feed流</strong></h3><h4 id="面临挑战："><a href="#面临挑战：" class="headerlink" title="面临挑战："></a><strong>面临挑战</strong>：</h4><ul><li><strong>性能要求高：</strong>需满足实时性，消息实时产生、消费和推送；</li><li><strong>存储要求大：</strong>消息来源多且海量；</li><li><strong>读写失衡模型</strong>：读写比大，性能考虑时间排序；</li><li><strong>原子性：</strong>要求用户感知消息，保证最终一致性。</li></ul><h4 id="基本功能："><a href="#基本功能：" class="headerlink" title="基本功能："></a><strong>基本功能</strong>：</h4><ul><li>用户发布：用户可以发布一条消息，他的订阅者都能感知到他发布了消息</li><li>用户删除：</li><li>查看消息：查看自己发布的所有消息</li><li>订阅/取消订阅消息源：注意有的场景中要求用户 Feed 流中能看到博主在被关注之前发的消息，这就要求订阅的时候，还要主动同步一份博主的所有消息到用户的 Feed 流中。</li><li>查看Feed流</li><li>额外：支持黑白名单和评论功能等。</li></ul><h4 id="问题与解决方案"><a href="#问题与解决方案" class="headerlink" title="问题与解决方案"></a><strong>问题与解决方案</strong></h4><h5 id="发布者与订阅者消息读取"><a href="#发布者与订阅者消息读取" class="headerlink" title="发布者与订阅者消息读取"></a><strong>发布者与订阅者消息读取</strong></h5><p>一般采用写扩散：发布者发布消息后，将自己的消息同步给粉丝的收件箱。</p><p>大v用户采用读写结合</p><p>热粉丝写扩散，冷粉丝读扩散</p><p>冷热分离方案：根据登录次数、时长或session池判断在线情况</p><h5 id="Feed流翻页"><a href="#Feed流翻页" class="headerlink" title="Feed流翻页"></a><strong>Feed流翻页</strong></h5><p>首先不能采取传统的 page_size 和 page_num，因为它是一个动态列表，每时每刻都有可能更新，如果两页之间出现内容的添加或删除，都会导致错位问题。</p><p>使用last_id记录上一页最后一条内容的id，避免传统分页方式在内容更新时的错位问题。</p><p>写扩散下last_id直接往后读取</p><p>读扩散下需记录拉取的write_last_id（多少个关注就记录多少个write_last_id），翻页时根据write_last_id往后拉取新的一定量（比如 page_size 个）的数据，再用这些数据组成新的收件箱列表，筛选page_size返回前端，同时更新write_last_id。</p><blockquote><p>由此可见：读扩散的翻页比写扩散复杂很多-。-</p></blockquote><h5 id="写扩散模式下删除修改问题"><a href="#写扩散模式下删除修改问题" class="headerlink" title="写扩散模式下删除修改问题"></a><strong>写扩散模式下删除修改问题</strong></h5><p>采用软删除（置为删除状态，查询时过滤）和懒删除（过滤时从收件箱真正删除）机制，通过读扩散回查方案，只写消息id到收件箱，查询时再丰富信息（比直接把内容一起写入收件箱内会更加节约内存，减少冗余数据，同时消息删除无需扩散）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//mermaid语言</span><br><span class="line">graph TD;</span><br><span class="line">    A[用户发布消息] --&gt; B{是否为大V用户};</span><br><span class="line">    B -- 是 --&gt; C[消息写扩散到活跃用户收件箱，仅写消息id];</span><br><span class="line">    B -- 否 --&gt; D[消息写扩散到所有粉丝收件箱，仅写消息id];</span><br><span class="line">    E[用户查看收件箱] --&gt; F[根据消息id回查消息内容];</span><br><span class="line">    F --&gt; G[判断消息状态是否为删除];</span><br><span class="line">    G -- 是 --&gt; H[过滤掉已删除消息，懒删除从收件箱中删除该消息id];</span><br><span class="line">    G -- 否 --&gt; I[返回消息内容给用户];</span><br><span class="line">    J[发布者删除消息] --&gt; K[将消息置为删除状态，软删除deleteflag];</span><br></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/-17344454969514.png" alt="img"></p><h5 id="用户收件箱刷新时机"><a href="#用户收件箱刷新时机" class="headerlink" title="用户收件箱刷新时机"></a><strong>用户收件箱刷新时机</strong></h5><p>关注他人时采用写扩散+刷新（也就是获取到关注用户的发件箱内所有消息，然后刷新自己的收件箱）</p><p>取消关注、关注人删除或修改消息时采用读扩散+懒删除方式，通过回查过滤完成同步。</p><p>不同的业务场景会遇到不同的侧重点，上述方案仅仅是一个参考。</p><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a><strong>总体设计</strong></h2><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a><strong>架构设计</strong></h3><p>系统包括消息发送逻辑、用户操作触发、对外CGI模块、消息队列等</p><p>通过抽象数据结构（消息、消息发布处理器、用户、发布配置）</p><p>设计良好的数据库表（消息表、收件箱、发布配置表、关注关系表）来满足性能要求</p><p>核心难点是发布和拉取Feed流功能。</p><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/-17344454969515.png" alt="img"></p><h3 id="存储和缓存设计"><a href="#存储和缓存设计" class="headerlink" title="存储和缓存设计"></a><strong>存储和缓存设计</strong></h3><ul><li><strong>消息表</strong>：存储消息相关信息，如id、标题、内容、类型、状态、渠道、发布者、时间等，部分字段用于扩展。</li></ul><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/-17344454969516.png" alt="img"></p><ul><li><strong>收件箱</strong>：采用redis的zset存储，key为接收者uid + channelid，value为发件人uid + 消息id，score为发布时间戳，可实现自动排序。</li><li><strong>发布配置表</strong>：用于扩展为消息推送系统，包含发布id、类型、规则、渠道等信息。</li></ul><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/-17344454969517.png" alt="img"></p><ul><li><strong>关注关系表</strong>：记录博主与粉丝关系，包括uid、状态、热粉丝标记等，用于粉丝冷热分离查询优化。</li></ul><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/img/202412172238439.png" alt="img"></p><h3 id="核心业务流程"><a href="#核心业务流程" class="headerlink" title="核心业务流程"></a><strong>核心业务流程</strong></h3><ul><li><p><strong>发布Feed流程</strong>：</p><ul><li>消息进入队列</li><li>读取粉丝列表，判断自己是否为大v</li><li>把feed写入个人页Timeline（发件箱）</li><li>大V拉取活跃用户、普通用户拉取所有粉丝，同步Feed ID给粉丝。</li></ul></li><li><p><strong>读取Feed流流程</strong>：</p></li></ul><ol><li>判断自己是否为活跃用户，不是的话才去读扩散，读取自己关注的大v列表</li><li>读取收件箱（起始位置为上次最新Feed ID）并反查剔除软删除数据，</li><li>非活跃用户，并发读取关注的大V列表的发件箱</li><li>合并结果排序后返回给用户。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    subgraph 发布Feed流程</span><br><span class="line">        A[用户发布Feed消息] --&gt; B[消息进入队列服务]</span><br><span class="line">        B --&gt; C[读取关注列表获取粉丝列表并判断是否为大V]</span><br><span class="line">        C --&gt; D[将Feed消息写入个人页Timeline发件箱]</span><br><span class="line">        D --&gt; E{是否为大V}</span><br><span class="line">        E -- 是 --&gt; F[拉取活跃用户]</span><br><span class="line">        E -- 否 --&gt; G[拉取所有粉丝用户]</span><br><span class="line">        F --&gt; H[将Feed消息同步给活跃用户，仅写Feed ID到收件箱]</span><br><span class="line">        G --&gt; I[将Feed消息同步给所有粉丝，仅写Feed ID到收件箱]</span><br><span class="line">    end</span><br><span class="line">    subgraph 读取Feed流流程</span><br><span class="line">        J[用户刷新Feed流] --&gt; K{是否为活跃用户}</span><br><span class="line">        K -- 是 --&gt; L[读取自己的收件箱，起始位置为上次最新Feed ID]</span><br><span class="line">        K -- 否 --&gt; M[读取关注的大V列表]</span><br><span class="line">        M --&gt; N[并发读取每个大V的发件箱]</span><br><span class="line">        L --&gt; O[通过Feed ID反查Feed内容并剔除软删除数据]</span><br><span class="line">        N --&gt; P[通过Feed ID反查Feed内容]</span><br><span class="line">        P --&gt; Q[合并大V发件箱数据和自己收件箱数据]</span><br><span class="line">        Q --&gt; R[按时间顺序排序数据]</span><br><span class="line">        R --&gt; S[返回排序后的数据给用户]</span><br><span class="line">        O --&gt; S</span><br><span class="line">    end</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/img/202412182353453.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/img/202412182353281.png" alt="img"></p><p>至此，使用推拉结合，冷热分离方式的 Feed 流发布，读取 Feed 流的流程都结束了。</p>]]></content>
      
      
      <categories>
          
          <category> 场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景 </tag>
            
            <tag> Feed </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二份工作</title>
      <link href="/posts/defgz/"/>
      <url>/posts/defgz/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>熬了三个两点多晚上前几天看完<br>形式是非常喜欢的小故事类型<br>主人公的性格也很喜欢很有代入感<br>但很多点并没有很深的体会<br>可能是因为岗位差别对书中关于mkt的各种东西都看得有点懵<br>也有可能上班经验还是没那么丰富🤔</p>]]></content>
      
      
      <categories>
          
          <category> 怎么认识这个世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024秋小总结</title>
      <link href="/posts/2024qksxzj/"/>
      <url>/posts/2024qksxzj/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好久好久没记录了<br>太久远的也不记得了就记一下近三个月的</p><p>最近看的书<br>午后四点：前天睡不着两点半看完的<br>远山淡影：飞成都的飞机上看完的<br>我在上东区做家教：昨晚开始看的<br>仿生人会梦见电子羊吗：maybe一个月前<br>一个陌生女人的来信：一个月前<br>金色梦乡：两个月前<br>麦琪的礼物：两个月前<br>九篇雪：三个月前<br>再袭面包店：三个月前</p><p>播客的话还在探索阶段<br>认知类的有点听腻了<br>更想听点探索世界or不同的生活方式<br>所以最近听得很杂<br>讲飞机的，讲咸鱼的，讲韩国女作家的</p><p>电影的话<br>暮然回首：周二<br>白日梦想家：九月份看的吧<br>因果报应：这个应该是六月份看的了</p><p>总结就是书看的还行，但是缺少记录<br>播客以后每天骑车听<br>电影看的太少了，争取以后每周一部<br>上完班回来看看别的东西吧<br>世界上这么多值得探索的东西</p>]]></content>
      
      
      <categories>
          
          <category> 怎么认识这个世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机票是手段，世界是目的</title>
      <link href="/posts/jpssdsjsmd/"/>
      <url>/posts/jpssdsjsmd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>年度最爱博客！</p><p>也可能和听这场播客的心境有关系，等我有时间了就写感想！</p>]]></content>
      
      
      <categories>
          
          <category> 怎么认识这个世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排查日志：从http1.1升级到http2</title>
      <link href="/posts/http2/"/>
      <url>/posts/http2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排查日志：http1-1-升级到-http2"><a href="#排查日志：http1-1-升级到-http2" class="headerlink" title="排查日志：http1.1 升级到 http2"></a>排查日志：http1.1 升级到 http2</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>实习需求：把原有的系统从http1.1升级到http2</p><p>一开始觉得非常简单，思路大概就是：前端改配置升级、后端改配置升级、适配代理层nginx。</p><p>项目前后端配置：</p><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/image-20241022121711494.png" alt="image-20241022121711494"></p><p>nginx配置：</p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/image-20241022121853314.png" alt="image-20241022121853314" style="zoom:50%;"><p>❗但是发送的请求在网页控制台发现还是http1.1🤔</p><h2 id="逐步排查"><a href="#逐步排查" class="headerlink" title="逐步排查"></a>逐步排查</h2><h3 id="1-排查后端"><a href="#1-排查后端" class="headerlink" title="1. 排查后端"></a>1. 排查后端</h3><p>写了个方法专门判断http版本</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试请求是否为 http2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/apiTest")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpVersionController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/http-version")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHttpVersion</span><span class="params">(HttpServletRequest request)</span> {</span><br><span class="line">        System.out.println(request.getHeader(<span class="string">"User-Agent"</span>));</span><br><span class="line">        System.out.println(request.getRequestURL());</span><br><span class="line">        <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> request.getProtocol();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"HTTP/1.1"</span>.equals(protocol)) {</span><br><span class="line">            System.out.println(<span class="string">" HTTP/1.1"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"This is an HTTP/1.1 request."</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"HTTP/2.0"</span>.equals(protocol)) {</span><br><span class="line">            System.out.println(<span class="string">" HTTP/2"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"This is an HTTP/2 request."</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Unknown HTTP version: "</span> + protocol;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>直接访问后端接口返回的是http2，说明后端已经成功升级，不是后端的问题</p><p><img src="E:/Download/PicGo/picture/image-20241022142941523.png" alt="image-20241022142941523"></p><p>但是前端访问此接口返回的还是http1.1</p><p><img src="E:/Download/PicGo/picture/image-20241022143627983.png" alt="image-20241022143627983"></p></blockquote><h3 id="2-排查nginx"><a href="#2-排查nginx" class="headerlink" title="2. 排查nginx"></a>2. 排查nginx</h3><p>在这个地方卡了很久，又是升级nginx又是make又是重新配置openssl又是配置tls，后面查看nginx的access.log发现这个系统根本没走nginx（流泪le家人们，这就是半路接手系统的弊端😭</p><h3 id="3-排查前端"><a href="#3-排查前端" class="headerlink" title="3. 排查前端"></a>3. 排查前端</h3><p>那现在问题已经非常呼之欲出了！！就是前端的问题！！！🤯</p><p>使用<code>echo | openssl s_client -alpn h2 -connect localhost:3100 | grep ALPN</code>模拟向前端项目地址发送SSL握手，发现这个端口不支持<code>ALPN</code>，发送的请求有http2和http1.1，但最后选择了http1.1</p><p><img src="E:/Download/PicGo/picture/image-20241022144724722.png" alt="image-20241022144724722"></p><p>看起来解决办法就是让端口支持ALPN就可以了，也就是配置vite，但是我早在第一步就配置好了，在这里思考了非常久</p><p>之后搜索vite官网才发现上面写着：“启用 TLS + HTTP/2。注意：当 server.proxy 选项 也被使用时，将会仅使用 TLS。”</p><p><img src="E:/Download/PicGo/picture/image-20241022141600185.png" alt="image-20241022141600185"></p><p>自己测试了一下，确实是https属性和proxy属性只会有一个生效，而且优先生效proxy属性</p><p>如果注释proxy属性，开启https属性，发现端口就支持ALPN协议，且走的是http2；但是因为proxy失效，后端请求报错，如下图：</p><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/img/202412281658722.png" alt="image-20241022143316300"></p><blockquote><p>所以最终原因就是使用的vite不支持server同时配置HTTP2和proxy，相关讨论：<a href="https://github.com/vitejs/vite/issues/4184">Support HTTP2 and Proxy at the same time? · Issue #4184 · vitejs/vite (github.com)</a></p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>使用相关插件支持http2和proxy，如<a href="https://github.com/williamyorkl/vite-plugin-proxy-middleware">williamyorkl/vite-plugin-proxy-middleware: a vite plugin that solve the conflict problem between turning on vite proxy and http2, you can use both http2 and proxy at the same time ;-) (github.com)</a></li><li>使用自定义的http2服务器</li></ol><p>参考代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> http2 = <span class="built_in">require</span>(<span class="string">'http2'</span>)</span><br><span class="line"><span class="keyword">const</span> handler = <span class="built_in">require</span>(<span class="string">'vite'</span>).<span class="title function_">createServer</span>({</span><br><span class="line">  <span class="comment">// Vite server options</span></span><br><span class="line">  <span class="attr">server</span>: {</span><br><span class="line">    <span class="attr">middlewareMode</span>: <span class="string">'html'</span>,</span><br><span class="line">  },</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http2.<span class="title function_">createSecureServer</span>({</span><br><span class="line">  <span class="attr">cert</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">'cert.pem'</span>),</span><br><span class="line">  <span class="attr">key</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">'key.pem'</span>),</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">'stream'</span>, <span class="function">(<span class="params">stream, headers</span>) =&gt;</span> {</span><br><span class="line">  handler.<span class="title function_">middlewares</span>(stream, headers)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3100</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'HTTP/2 server running on https://localhost:3100'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ol><li>感觉自己排查的思路还是有点慢，应该快一点反应过来不是后端的问题、不是nginx的问题，从而推出是前端的问题</li><li>这种问题不要老是想着问gpt，多去github上搜搜issus反而更合适，有时候经验比机器管用</li><li>每次都很容易被前端的bug困很久，找个时间去学学前端的进阶框架，起码得知道vite、webpack的用法等等</li></ol><p>纪念我的2024.10.21，在图书馆改了一天这个东西🥺🥺🥺</p><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/img/202412281658884.png" alt="image-20241022144250448"></p>]]></content>
      
      
      <categories>
          
          <category> Error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 实习 </tag>
            
            <tag> http </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[1010]字符串刷题思路</title>
      <link href="/posts/string/"/>
      <url>/posts/string/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><blockquote><p>本篇博客只记录刷题思路不记录具体代码，用于本人快速回顾<br>题目来源代码随想录<br>奖励自己上半天班😋</p></blockquote><blockquote><ol><li>注意Java的String是不可变的，所以很多时候要toChar()</li><li>涉及到交换的操作都很适合双指针</li><li>数组填充优化解决思路：先确定长度再从后往前遍历</li><li>KMP 算法</li></ol></blockquote><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>一眼双指针</p><p>非常朴素无华，秒了</p><p>值得注意的是swap不用temp的高效写法，三次异或</p><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">s[l] ^= s[r];  //构造a^b的结果，并放在a中</span><br><span class="line">s[r] ^= s[l];  //a^b的结果再^ b，存入b，此时b=a,a=a^b</span><br><span class="line">s[l] ^= s[r];  //a ^ b的结果再^a，存入a，此时b=a,a=b完成交换</span><br></pre></td></tr></tbody></table></figure><h2 id="反转字符串Ⅱ"><a href="#反转字符串Ⅱ" class="headerlink" title="反转字符串Ⅱ"></a>反转字符串Ⅱ</h2><p>在上一道题的基础上多加一个判断即可</p><p>注意最后需要判断尾数够不够k个，来确定end指针的位置，所以我们需要取min：<code>int end = Math.min(ch.length - 1, start + k - 1);</code></p><p>也可以直接用<code>i+k&lt;=s.length()</code>判断</p><h2 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h2><p>思路非常简单，遍历到数字就append”number”（❌）</p><p>nono，给的是String类型，String类型是不可变的</p><p>所以可以先转成char[]，但是需要先for遍历string确定数字数量再确定char长度，再for填充数组，又要注意是从后往前填充，从前往后的话需要整体向后移动数组后面部分，很麻烦</p><p>==》这也是常见的数组填充解决思路，双指针思路</p><h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><p>字符串匹配算法，KMP登场！</p><blockquote><p>又称学一次忘一次算法，在B站上搜教程发现热门前几的视频都收藏过😶</p><p><a href="https://www.cnblogs.com/Higurashi-kagome/p/18013626">https://www.cnblogs.com/Higurashi-kagome/p/18013626</a></p></blockquote><p>原始肯定是最容易想到暴力，运气不好的话得匹配到最后一个</p><p>KMP就是为了优化这一步：<strong>已经知道之前遍历过的字符，那能不能利用这些信息来避免暴力算法中回退的步骤呢</strong></p><p>这里就需要一个next数据，记录我们可以回退的数量</p><p><img src="E:/Download/PicGo/picture/-17285647299261.png" alt="img"></p><p>next数组/前缀表求解思路：<strong>寻找子串中相同前后缀的长度，并且一定是最长的前后缀</strong></p><p>可以暴力</p><p>也可以递推优化</p><ol><li>while遍历s，定义当前共同前后缀长度len【why not for，因为i不一定++】</li><li>如果s[i] == s [len]，next[i]= ++len，i++</li><li>如果不相等<ol><li>len ==0 ，直接 next[i] = 0，i++</li><li>len != 0，更新 len = next[len - 1];<ol><li>感觉这一步挺难理解的，因为现在为len的字符串是不匹配的，我们就通过next[len-1]找更短的前缀匹配</li><li>比如说ABABA，i=4时len=2，s[i]!=s[len]且len!=0，那我们就更新len为next[len-1]的值</li></ol></li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] buildNext(String patt) {</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[patt.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 初值设为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefixLen</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前共同前后缀的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; patt.length()) {</span><br><span class="line">            <span class="keyword">if</span> (patt.charAt(i) == patt.charAt(prefixLen)) {</span><br><span class="line">                <span class="comment">// 下一个字符依然相同，长度加 1</span></span><br><span class="line">                prefixLen++;</span><br><span class="line">                next[i] = prefixLen;</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 下一个字符不同</span></span><br><span class="line">                <span class="keyword">if</span> (prefixLen == <span class="number">0</span>) {</span><br><span class="line">                    next[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 查表看看其中存不存在更短的前后缀</span></span><br><span class="line">                    prefixLen = next[prefixLen - <span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>有了next数组后：</p><ol><li>双指针：主串指针i和子串指针j</li><li>遍历主串，判断是否和子串对应位置字符匹配</li><li>匹配的话直接++</li><li>不匹配的话根据next跳过子串位置</li><li>while后的 j==子串.length，说明匹配成功</li></ol><h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p>不要想复杂了这就是一道easy而已呀，直接枚举</p><ol><li>for遍历s，i*2&lt;n剪枝</li><li>If n%i==0，说明现在有可能成倍匹配，没匹配到就break</li><li>匹配到用boolea信号量return true</li></ol><p>还有一种很巧妙的方法是直接复制成ss，然后判断ss(1,length-1)是否包含s，两行完成但是时间和空间效率不高</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s + s;</span><br><span class="line"><span class="keyword">return</span> str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).contains(s);</span><br></pre></td></tr></tbody></table></figure><p>要是想复杂点（但完美的复杂度）也可以KMP</p><p>重复也就是查找</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[1009]hash刷题思路</title>
      <link href="/posts/hash/"/>
      <url>/posts/hash/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><blockquote><p>本篇博客只记录刷题思路不记录具体代码，用于本人快速回顾<br>题目来源代码随想录<br>今天还在喝中药🤒</p></blockquote><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p>服了每次都想不到用数组</p><p>虽然还是要两次for罢了，但起码复杂度还是O(n)</p><p>优化剪枝：</p><ol><li>先判断长度是否相同</li><li>我靠好妙，官方解答是第一次for数组确定value，第二次for数组 if数组==0；还有一种解法是第一次for1确定数组value，第二次for减去s2的数组再if ==0，这就就可以只遍历length* 2而不是26* 2【但如果是长字符的话效率不高】但实际运行并没有快很多🤔</li><li>还有一种方法：toCharArray后sort再equals，但感觉有点过于依赖API了</li></ol><p>看题解下的评论也真好！！！</p><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p>这个主要是观察题干发现：1. 要求不重复   2. 数字范围没有限制</p><p>所以就用set解决</p><p>还有一个难点是set转数组了</p><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><blockquote><p>额老师我是真的没想到居然使用hash存结果啊</p></blockquote><p>没什么思路</p><p>首先 求和不难想到，但是没想到while的跳出条件</p><p>条件就是当前和是之前存在的，这样的话就会一直循环</p><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>梦开始的地方</p><ol><li>快速查找是否存在——用哈希表</li><li>涉及到对应关系——用map，key存当前数，value存当前数位置【因为最后要返回的是这个】，相关方法<code>containsKey(key)</code>、<code>put(key，value)</code></li></ol><h2 id="四数相加Ⅱ"><a href="#四数相加Ⅱ" class="headerlink" title="四数相加Ⅱ"></a>四数相加Ⅱ</h2><p>和四数之和最大的区别就是不用考虑去重，只用算次数（真的简便很多！</p><p>面对多元素我们的思路是抽丝剥茧</p><p>先两层for计算两个数组的元素之和放进map，key存sum，value存次数</p><p>再两层for统计剩余两个元素之和，在map中查找是否存在</p><p>相关方法：<code>getOrDefault(value,defaultvalue)</code></p><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p>和《有效的字母异位词》几乎一样，就是题目有点新奇</p><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>相当于target = 0，但是哈希表做这道题很多东西要处理</p><p>不如双指针，先确定一个数，另外两个指针找两数之和</p><p>直接上思路（因为没想完善）</p><ol><li>因为去重，所以肯定得先排序，排序是去重的基础</li><li>for遍历第一个数</li><li>左右指针开始遍历，while指针没有相遇，求和</li><li>如果==target，就加进list，❗同时要while更新左右指针去重❗</li></ol><h2 id="四树之和"><a href="#四树之和" class="headerlink" title="四树之和"></a>四树之和</h2><p>和三数之和的思路很像</p><p>必须两层for  +左右指针</p><p>注意判断第一个组合和最后一个组合是否&gt;target，用来剪枝</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[1008]链表刷题思路</title>
      <link href="/posts/link/"/>
      <url>/posts/link/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote><p>本篇博客只记录刷题思路不记录具体代码<br>题目来源代码随想录<br>刷完感想：奖励今天喝中药调理脑子🙂</p></blockquote><p>:::tip 和链表题相关的提示</p><ol><li>虚拟头节点</li><li>双指针</li><li>一般涉及三个节点：pre、cur，next<br>:::</li></ol><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>包含data和next下一节点指针</p><p>新增：cur.next = new;new.next = next;【这里就涉及到一个保存操作】</p><p>删除：cur.next = cur.next.next</p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><ol><li>注意对头节点进行特判【因为是站在当前节点，判断下一节点是否值相等，相等的话把当前节点的next为下下节点】</li><li>不要用for，不知道具体长度，用while</li><li>不能直接对head操作，而是新建一个链表节点</li></ol><h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p>感觉没什么好说的，记得用虚拟头节点</p><p>show code</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(){}</span><br><span class="line">    ListNode(<span class="type">int</span> val) {</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> {</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> {</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) {</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) {</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) {</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">//因为有虚拟头节点，所以不用对Index=0的情况进行特殊处理</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) {</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        }</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p>还是【因为是站在当前节点，判断下一节点是否值相等，相等的话把当前节点的next为下下节点】的思路</p><p>所以必须要有三个参数：pre、cur，next</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 更新节点next</span></span><br><span class="line">next = cur.next</span><br><span class="line">cur.next = pre</span><br><span class="line"><span class="comment">// 更新节点</span></span><br><span class="line">cur = next</span><br><span class="line">pre = cur</span><br></pre></td></tr></tbody></table></figure><h2 id="两两交换链表"><a href="#两两交换链表" class="headerlink" title="两两交换链表"></a>两两交换链表</h2><p>表面涉及两个节点，实际上涉及到了四个节点(考虑next ，所以也加上虚拟头节点)</p><p>所以就按照模拟逻辑一个个交换就好了</p><p>但是要注意保存节点（1，3），因为在更改cur节点next为2的同时，1是被独立了，得temp保存一下</p><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/-17284811961171.png" alt="img"></p><h2 id="删除倒数第k个节点"><a href="#删除倒数第k个节点" class="headerlink" title="删除倒数第k个节点"></a>删除倒数第k个节点</h2><p>双指针中的快慢指针思路，还没忘记，真不错</p><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><p>为啥这道题就忘记了要用双指针、、、</p><p>这种涉及到两个位置差的就很适合快慢指针</p><h2 id="环形链表Ⅱ"><a href="#环形链表Ⅱ" class="headerlink" title="环形链表Ⅱ"></a>环形链表Ⅱ</h2><p>还得是数学证明啊</p><ol><li>fast每次比slow多移动一个节点，如果在途中相遇证明链表有环</li><li>从头结点和相遇节点分别出发一个指针，每次只走一个节点， 相遇节点就是环形入口的节点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[1007]数组刷题思路</title>
      <link href="/posts/array/"/>
      <url>/posts/array/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote><p>本篇博客只记录刷题思路不记录具体代码<br>题目来源代码随想录<br>刷完感想：今天去吃烤肉拌饭🤤</p></blockquote><p>:::tip  和数组题相关的提示</p><ol><li>数组是存放在连续内存空间上的相同类型数据的集合。</li><li>可以靠索引快速定位</li><li>双指针<br>:::</li></ol><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>典型，但是思路好像还是没跟上</p><p>注意区间的左闭右开会影响很多东西</p><p>没事之前已经把能踩的坑都踩过一遍了（<a href="https://www.yuque.com/kixuan/yy8qei/lpansi5g3iogf6tr">https://www.yuque.com/kixuan/yy8qei/lpansi5g3iogf6tr</a></p><p>这里重新贴一下用于警醒自己😰</p><p>哈哈服了写个二分查找写出了一堆问题，来看你写的破代码！🥰🥰<br>原代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) left = mid;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) right = mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>‼️问题分析‼️<br>最重要的确定你的区间是 [ , ] 还是 [ , )，这会影响 mid、left、right 的更改</p><ol><li>初始 mid 计算错误： mid 不正确，应在每次循环内计算 mid。<br>int mid = left + (right - left) / 2;</li><li>循环条件错误：在进行二分查找时，应该使用 &lt;=<br>这里是因为你设置的区间是 [left,right]，=的时候有意义，所以是&lt;=<br>while (left &lt;= right) {</li><li>mid 更新逻辑错误： 更新 left 和 right 时，不应将 mid 直接赋值给 left 或 right，应调整为 mid + 1 或 mid - 1，否则可能会导致死循环<br>if (nums[mid] &lt; target) left = mid + 1;<br>if (nums[mid] &gt; target) right = mid - 1;</li><li>返回值错误： 在循环结束后，mid 可能不代表目标插入位置，应返回 left，因为 left 是当前查找区间的起始位置。</li></ol><p>修正代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>发表重大感想：<br>把能踩的坑全踩了一遍！！牛！！！🥳🥳🥳🥳</p><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>经典同向双指针，直接在原数组上更新就行</p><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p>还是双指针，但是注意这次得新开一个数组</p><p>还得根据给出数组的特征改成异向双指针</p><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p>模拟，思路不难但是也要注意左闭右开，看你自己最近一次提交更容易理解</p><h2 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h2><p>前缀和思路没想到，用的确实不多</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[1006]贪心刷题思路</title>
      <link href="/posts/tanxin/"/>
      <url>/posts/tanxin/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><blockquote><p>本篇博客只记录刷题思路不记录具体代码，用于本人快速回顾<br>题目来源代码随想录<br>刷完感想：连刷三个小时头都要晕了，去吃牛肉饭了🤤</p></blockquote><p>:::tip  和贪心题相关的提示<br>局部最优得到全局最优<br>:::</p><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p>非常标准的贪心</p><p>先满足胃口小的，注意这种情况是for饼干if胃口，因为无论是否满足，饼干一定会后移动，胃口不一定会后移（和先满足胃口的思路不一样，这种是胃口一定会前移，饼干不一定前移）</p><p>第二tips就是用if优化for循环，做一个自减</p><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>笑死感觉不算贪心算模拟，思路上有难度</p><p>比较[当前差值]和[上一个差值]</p><p>相同不算，不同算一个</p><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>贪心的点在于：碰到连续和为负数的情况就舍弃，不要影响后续的最大和</p><h2 id="买股票的最佳时间Ⅱ"><a href="#买股票的最佳时间Ⅱ" class="headerlink" title="买股票的最佳时间Ⅱ"></a>买股票的最佳时间Ⅱ</h2><p>非常简单：求差，正数就算上利益</p><p>（不用担心连续正数，这种情况也考虑到了）</p><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>思路：不能从后往前，因为除了要判断能否往后到达，还要考虑前面能不能到这里</p><p>==》考虑最远范围 + 能不能到达（从前考虑就比较容易，刚好是之前的最大值）</p><h2 id="跳跃游戏Ⅱ"><a href="#跳跃游戏Ⅱ" class="headerlink" title="跳跃游戏Ⅱ"></a>跳跃游戏Ⅱ</h2><p>比较有难度，难度在于找到更新maxReach的时机，是到了当前跳跃边界才更新cnt，而不是更新了maxReach就更新cnt</p><h2 id="k次取反求最大值"><a href="#k次取反求最大值" class="headerlink" title="k次取反求最大值"></a>k次取反求最大值</h2><p>思路easy，从小到大排序</p><p>一次贪心：先把最小的负数更新成正数</p><p>二次贪心：如果还有次数，偶直接抵消，奇就找到最小的正数为负</p><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>初步思路想到了根据gas和cost的差判断找起始点</p><p>但是以为找到最大值就行了</p><p>nono，应该用前缀和找到负数和的下一个</p><p>而且有个证明：有解就是唯一解</p><p>还需要判断一下sum&lt;0的话无解</p><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/-17284801978801.png" alt="img"></p><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>[老师怎么是hard，我是废物先溜了]</p><h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p>easy，更新5r、10r的张数能否满足就行</p><p>贪心的点在于20可以换3*5，也可以10+5，这个时候应该有限10+5</p><blockquote><p>but第一反应怎么是用数组存？肯定是int存啊，奇怪脑子</p></blockquote><h2 id="身高重建队列"><a href="#身高重建队列" class="headerlink" title="身高重建队列"></a>身高重建队列</h2><p>太妙了</p><p>初步思路想到了先根据身高排列，再根据人数调整位置</p><p>但是应该从大到小排（妙!!!!!），然后直接插入到对应的位置</p><p>而且注意用LinkedList的<code>add(index,value)</code>方法更快，后续再<code>toArray(new int[size][])</code></p><h2 id="最少数量箭引爆气球"><a href="#最少数量箭引爆气球" class="headerlink" title="最少数量箭引爆气球"></a>最少数量箭引爆气球</h2><p>服了没读懂题目</p><p>思路就是找排序 + 是否交集（前一个气球的末值和后一个气球的初值）</p><p>没有交集多加一支箭</p><p>有交集就更新后一个气球的末值为前后气球末值的最小值，不用加箭</p><h2 id="剩下的不想看了，累了"><a href="#剩下的不想看了，累了" class="headerlink" title="剩下的不想看了，累了"></a>剩下的不想看了，累了</h2><h2 id="TODO-划分字母区间"><a href="#TODO-划分字母区间" class="headerlink" title="TODO 划分字母区间"></a>TODO 划分字母区间</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Cannot get/</title>
      <link href="/posts/blog-err/"/>
      <url>/posts/blog-err/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我靠终于跑出来了😭</p><p>可恶可恶可恶改了快两天</p><p>极大严重影响了我这两个月写blog的心情！</p><p>mark一下排查思路!</p><p>首先线上点击网址显示404，其他页面访问正常</p><p>线下运行首页显示cannot get/</p><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/img/202412302350298.png" alt="Alt text"><br>排查了快半个小时定位到是hexo g没有生成index.html</p><p>非常奇怪</p><p>于是按照网上的方法npm audit fix检查</p><p>but有个审计的接口一直显示404</p><p>考虑到可能是换过淘宝镜像显示不全</p><p>于是换成原始镜像但又显示timeout</p><p>这里开始疯狂怀疑自己的网络试了好多次</p><p>都不行于是放弃，继续在网上搜刮issus</p><p>加了后缀–loglever=silly起码知道了它在fix什么东西</p><p>但还是timeout！无休止的timeout！</p><p>再把modules和packjson全删掉重装</p><p>这次fix出了两个high bug但是感觉没什么关系</p><p>npm ls –depth 0也完全没error</p><p>本来都想写个issus问问了</p><p>看到好久之前的一篇博客写他ls出来少装的是hexo-generator-index(<a href="https://blog.csdn.net/weixin_41290516/article/details/109595900">https://blog.csdn.net/weixin_41290516/article/details/109595900</a>)</p><p>开始觉得不对劲，我靠我不就是没有生成index</p><p>于是npm install这个插件</p><p>果然行了</p><p>虽然b站的那个插件有点小问题但比首页不能访问容易接受多了</p><p>好奇怪啊为什么ls显示没有error啊</p><p>就是在走歪的排查了这么久</p><p><img src="https://h5.sinaimg.cn/m/emoticon/icon/_/co_niuec-7d05bc992a.png" alt="[单身狗]"></p><p><img src="https://raw.githubusercontent.com/kixuan/PicGo/main/img/202412302346970.png" alt="image-20241230234558803"></p>]]></content>
      
      
      <categories>
          
          <category> Error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elastic Search 学习笔记</title>
      <link href="/posts/es/"/>
      <url>/posts/es/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Elastic-Search-学习笔记"><a href="#Elastic-Search-学习笔记" class="headerlink" title="Elastic Search 学习笔记"></a>Elastic Search 学习笔记</h1><p><img src="E:/Download/PicGo/picture/image-20240928120721956-17274964805611.png" alt="image-20240928120721956"></p><p>参考教程：<a href="https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/es/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/elasticSearch%E6%9E%B6%E6%9E%84%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/es/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/elasticSearch%E6%9E%B6%E6%9E%84%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>是一个开源的搜索引擎。</p><p>它介于应用和数据之间，只要将数据写入 es，应用就可以通过一些关键词搜索到数据。效果就像某度搜索一样。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>正排</strong>：依次遍历文本匹配是否含有关键词</p><p><strong>倒排</strong>：遍历关键词去搜索对应原始数据的id</p><p><strong>分词</strong>：对文本进行切分</p><p><strong>词项term</strong>：分词后的每部分。词项非常多，时间复杂度为O(N)，按字典序从小到大排序，二分查找O(lgN)</p><p>排好序的词项Term Dictionary：包括term（词项）和对应的文档id（其实还包括词频、偏移量等等）</p><img src="E:/Download/PicGo/picture/-17274937426166.png" alt="img" style="zoom:50%;"><p>数据量很大，放内存并不现实，因此必须放在磁盘中。但查询磁盘是个较慢的过程</p><p>==》提取词项相同的前缀，构成目录树term index</p><img src="E:/Download/PicGo/picture/-17274937426101.png" alt="img" style="zoom:50%;"><p>搜索出来的是文档id，获取文档内容本身==》Stored Fields（行式存储）存放文档id和对应的文档内容</p><p>根据某个字段排序文档，但是字段散落在文档中==》空间换时间的思路，再构造一个列式存储结构，将散落在各个文档的某个字段，集中存放</p><h3 id="lucene总结"><a href="#lucene总结" class="headerlink" title="lucene总结"></a>lucene总结</h3><p>倒排索引用于搜索</p><p>Term Index 用于加速搜索【相同前缀，目录树】</p><p>Stored Fields 用于存放文档的原始信息</p><p>Doc Values 用于排序和聚合。</p><p>这些结构共同组成了一个复合文件segment，segment 一旦生成，则不能再被修改，所以旧的segment只负责读，新的segment 负责读和写；segment 一旦变多就有segment merging段合并</p><p>而多个segment组成lucene，一个单机的文本检索库</p><h3 id="es的进步"><a href="#es的进步" class="headerlink" title="es的进步"></a>es的进步</h3><p>es就是在lucene 的基础上实现了</p><ul><li><p>高性能：对数据进行分类写入不同的lucene，把多操作分摊到多个分片shard 中去</p></li><li><p>高扩展：把shard 分散部署在多台机器</p></li><li><p>高可用：在不同node添加shard 的副本</p></li></ul><p>涉及到集群部分：</p><ul><li><p>Node角色分化：主节点负责管理集群；数据节点负责存储管理数据，协调节点负责接受客户端搜索查询请求</p></li><li><p>去中心化：选主，在 Node 间引入协调模块，用类似一致性算法 Raft 的方式，在节点间互相同步数据</p></li></ul><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h3><ul><li>当客户端应用发起数据写入请求，请求会先发到集群中协调节点。</li><li>协调节点根据 hash 路由，判断数据该写入到哪个分片(Shard)，找到主分片并写入到 lucene 库里的 segment 内，将数据固化为倒排索引和 Stored Fields 以及 Doc Values 等多种结构。</li><li>主分片 写入成功后会将数据同步给 副本分片。</li><li>副本分片 写入完成后，主分片会响应协调节点 ACK</li><li>最后，协调节点响应客户端应用写入完成。</li></ul><h3 id="搜索过程"><a href="#搜索过程" class="headerlink" title="搜索过程"></a>搜索过程</h3><ol><li>查询阶段</li></ol><ul><li>当客户端应用发起搜索请求，请求会先发到集群中的协调节点。</li><li>协调节点根据 index name 的信息，可以了解到 index name 被分为了几个 分片，以及这些分片 分散哪个数据节点上，将请求转发到这些数据节点的 分片 上面。</li><li>搜索请求到达分片后，分片 底层的 lucene 库会并发搜索多个 segment，利用每个 segment 内部的倒排索引获取到对应文档 id，并结合 doc values 获得排序信息。分片将结果聚合返回给协调节点。</li><li>协调节点排序聚合多个分片中拿到的数据，舍弃大部分不需要的数据。</li></ul><ol start="2"><li>获取阶段</li></ol><ul><li>协调节点再次拿着文档 id 请求数据节点里的 分片，分片 底层的 lucene 库会从 segment 内的 Stored Fields 中取出完整文档内容，并返回给协调节点。</li><li>协调节点最终将数据结果返回给客户端。完成整个搜索过程。</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><p>分词机制：字符过滤（移除特殊符号）、分词器、词项过滤器（转小写，停用词，同义，长度过滤）</p><p>中文分词的挑战：没有自然分隔、歧义词、词性多样</p><p>使用IK分词器</p><p><strong>电子商务中的商品搜索</strong>：使用 <strong>同义词过滤器</strong> 和 <strong>拼音分词</strong> 来扩展用户查询，提高商品搜索的精度和召回率。</p><p><strong>内容推荐和个性化搜索：</strong>通过 <strong>智能分词</strong> 提升语义理解能力，识别用户查询中的重要部分，增强推荐的相关性；结合 <strong>上下文分析</strong> 和 <strong>实体识别</strong> 技术，可以进一步理解用户的搜索意图，从而提供个性化的推荐。</p><p><strong>社交媒体和评论分析</strong>：通过 <strong>分词器的定制化</strong> 和 <strong>同义词扩展</strong>，可以帮助解析出用户的真正意图，例如“赞”、“喜欢”等表达同一情感的词可以归为同一类；在分析社交数据时，还需要处理拼音输入带来的问题，尤其是年轻用户常用拼音代替汉字，利用拼音分词器优化这类搜索场景。</p><h3 id="如何与mysql保持一致？"><a href="#如何与mysql保持一致？" class="headerlink" title="如何与mysql保持一致？"></a>如何与mysql保持一致？</h3><p><a href="https://www.bilibili.com/video/BV1H84y1e7AF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=41a2f9dcec558ceed6904640a531e4b3">【IT老齐268】ElasticSearch与MySQL如何搭配，很多人都弄错了_哔哩哔哩_bilibili</a></p><p><img src="E:/Download/PicGo/picture/-17274937426102.png" alt="img"></p><ol><li><strong>Binlog同步</strong>（如使用Canal）适合需要实时同步且能保证较高一致性的场景。</li><li><strong>应用程序双写</strong>简单有效，但需要注意事务性和网络问题。</li><li><strong>定时批量同步</strong>适合对实时性要求不高的业务。</li><li><strong>消息队列同步</strong>提供异步处理，解耦MySQL和ES操作，但需要处理好消息丢失和幂等性问题。</li></ol><p>使用Canal实现ES与MySQL保持一致性注意事项</p><ol><li>Binlog 格式设置：Canal 只能解析 <strong>ROW</strong> 格式的 Binlog 日志，而不是默认的 STATEMENT 或 MIXED。</li><li>初始化：Canal只能增量同步，所以要先进行全量数据导入</li><li>写入性能优化：使用<strong>批量写入</strong>（Bulk API）而不是每次变更都单独发送请求</li><li>幂等性处理：恢复、网络抖动或者重试时Canal 可能会重复接收到同一条 Binlog 记录  ==》MySQL <code>ID</code>作为文档的 <code>_id</code> 字段</li><li>数据一致性：同步数据是异步操作，接受一定延迟，Canal要设置失败重试</li><li>监控：建立监控报警机制，当同步延迟或出现异常时，能够及时告警并采取修复措施。</li></ol><h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><p>倒排索引，分词器（分词流程），分片机制（分布式集群），分段机制，一般考的就是倒排</p><p>es搜索引擎，高并发架构的一环，简单来讲是搜索功能的升级版（比通常数据库的like %效率更高，耗费性能更少），实习的话不算必须项，算加分项，工作以后看项目需求（如果你的项目很少用到搜索功能，就不太需要，比如说专门研究网络传输的部门，毕竟完全没有高并发，不是toC端的），不过实习的时候面试官应该都会本着试探你学习能力的目的稍微问问吧。 </p><ol><li>为什么用Elasticsearch（包含为什么快/和直接使用MySQL模糊查询比较有什么优势/为什么不用mysql）<ol><li>ES专为全文检索设计，能够处理复杂的分词、权重计算、相关性排序等需求<ul><li>权重是一个比较重要的指标，会影响影响文档的相关性得分</li><li><strong>搜索引擎</strong>：为不同的字段或文档设置权重，确保更重要的内容在搜索结果中排名靠前。</li><li><strong>电商平台</strong>：提升用户更可能购买的商品，或者某些促销商品的排名。</li><li><strong>内容推荐系统</strong>：根据用户历史浏览、点击、购买行为，动态调整内容的推荐权重。</li></ul></li><li>倒排索引，查找速度远超MySQL的<code>LIKE</code>查询。尤其是当数据量巨大时，MySQL模糊查询会变得非常慢</li><li>ES天生支持分布式存储和查询，能够轻松扩展处理大规模数据，适用于日志分析、数据搜索等场景。MySQL虽然也可以通过分库分表解决，但操作复杂且扩展性较差。</li><li>支持多种复杂查询，如地理位置查询、模糊匹配、聚合分析等，功能远超MySQL。</li><li>读写分离</li></ol></li></ol><p>为什么不用mysql</p><p>单表有限、B+树不适合不适合全文检索</p><p><img src="E:/Download/PicGo/picture/-17274937426103.png" alt="img"></p><p>为什么不直接只用ES（Mysql的优势）</p><p>ES：非关系型数据库不适合，不支持事务</p><p><img src="E:/Download/PicGo/picture/-17274937426104.png" alt="img"></p><ol start="2"><li>ES 有哪些数据类型以及用了哪些</li></ol><p>结构类型见【基础概念part】</p><p>数据类型：</p><ul><li>核心类型：8种基本数据类型</li></ul><img src="E:/Download/PicGo/picture/-17274937426105.png" alt="img" style="zoom: 67%;"><ol start="3"><li>怎样数据同步（为什么引入Elasticsearch canel）</li></ol><p>​见<a href="https://i12pc3nf6d.feishu.cn/wiki/FnPwwGXGli1ANGkaMz5chvhmn2e#share-HIeddyZ1ooUb4Ex9qpScZBBynLf">Elastic Search</a></p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol start="4"><li>压力大怎么处理</li></ol><p><strong>增加节点</strong>：增加数据节点（Data Node）来水平扩展。</p><p><strong>调整集群资源配置</strong>：</p><ul><li><strong>分片（Shard）数量</strong>：合理配置主分片和副本分片的数量。</li><li><strong>资源隔离</strong>：通过角色分离不同节点，如数据节点、主节点和协调节点避免因资源争抢而导致瓶颈。</li></ul><p><strong>缓存机制：</strong>使用查询缓存和索引缓存来减少对磁盘的访问频率；针对常见查询结果，使用<code>_search</code> API的<code>request_cache</code>来缓存结果。</p><p><strong>请求优化</strong>：</p><ul><li>尽量使用分页查询（Scroll API）或批量操作（Bulk API）来减小单次请求的压力。</li><li>控制查询深度（限制深度分页）和返回数据量（减少字段选择）来降低查询负载。</li></ul><ol start="5"><li>数据倾斜：某些节点或分片承载了过多的查询或写入请求，导致这些节点或分片成为性能瓶颈。</li></ol><p>​<strong>自定义路由</strong>：使用<code>_routing</code>参数进行自定义路由，确保数据根据业务逻辑被合理分配到不同分片，而不是所有写请求都集中到某个热点分片。</p><ol start="6"><li>长尾：某些查询或写入操作花费时间过长，导致延迟累积，影响整体性能<ol><li>慢查询分析：showlog</li><li>索引优化：doc_values</li><li>查询重构：将深度嵌套查询改为多次请求、适当使用过滤器而非<code>full-text</code>查询。</li><li>分片优化：防止某些查询集中在单一分片上造成长尾现象。分片过少会导致查询集中，分片过多会引入开销。</li><li>异步查询</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Elastic Search </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现多级缓存的策略方法</title>
      <link href="/posts/cache/"/>
      <url>/posts/cache/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="实现多级缓存的策略方法"><a href="#实现多级缓存的策略方法" class="headerlink" title="实现多级缓存的策略方法"></a>实现多级缓存的策略方法</h1><blockquote><p>保证多级缓存数据一致性是一个复杂的任务，尤其是在分布式和高并发环境中。以下是一些常见的方法和策略，可以帮助实现多级缓存的数据一致性</p></blockquote><h2 id="1-缓存失效策略"><a href="#1-缓存失效策略" class="headerlink" title="1. 缓存失效策略"></a>1. 缓存失效策略</h2><h3 id="1-1-主动失效"><a href="#1-1-主动失效" class="headerlink" title="1.1 主动失效"></a>1.1 主动失效</h3><p>在更新数据库时，主动使相关缓存失效。</p><p>步骤：</p><ol><li>更新数据库</li><li>删除或失效缓存<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        database.update(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除相关缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">"data:"</span> + data.getId();</span><br><span class="line">        localCache.delete(cacheKey);</span><br><span class="line">        redisCache.delete(cacheKey);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="1-2-延迟双删（Lazy-Delete）"><a href="#1-2-延迟双删（Lazy-Delete）" class="headerlink" title="1.2 延迟双删（Lazy Delete）"></a>1.2 延迟双删（Lazy Delete）</h3><p>在更新数据库前后都删除缓存，确保缓存数据的准确性。</p><p>步骤：</p><ol><li>更新前删除缓存</li><li>更新数据库</li><li>更新后再删除一次缓存</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">"data:"</span> + data.getId();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一次删除缓存</span></span><br><span class="line">        localCache.delete(cacheKey);</span><br><span class="line">        redisCache.delete(cacheKey);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        database.update(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保数据库更新完成后再次删除缓存</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 延迟 1 秒</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        localCache.delete(cacheKey);</span><br><span class="line">        redisCache.delete(cacheKey);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-双写一致性策略"><a href="#2-双写一致性策略" class="headerlink" title="2. 双写一致性策略"></a>2. 双写一致性策略</h2><h3 id="2-1-先更新数据库，再更新缓存"><a href="#2-1-先更新数据库，再更新缓存" class="headerlink" title="2.1 先更新数据库，再更新缓存"></a>2.1 先更新数据库，再更新缓存</h3><p>步骤：</p><ol><li>更新数据库</li><li>更新缓存<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        database.update(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">"data:"</span> + data.getId();</span><br><span class="line">        localCache.set(cacheKey, data);</span><br><span class="line">        redisCache.set(cacheKey, data);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="2-2-先删除缓存，再更新数据库"><a href="#2-2-先删除缓存，再更新数据库" class="headerlink" title="2.2 先删除缓存，再更新数据库"></a>2.2 先删除缓存，再更新数据库</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">"data:"</span> + data.getId();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除缓存</span></span><br><span class="line">        localCache.delete(cacheKey);</span><br><span class="line">        redisCache.delete(cacheKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        database.update(data);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-缓存更新策略"><a href="#3-缓存更新策略" class="headerlink" title="3. 缓存更新策略"></a>3. 缓存更新策略</h2><h3 id="3-1-写通过（Write-through）"><a href="#3-1-写通过（Write-through）" class="headerlink" title="3.1 写通过（Write-through）"></a>3.1 写通过（Write-through）</h3><p>在写入数据库时，同时更新缓存。</p><p>步骤：</p><ol><li>更新数据库</li><li>更新缓存<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        database.update(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">"data:"</span> + data.getId();</span><br><span class="line">        localCache.set(cacheKey, data);</span><br><span class="line">        redisCache.set(cacheKey, data);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="3-2-写回（Write-back）"><a href="#3-2-写回（Write-back）" class="headerlink" title="3.2 写回（Write-back）"></a>3.2 写回（Write-back）</h3><p>先更新缓存，定期将缓存数据写回数据库。</p><p>步骤：</p><ol><li>更新缓存</li><li>定期将缓存数据写回数据库<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">"data:"</span> + data.getId();</span><br><span class="line">        localCache.set(cacheKey, data);</span><br><span class="line">        redisCache.set(cacheKey, data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定期将缓存数据写回数据库</span></span><br><span class="line">        scheduleWriteBack(data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleWriteBack</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="comment">// 实现定期将缓存数据写回数据库的逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h2><p>使用分布式锁（如 Redis 的 RedLock）来确保多节点环境下的一致性。</p><p>步骤：</p><ol><li>获取分布式锁</li><li>更新数据库和缓存</li><li>释放分布式锁</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line">    <span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDataWithLock</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">"lock:data:"</span> + data.getId();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource()) {</span><br><span class="line">            <span class="comment">// 获取分布式锁</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> acquireLock(jedis, lockKey, <span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">if</span> (lock != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    updateData(data);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 释放分布式锁</span></span><br><span class="line">                    releaseLock(jedis, lockKey, lock);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        database.update(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">"data:"</span> + data.getId();</span><br><span class="line">        localCache.set(cacheKey, data);</span><br><span class="line">        redisCache.set(cacheKey, data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">acquireLock</span><span class="params">(Jedis jedis, String lockKey, <span class="type">int</span> timeout)</span> {</span><br><span class="line">        <span class="comment">// 实现获取分布式锁的逻辑</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(Jedis jedis, String lockKey, String lock)</span> {</span><br><span class="line">        <span class="comment">// 实现释放分布式锁的逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-异步更新"><a href="#5-异步更新" class="headerlink" title="5. 异步更新"></a>5. 异步更新</h2><p>使用异步机制，在更新数据库后异步更新缓存。</p><p>步骤：</p><ol><li>更新数据库</li><li>异步更新缓存</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> {</span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        database.update(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步更新缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">"data:"</span> + data.getId();</span><br><span class="line">        executorService.submit(() -&gt; updateCache(cacheKey, data));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateCache</span><span class="params">(String cacheKey, Data data)</span> {</span><br><span class="line">        localCache.set(cacheKey, data);</span><br><span class="line">        redisCache.set(cacheKey, data);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-使用消息队列"><a href="#6-使用消息队列" class="headerlink" title="6. 使用消息队列"></a>6. 使用消息队列</h2><p>通过消息队列通知其他缓存节点更新缓存。这里举例使用<code>rabbitmq</code>简单实现，也可以用<code>其他mq</code>或者<code>Canal</code>实现</p><p>步骤：</p><ol><li>更新数据库</li><li>发送缓存失效消息到消息队列</li><li>各缓存节点订阅消息队列，接收到消息后失效缓存</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// RabbitMQConfig.java</span></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">"cache_invalidation_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">createChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>); <span class="comment">// RabbitMQ 服务器地址</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection.createChannel();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// CacheService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Database database;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheService</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="built_in">this</span>.channel = RabbitMQConfig.createChannel();</span><br><span class="line">        channel.queueDeclare(RabbitMQConfig.QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        database.update(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成缓存键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">"data:"</span> + data.getId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送缓存失效消息到 RabbitMQ</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, RabbitMQConfig.QUEUE_NAME, <span class="literal">null</span>, cacheKey.getBytes());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// CacheInvalidationListener.java</span></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheInvalidationListener</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheInvalidationListener</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="built_in">this</span>.channel = RabbitMQConfig.createChannel();</span><br><span class="line">        channel.queueDeclare(RabbitMQConfig.QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startListener</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">                <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                localCache.delete(cacheKey);</span><br><span class="line">                redisCache.delete(cacheKey);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume(RabbitMQConfig.QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">CacheInvalidationListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheInvalidationListener</span>();</span><br><span class="line">        listener.startListener();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>TIPS：异步更新和消息队列思想的区别<br>异步更新：适用于单节点或小规模系统，依赖于应用内部的异步处理机制，较为简单但在分布式环境中扩展性差。</p><p>使用消息队列：适用于分布式和大规模系统，依赖于外部消息队列系统，在多个节点之间确保数据一致性，更具扩展性但实现和运维复杂度较高。</p></blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过结合使用主动失效、延迟双删、双写一致性、写通过、写回、分布式锁和异步更新等策略，可以有效地保证多级缓存的数据一致性。选择合适的策略取决于具体的应用场景和需求O(∩_∩)O</p>]]></content>
      
      
      <categories>
          
          <category> 场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 项目优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL 学习笔记及项目应用</title>
      <link href="/posts/openssl/"/>
      <url>/posts/openssl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenSSL-学习笔记及项目应用"><a href="#OpenSSL-学习笔记及项目应用" class="headerlink" title="OpenSSL 学习笔记及项目应用"></a>OpenSSL 学习笔记及项目应用</h1><p>OpenSSL官方命令手册：<a href="https://docs.openssl.org/master/man1/">OpenSSL commands - OpenSSL Documentation</a></p><p>参考教程：</p><p>操作：<a href="https://blog.csdn.net/fsq0827/article/details/99710052">OpenSSL的基本使用教程(一）_openssl.exe使用教程-CSDN博客</a></p><p>操作：<a href="https://www.cnblogs.com/f-ck-need-u/p/7048359.html#auto_id_5">Linux和Shell回炉复习系列文章总目录 - 骏马金龙 - 博客园 (cnblogs.com)</a></p><p>网站应用：<a href="https://blog.csdn.net/xxxlllbbb/article/details/107891790">最新OpenSSL简明教程_openssl使用教程-CSDN博客</a></p><p>项目应用：<a href="https://gitee.com/hweiyu/spring-boot-sign">spring-boot-sign: SpringBoot请求响应加签、验签 (gitee.com)</a></p><p><a href="https://blog.csdn.net/qq_43290318/article/details/131516099">最详细的SpringBoot实现接口校验签名调用_springboot接口签名验证-CSDN博客</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="公钥和私钥"><a href="#公钥和私钥" class="headerlink" title="公钥和私钥"></a>公钥和私钥</h3><ul><li><strong>公钥</strong>：可以公开分享，用于加密数据或验证数字签名。</li><li><strong>私钥</strong>：必须保密，用于解密数据或创建数字签名。</li><li>关系：公钥和私钥是成对出现的，使用公钥加密的数据只能由对应的私钥解密，反之亦然。</li></ul><p>一个完整的RSA私钥包含了以下几个关键参数：</p><ol><li>模数（Modulus，N）</li><li>公钥指数（Public Exponent，e）</li><li>私钥指数（Private Exponent，d）</li><li>素数p（Prime 1，p）</li><li>素数q（Prime 2，q）</li><li>指数dp（Exponent 1，dp）</li><li>指数dq（Exponent 2，dq）</li><li>系数（Coefficient，qinv）</li></ol><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li>数字签名使用私钥创建，确保数据的完整性和来源的真实性。</li><li>验证签名使用公钥，可以确认数据是否被篡改，并且确认数据确实来自特定的私钥持有者。</li></ul><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><ul><li>数字证书由受信任的证书颁发机构（CA）签发，包含公钥及其所有者的身份信息。</li><li>证书用于验证公钥的真实性，确保其属于声明中的持有者。</li></ul><h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><ul><li><strong>对称加密</strong>：使用相同的密钥进行加密和解密，例如 AES、DES。</li><li><strong>非对称加密</strong>：使用一对公钥和私钥进行加密和解密，例如 RSA。</li><li>对称加密速度快，适合大数据量；非对称加密安全性高，适合小数据量。</li></ul><h3 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h3><ul><li>证书链由一系列证书组成，确保最终用户证书的可信性。</li><li>包括根证书（CA）、中间证书和最终用户证书。</li><li>验证证书链时，必须从根证书到最终用户证书逐级验证。</li></ul><h3 id="常见文件后缀"><a href="#常见文件后缀" class="headerlink" title="常见文件后缀"></a>常见文件后缀</h3><p>**<code>.key</code>**：通常用于表示私钥或公钥文件。这个后缀比较通用，可以表示任何类型的加密密钥。 <code>private.key</code>（私钥），<code>public.key</code>（公钥）。</p><p><strong><code>.pub</code></strong>:通常用于表示公钥文件。这个后缀明确指示文件包含公钥。<code>id_rsa.pub</code>（RSA 公钥），<code>id_ecdsa.pub</code>（ECDSA 公钥）。</p><p>**<code>.pri</code>**：通常用于表示私钥文件。虽然不是标准后缀，但一些系统或工具可能使用这个后缀来标识私钥文件。 <code>private.pri</code>。</p><p>**<code>.pem</code>**： PEM（Privacy Enhanced Mail）格式文件的标准后缀，通常用于存储证书、私钥、公钥和证书链。文件内容通常以 Base64 编码并用 “—–BEGIN CERTIFICATE—–” 等标头和尾标记。<code>cert.pem</code>（证书），<code>private.pem</code>（私钥），<code>public.pem</code>（公钥）。</p><p>**<code>.crt</code>**：通常用于表示 X.509 证书文件。这个后缀通常用于证书文件，格式可以是 PEM 或 DER。<code>server.crt</code>（服务器证书），<code>ca.crt</code>（CA 证书）。</p><p>**<code>.csr</code>**：用于表示证书签名请求（Certificate Signing Request）文件。CSR 文件包含申请证书时的必要信息。<code>request.csr</code>。</p><p>**<code>.der</code>**：DER（Distinguished Encoding Rules）格式文件的标准后缀，通常用于存储二进制编码的证书或密钥。不同于 PEM 格式，DER 文件是二进制格式，没有 Base64 编码。<code>cert.der</code>（证书），<code>private.der</code>（私钥）。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="（零）使用-OpenSSL-的流程"><a href="#（零）使用-OpenSSL-的流程" class="headerlink" title="（零）使用 OpenSSL 的流程"></a>（零）使用 OpenSSL 的流程</h3><ol><li><strong>生成密钥对</strong>：使用 <code>openssl genpkey</code> 和 <code>openssl rsa</code> 生成私钥和公钥。</li><li><strong>创建 CSR</strong>：使用 <code>openssl req</code> 创建证书签名请求。</li><li><strong>获得数字证书</strong>：通过 CA 颁发或自签名生成证书。</li><li><strong>加密和签名</strong>：使用公钥加密数据，使用私钥签名数据。</li><li><strong>解密和验证签名</strong>：使用私钥解密数据，使用公钥验证签名。</li></ol><h3 id="（一）安装OpenSSL"><a href="#（一）安装OpenSSL" class="headerlink" title="（一）安装OpenSSL"></a>（一）安装OpenSSL</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install openssl</span><br><span class="line">openssl version</span><br></pre></td></tr></tbody></table></figure><h3 id="（二）生成自签名证书"><a href="#（二）生成自签名证书" class="headerlink" title="（二）生成自签名证书"></a>（二）生成自签名证书</h3><p>生成一张自签名证书，类似一张独一无二的会员卡。</p><ol><li><p><strong>生成私钥</strong> 私钥是证书的核心。首先生成一个2048位的RSA私钥：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># openssl genpkey: OpenSSL命令，用于生成私钥</span></span><br><span class="line"><span class="comment"># algorithm RSA: 指定使用RSA算法生成私钥</span></span><br><span class="line"><span class="comment"># out private.key: 输出文件名为private.key【可选，不写的话就是直接输出到终端】</span></span><br><span class="line"><span class="comment"># pkeyopt rsa_keygen_bits:2048: 指定生成2048位的RSA密钥</span></span><br><span class="line">openssl genpkey -algorithm RSA -out private.key -pkeyopt rsa_keygen_bits:2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用genrsa命令，就不用指定算法</span></span><br><span class="line">openssl genrsa -out genrsa.txt 512</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候屏幕会出现一堆+.符号，这只是用来表示计算进度的输出</span></span><br><span class="line"><span class="comment"># 查看私钥内容，是Base64编码格式</span></span><br><span class="line"><span class="built_in">cat</span> private.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析私钥，输出私钥的详细信息，包括私钥的模数（modulus）等</span></span><br><span class="line">openssl pkey -<span class="keyword">in</span> private.key -text -noout</span><br><span class="line"></span><br><span class="line"><span class="comment"># check检查私钥文件是否被修改过，如果修改了会输出RSA key not ok</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private.key -check</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出私钥明文到文件夹中</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private.key -text -out private.txt</span><br></pre></td></tr></tbody></table></figure><p>加钥私密文件</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 加密私钥文件，加密的密码为123456</span></span><br><span class="line">openssl genrsa -out genrsa.txt -des3 -passout pass:123456 512</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密码错误，无法加密，必须一致才能加密</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> genrsa.txt -passin pass:13456 -check</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>生成证书签名请求（CSR）</strong> 使用私钥生成一个CSR文件，这是获得数字证书的关键步骤，<strong>CSR包含了申请者的身份信息和公钥</strong></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># openssl req: OpenSSL命令，用于处理证书请求和生成CSR。</span></span><br><span class="line"><span class="comment"># new: 生成新的CSR。</span></span><br><span class="line"><span class="comment"># key private.key: 使用之前生成的私钥private.key。</span></span><br><span class="line"><span class="comment"># out mycsr.csr: 输出文件名为mycsr.csr。</span></span><br><span class="line">openssl req -new -key private.key -out mycsr.csr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看CSR内容，包含Subject（组织名称等）、Public Key（公钥）、Signature（用私钥对CSR进行的数字签名，确保CSR未被篡改）</span></span><br><span class="line">openssl req -<span class="keyword">in</span> mycsr.csr -noout -text</span><br></pre></td></tr></tbody></table></figure><p>在这个过程中，会被提示输入一些信息，以下字段是必填的：</p><ol><li>Country Name (2 letter code):CN</li><li>State or Province Name (full name):Guangdong</li><li>Locality Name (eg, city):Guangzhou</li><li>Organization Name (eg, company):SCNU</li><li>Common Name (e.g. server FQDN or YOUR name):Xuan</li></ol><p>而以下字段是可选的：</p><ol><li>Organizational Unit Name (eg, section)</li><li>Email Address</li><li>A challenge password</li><li>An optional company name</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/image-20240725085508784.png" alt="image-20240725085508784"></p></li><li><p><strong>生成自签名证书</strong> 使用CSR和私钥生成一个有效期为一年的自签名证书：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># penssl x509: OpenSSL命令，用于管理X.509证书。</span></span><br><span class="line"><span class="comment"># req: 表示输入是一个证书请求（CSR）。</span></span><br><span class="line"><span class="comment"># days 365: 证书的有效期为365天。</span></span><br><span class="line"><span class="comment"># in mycsr.csr: 输入CSR文件mycsr.csr。</span></span><br><span class="line"><span class="comment"># signkey private.key: 使用private.key私钥进行签名。</span></span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> mycsr.csr -signkey private.key -out mycert.crt</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="（三）基本使用"><a href="#（三）基本使用" class="headerlink" title="（三）基本使用"></a>（三）基本使用</h3><ol><li><p><strong>查看证书信息</strong> 使用以下命令查看证书的详细信息：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># in mycert.crt: 输入证书文件mycert.crt。</span></span><br><span class="line"><span class="comment"># text: 以文本格式显示证书内容。</span></span><br><span class="line"><span class="comment"># noout: 不输出证书本身，只显示信息。</span></span><br><span class="line"><span class="comment"># 数字证书包括版本号、序列号、签名算法、颁发者信息、有效期、持有者信息、公钥、证书扩展、签名等等</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> mycert.crt -text -noout</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>加密文件</strong> 使用公钥加密一个文件：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从证书中提取公钥</span></span><br><span class="line">openssl x509 -pubkey -noout -<span class="keyword">in</span> mycert.crt &gt; public.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成测试文本文件，输入sth</span></span><br><span class="line"><span class="built_in">touch</span> plaintext.txt</span><br><span class="line">/ vim plaintext.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># openssl rsautl: OpenSSL命令，用于使用RSA算法进行加密、解密操作。</span></span><br><span class="line"><span class="comment"># encrypt: 进行加密操作。</span></span><br><span class="line"><span class="comment"># inkey public.key: 使用public.key中的公钥。</span></span><br><span class="line"><span class="comment"># pubin: 指定输入文件是公钥。</span></span><br><span class="line"><span class="comment"># in plaintext.txt: 输入要加密的文件plaintext.txt。</span></span><br><span class="line">openssl pkeyutl -encrypt -pubin -inkey public.key -<span class="keyword">in</span> plaintext.txt -out encrypted.dat</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>解密文件</strong> 使用私钥解密文件：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># openssl pkeyutl: 用于使用RSA算法进行加密、解密操作。【注意3.0.x版本只能用pkeyutl不能用rsault】</span></span><br><span class="line"><span class="comment"># decrypt: 进行解密操作。</span></span><br><span class="line"><span class="comment"># inkey private.key: 使用私钥private.key进行解密。</span></span><br><span class="line">openssl pkeyutl -decrypt -inkey private.key -<span class="keyword">in</span> encrypted.dat -out decrypted.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看解密后内容，发现和</span></span><br><span class="line"><span class="built_in">cat</span> decrypted.txt</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="（四）其他使用"><a href="#（四）其他使用" class="headerlink" title="（四）其他使用"></a>（四）其他使用</h3><ol><li><p><code>openssl speed</code>测试加密算法的性能</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">openssl speed [md2] [mdc2] [md5] [hmac] [sha1] [rmd160] [idea-cbc] [rc2-cbc] [rc5-cbc] [bf-cbc] [des-cbc] [des-ede3] [rc4] [rsa512] [rsa1024] [rsa2048] [rsa4096] [dsa512] [dsa1024] [dsa2048] [idea] [rc2] [des] [rsa] [blowfish]</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>openssl rand</code>生成伪随机数</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">openssl rand [-out file] [-rand file(s)] [-<span class="built_in">base64</span>] [-hex] num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项说明：</span></span><br><span class="line"><span class="comment"># -out：指定随机数输出文件，否则输出到标准输出。</span></span><br><span class="line"><span class="comment"># -rand file：指定随机数种子文件。种子文件中的字符越随机，openssl rand生成随机数的速度越快，随机度越高。</span></span><br><span class="line"><span class="comment"># -base64：指定生成的随机数的编码格式为base64。</span></span><br><span class="line"><span class="comment"># -hex：指定生成的随机数的编码格式为hex。</span></span><br><span class="line"><span class="comment"># - num：指定随机数的长度。</span></span><br><span class="line"></span><br><span class="line">openssl rand -<span class="built_in">base64</span> 30;</span><br><span class="line">openssl rand -hex 30;</span><br><span class="line">openssl rand 30</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>openssl passwd</code> 生成加密的密码</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">   openssl passwd [-crypt] [-1] [-apr1] [-salt string] [-<span class="keyword">in</span> file] [-stdin] [-quiet] {password}</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 生成默认的密码哈希（使用 DES 加密）</span></span><br><span class="line">   openssl passwd -1 <span class="string">"password"</span></span><br><span class="line">   <span class="comment"># 生成使用 SHA-256 的密码哈希</span></span><br><span class="line">   openssl passwd -6 <span class="string">"password"</span></span><br><span class="line">   <span class="comment"># 生成盐（salt）并使用其生成密码哈希【盐相同，密码相同】</span></span><br><span class="line">   openssl passwd -salt mysalt -1 <span class="string">"password"</span></span><br><span class="line">   <span class="comment"># 交互式输入密码</span></span><br><span class="line">   openssl passwd -1</span><br><span class="line"></span><br><span class="line">4. `openssl dgst` 生成和验证数字签名</span><br><span class="line"></span><br><span class="line">   ```bash</span><br><span class="line">   openssl dgst [-md5|-sha1|...] [-hex | -binary] [-out filename] [-sign filename] [-passin arg] [-verify filename] [-prverify filename] [-signature filename] [file...]</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># -sign filename:使用指定的私钥文件对哈希值进行签名</span></span><br><span class="line">   <span class="comment"># -verify filename:使用指定的公钥文件来验证签名</span></span><br><span class="line">   <span class="comment"># -prverify filename:同上，可以指定密钥文件的密码。</span></span><br><span class="line">   <span class="comment"># -signature filename:指定签名文件，以便与数据一起用于验证签名</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 计算文件.txt 的 SHA-256 哈希并将结果写入 hash.txt 文件：</span></span><br><span class="line">   dgst -sha256 -hex (-out hash.txt) plaintext.txt </span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 使用私钥对plaintext.txt生成签名，并将签名保存到signature.sig 中【使用-sign签名时绝对不能加-hex，不然后面验签一定会失败】</span></span><br><span class="line">   openssl dgst -sha256 -sign private.key -out signature.sig plaintext.txt</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 使用公钥 public.key 验证签名 signature.sig，输出verified.ok即签名有效</span></span><br><span class="line">   openssl dgst -sha256 -verify public.key -signature signature.sig plaintext.txt </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 使用密码保护的私钥</span></span><br><span class="line">   openssl dgst -sha256 -sign private.key -passin pass:yourpassword -out signature.sig example.txt</span><br><span class="line">   </span><br></pre></td></tr></tbody></table></figure></li><li><p><code>openssl rsautl和openssl pkeyutl</code>：文件的非对称加密</p><p>rsautl是rsa的工具，相当于rsa、dgst的部分功能集合，可用于生成数字签名、验证数字签名、加密和解密文件。</p><p>pkeyutl是非对称加密的通用工具，大体上和rsautl的用法差不多</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">   ```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 项目实践</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### （一）在SpringBoot中使用</span></span><br><span class="line"></span><br><span class="line">1. OpenSSL生成密钥和证书，配置HTTPS</span><br><span class="line"></span><br><span class="line">```yaml</span><br><span class="line"><span class="comment"># application.yml</span></span><br><span class="line">server:</span><br><span class="line">  ssl:</span><br><span class="line">    key-store: classpath:keystore.p12</span><br><span class="line">    key-store-password: yourpassword</span><br><span class="line">    key-store-type: PKCS12</span><br><span class="line">    key-alias: youralias</span><br></pre></td></tr></tbody></table></figure></li><li><p>在JWT中使用（JWT详细介绍可见：<a href="https://blog.csdn.net/Kixuan214/article/details/140690612?spm=1001.2014.3001.5502">浅析JWT原理及牛客出现过的相关面试题-CSDN博客</a>），在Spring Boot应用中使用JWT进行认证和授权时，可以使用生成的私钥和公钥进行签名和验证。</p></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">"-----BEGIN PRIVATE KEY-----...-----END PRIVATE KEY-----"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PUBLIC_KEY</span> <span class="operator">=</span> <span class="string">"-----BEGIN PUBLIC KEY-----...-----END PUBLIC KEY-----"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从PEM格式的字符串中解析并返回私钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title function_">getPrivateKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyPEM</span> <span class="operator">=</span> PRIVATE_KEY.replace(<span class="string">"-----BEGIN PRIVATE KEY-----"</span>, <span class="string">""</span>)</span><br><span class="line">                                          .replace(<span class="string">"-----END PRIVATE KEY-----"</span>, <span class="string">""</span>)</span><br><span class="line">                                          .replaceAll(<span class="string">"\\s"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="type">byte</span>[] encoded = Base64.getDecoder().decode(privateKeyPEM);</span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(encoded);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(keySpec);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从PEM格式的字符串中解析并返回公钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PublicKey <span class="title function_">getPublicKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">publicKeyPEM</span> <span class="operator">=</span> PUBLIC_KEY.replace(<span class="string">"-----BEGIN PUBLIC KEY-----"</span>, <span class="string">""</span>)</span><br><span class="line">                                        .replace(<span class="string">"-----END PUBLIC KEY-----"</span>, <span class="string">""</span>)</span><br><span class="line">                                        .replaceAll(<span class="string">"\\s"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="type">byte</span>[] encoded = Base64.getDecoder().decode(publicKeyPEM);</span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(encoded);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用私钥生成JWT令牌</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateToken</span><span class="params">(String subject)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                   .setSubject(subject)</span><br><span class="line">                   .signWith(getPrivateKey(), SignatureAlgorithm.RS256)</span><br><span class="line">                   .compact();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用公钥验证JWT令牌</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">validateToken</span><span class="params">(String token)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        Jwts.parserBuilder()</span><br><span class="line">            .setSigningKey(getPublicKey())</span><br><span class="line">            .build()</span><br><span class="line">            .parseClaimsJws(token);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="（二）在区块链项目中使用"><a href="#（二）在区块链项目中使用" class="headerlink" title="（二）在区块链项目中使用"></a>（二）在区块链项目中使用</h3><p>使用私钥对交易进行签名。使用Java的Bouncy Castle库进行签名</p><ol><li><p>添加Bouncy Castle依赖</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.70&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;bcpkix-jdk15on&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.70&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>创建证书生成工具类<code>CertificateGenerator</code></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.bouncycastle.asn1.x500.X500Name;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.asn1.x500.style.BCStyle;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.asn1.x509.Extension;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.asn1.x509.ExtensionsGenerator;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.cert.X509CertificateHolder;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.operator.ContentSigner;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CertificateGenerator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title function_">generateKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException {</span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        keyPairGenerator.initialize(<span class="number">2048</span>);</span><br><span class="line">        <span class="keyword">return</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> X509Certificate <span class="title function_">generateCertificate</span><span class="params">(KeyPair keyPair)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">X500Name</span> <span class="variable">issuer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X500Name</span>(<span class="string">"CN=Test CA Certificate"</span>);</span><br><span class="line">        <span class="type">X500Name</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X500Name</span>(<span class="string">"CN=Test Certificate"</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">serialNumber</span> <span class="operator">=</span> BigInteger.valueOf(System.currentTimeMillis());</span><br><span class="line">        <span class="type">Date</span> <span class="variable">notBefore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() - <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">notAfter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyPair.getPublic();</span><br><span class="line">        </span><br><span class="line">        <span class="type">JcaX509v3CertificateBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JcaX509v3CertificateBuilder</span>(</span><br><span class="line">                issuer, serialNumber, notBefore, notAfter, subject, publicKey);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExtensionsGenerator</span> <span class="variable">extensionsGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtensionsGenerator</span>();</span><br><span class="line">        extensionsGenerator.addExtension(Extension.basicConstraints, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">org</span>.bouncycastle.asn1.x509.BasicConstraints(<span class="literal">true</span>));</span><br><span class="line">        builder.addExtension(Extension.basicConstraints, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">org</span>.bouncycastle.asn1.x509.BasicConstraints(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ContentSigner</span> <span class="variable">contentSigner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JcaContentSignerBuilder</span>(<span class="string">"SHA256withRSA"</span>).build(keyPair.getPrivate());</span><br><span class="line"></span><br><span class="line">        <span class="type">X509CertificateHolder</span> <span class="variable">certificateHolder</span> <span class="operator">=</span> builder.build(contentSigner);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JcaX509CertificateConverter</span>().setProvider(<span class="string">"BC"</span>).getCertificate(certificateHolder);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用工具类<code>CertificateGenerator</code>生成密钥对和自签名证书</p> <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootCertificateApp</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SpringApplication.run(SpringBootCertificateApp.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> CertificateGenerator.generateKeyPair();</span><br><span class="line">        <span class="type">X509Certificate</span> <span class="variable">certificate</span> <span class="operator">=</span> CertificateGenerator.generateCertificate(keyPair);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">keyOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"private.key"</span>)) {</span><br><span class="line">            keyOut.write(keyPair.getPrivate().getEncoded());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">certOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"certificate.crt"</span>)) {</span><br><span class="line">            certOut.write(certificate.getEncoded());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Certificate and private key generated successfully."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="TIPS-BUGS"><a href="#TIPS-BUGS" class="headerlink" title="TIPS/BUGS"></a>TIPS/BUGS</h2><h3 id="验证openssl-version时报错version-not-found"><a href="#验证openssl-version时报错version-not-found" class="headerlink" title="验证openssl version时报错version not found"></a>验证openssl version时报错version not found</h3><p>背景：在使用openssl version时出现<code>openssl: /lib/x86_64-linux-gnu/libcrypto.so.3: version OPENSSL_3.0.9' not found (required by openssl)</code></p><p>解决办法：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 更新</span></span><br><span class="line"><span class="built_in">sudo</span> apt upgrade openssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重装</span></span><br><span class="line"><span class="built_in">sudo</span> apt remove --purge openssl</span><br><span class="line"><span class="built_in">sudo</span> apt install openssl</span><br></pre></td></tr></tbody></table></figure><h3 id="加密时报错Could-not-read-public-key-from-mycert-crt"><a href="#加密时报错Could-not-read-public-key-from-mycert-crt" class="headerlink" title="加密时报错Could not read public key from mycert.crt"></a>加密时报错<code>Could not read public key from mycert.crt</code></h3><p>意思是在证书中读取不到公钥，这种情况就把公钥提取出来，再用公钥文件加密即可</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从证书中提取公钥</span></span><br><span class="line">openssl x509 -pubkey -noout -<span class="keyword">in</span> mycert.crt &gt; public.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">openssl pkeyutl -encrypt -pubin -inkey public.key -<span class="keyword">in</span> plaintext.txt -out encrypted.dat</span><br></pre></td></tr></tbody></table></figure><h3 id="openssl-genrsa-和openssl-genpkey-algorithm-rsa有什么区别"><a href="#openssl-genrsa-和openssl-genpkey-algorithm-rsa有什么区别" class="headerlink" title="openssl genrsa 和openssl genpkey -algorithm rsa有什么区别?"></a><code>openssl genrsa</code> 和<code>openssl genpkey -algorithm rsa</code>有什么区别?</h3><p>openssl pkey 更通用，可以处理多种私钥<br>openssl rsa  专门处理RSA密钥</p><p><a href="https://docs.openssl.org/master/man1/openssl-genpkey/#notes">openssl-genpkey - OpenSSL Documentation</a>明确指出应使用<code>genpkey</code>，而不是特定于算法的 <code>genrsa</code>：</p><blockquote><p> The use of the genpkey program is encouraged over the algorithm specific utilities because additional algorithm options and ENGINE provided algorithms can be used.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 中间件 </tag>
            
            <tag> OpenSSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划算法刷题记录</title>
      <link href="/posts/dp/"/>
      <url>/posts/dp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>所以动态规划中每一个状态一定是由上一个状态推导出来的。<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。【动规是由前一个状态推导出来的，而贪心是局部直接选最优的】</p><p>所以贪心解决不了动态规划的问题</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化【根据第2步判断】</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="一维入门"><a href="#一维入门" class="headerlink" title="一维入门"></a>一维入门</h2><h3 id="【简单】509-斐波那契数"><a href="#【简单】509-斐波那契数" class="headerlink" title="【简单】509. 斐波那契数"></a>【简单】509. 斐波那契数</h3><p><a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数 - 力扣（LeetCode）</a></p><p>分析：当前状态由前两个状态推出，可以使用动规</p><p>五步走：</p><ol><li>确定dp数组（dp table）以及下标的含义：dp[i]表示第i个数字为多少</li><li>确定递推公式：<code>dp[i] = dp[i-1] + dp[i-2]</code></li><li>dp数组如何初始化<ol><li>根据上一步进行初始化</li><li>注意题目也给了：dp[0] = 0,dp[1] = 1</li></ol></li><li>确定遍历顺序：dp[i] = dp[i-1] + dp[i-2]可知从前往后遍历</li><li>举例推导dp数组</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp  = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">         dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">         dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>⭐优化：我们只在乎dp[i] 、dp[i-1]、dp[i-2]三个数字，而不需要记录整个序列</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];    <span class="comment">// 数组大小改为2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) {  <span class="comment">// 更新dp</span></span><br><span class="line">            sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="【简单】70-爬楼梯"><a href="#【简单】70-爬楼梯" class="headerlink" title="【简单】70. 爬楼梯"></a>【简单】70. 爬楼梯</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></p><p>分析：主要是由每次可以爬1/2层推出递归公式 ＋ 初始化从1开始</p><p>五步走：</p><ol><li>确定dp数组（dp table）以及下标的含义：dp[i]表示第i层楼梯有多少种到达方式</li><li>确定递推公式：<code>dp[i] = dp[i-1] + dp[i-2]</code></li><li>dp数组如何初始化<ol><li>根据上一步进行初始化</li><li>注意题目也给了：dp[1] = 1,dp[2] = 2</li></ol></li><li>确定遍历顺序：dp[i] = dp[i-1] + dp[i-2]可知从前往后遍历</li><li>举例推导dp数组</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++){</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p> 同样可以优化空间，方法同509</p></blockquote><h3 id="【简单】746-使用最小花费爬楼梯"><a href="#【简单】746-使用最小花费爬楼梯" class="headerlink" title="【简单】746. 使用最小花费爬楼梯"></a>【简单】746. 使用最小花费爬楼梯</h3><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p><p>分析：看起来涉及到两个维度：阶梯数＆体力，但是这两个维度是联系的（也就是阶梯数对应体力）</p><p>五步走：</p><ol><li>确定dp数组（dp table）以及下标的含义：dp[i]表示到达第i层花费的最小体力</li><li>确定递推公式：<code>dp[i] = min(dp[i-1] + cost[i-1] , dp[i-2] + cost[i-2])</code>，也计算就是从第i-1层还是第i-2层跳到第i层花费体力小</li><li>dp数组如何初始化<ol><li>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯：dp[0] = 0,dp[1] = 0</li></ol></li><li>确定遍历顺序：由递推公式可知从前往后遍历</li><li>举例推导dp数组</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="comment">// ❗【这个很重要】 dp含义:dp[i],i表示阶梯数，dp[i]表示花费的总体力</span></span><br><span class="line">        <span class="comment">// 第二个要注意的就是第一级和第二级是不花费体力的，如果从这两级出发才用体力</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">2</span>) <span class="keyword">return</span> Math.min(cost[<span class="number">0</span>],cost[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=length;i++){</span><br><span class="line">            dp[i] = Math.min(dp[i-<span class="number">1</span>] + cost[i-<span class="number">1</span>] ,dp[i-<span class="number">2</span>] + cost[i-<span class="number">2</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[length];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>同样可以优化空间，方法同509</p></blockquote><h2 id="二维入门"><a href="#二维入门" class="headerlink" title="二维入门"></a>二维入门</h2><h3 id="【中等】62-不同路径"><a href="#【中等】62-不同路径" class="headerlink" title="【中等】62.不同路径"></a>【中等】62.不同路径</h3><p><a href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（LeetCode）</a></p><p>分析：<strong>当前点位置路径数 = 左侧位置路径数+上侧位置路径数</strong></p><p>五步走：</p><ol><li>确定dp数组（dp table）以及下标的含义：dp[i] [j]表示到达(i,j)的路径有多少条</li><li>确定递推公式：<code>dp[i] [j] = dp[i] [j-1] +dp[i-1] [j]</code></li><li>dp数组如何初始化<ol><li>dp[0] [0] = 0</li><li><strong>第一行和第一列都是1</strong></li></ol></li><li>确定遍历顺序：由递推公式可知从前往后遍历</li><li>举例推导dp数组</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="title function_">int</span> <span class="params">( m, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> &amp;&amp; n==<span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">            <span class="comment">// dp[i][j] 表示达到[i,j]处的路径数</span></span><br><span class="line">            <span class="comment">// 初始化，第一行和第一列都初始化成1</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) </span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历顺序：都可以</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>优化：状态压缩</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// [优化]：关于对角线对称，本质上就是杨辉三角</span></span><br><span class="line"><span class="comment">// 根据 dp[i][j]=dp[i−1][j]+dp[i][j−1]可以发现，只需要用到上一行和当前行的数据，而不需要之前所有行的数据</span></span><br><span class="line"><span class="comment">// 所以我们用一维数组就可以解决，dp[j] 表示从左边到达当前位置的路径数，dp[j - 1] 表示从上面到达当前位置的路径数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            dp[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="【中等】63-不同路径-II"><a href="#【中等】63-不同路径-II" class="headerlink" title="【中等】63. 不同路径 II"></a>【中等】63. 不同路径 II</h3><p><a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></p><p>分析：<strong>总体思路同上，遇到障碍物把当前路径数设为0就好了</strong></p><p>五步走：</p><ol><li>确定dp数组（dp table）以及下标的含义：dp[i] [j]表示到达(i,j)的路径有多少条</li><li>确定递推公式：<code>dp[i] [j] = dp[i] [j-1] +dp[i-1] [j];  </code><br><code>if(obstacleGrid[i] [j] == 0)   dp[i] [j]  = 0</code></li><li>dp数组如何初始化<ol><li>dp[0] [0] = 0</li><li><strong>第一行和第一列都是1</strong></li></ol></li><li>确定遍历顺序：由递推公式可知从前往后遍历</li><li>举例推导dp数组</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在起点或终点出现了障碍，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span> || obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>] = </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; </span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j</span><br><span class="line">            <span class="comment">// 碰到状态直接将状态设为0就可以了</span></span><br><span class="line">                dp[i][j] = (obstacleGrid[i][j] == <span class="number">0</span>) ? dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>优化：思路同62</p><p>顺带嘲笑一下脑子没转过弯来的自己</p><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/image-20240517143011162.png" alt="image-20240517143011162"></p></blockquote><h3 id="【中等】-343-整数拆分"><a href="#【中等】-343-整数拆分" class="headerlink" title="【中等】 343. 整数拆分"></a>【中等】 343. 整数拆分</h3><p><a href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分 - 力扣（LeetCode）</a></p><p>分析：一开始会一直纠结到底是分成两个数还是几个数，我们统一分成两个数</p><p>dp[i]有两种得到方式：</p><ol><li><p>直接拆分：j * (i - j)    【真正意义上的拆分成两个数】</p></li><li><p>继续拆分：j * dp[i - j] 【这个就相当于把i-j再进行拆分，也就包括了多个数的情况】</p></li></ol><p>五步走：</p><ol><li>确定dp数组（dp table）以及下标的含义：dp[i] 表示i可以被拆分的最大乘积</li><li>确定递推公式：<ol><li><code>dp[i] = max(dp[i] , max((i-j) * j , dp[i-j] * j))</code></li><li>两层max：里面的max是比较直接拆分和继续拆分的大小，外面的是把当前dp[i]和新的计算结果相比</li></ol></li><li>dp数组如何初始化：dp[2] = 1，0和1没有意义</li><li>确定遍历顺序：双层遍历</li><li>举例推导dp数组</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="comment">// dp[i]表示n=i时的最大乘积</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 递推公式 dp[i] = (i-j)*j【两个数】 / dp[i-j]*j【多个数】</span></span><br><span class="line">        <span class="comment">// 初始化：只用初始化dp[2]就行，0和1没有意义</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历顺序：i从3遍历到n</span></span><br><span class="line">        <span class="comment">// j表示分成的两个数，从1遍历到i/2【为什么不到i，因为对称（意会一下】</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n ; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++)</span><br><span class="line">                <span class="comment">// 还要再max一下，因为dp[i]时要不断把这个值和新的值进行比较更新</span></span><br><span class="line">                dp[i] = Math.max(dp[i],Math.max((i-j)*j,dp[i-j]*j));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="【中等】-96-不同的二叉搜索树"><a href="#【中等】-96-不同的二叉搜索树" class="headerlink" title="【中等】 96.不同的二叉搜索树"></a>【中等】 96.不同的二叉搜索树</h3><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></p><p>分析：额有点数学题，难度可以算半个困难了【推导过程见<a href="https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a>】</p><p>反正最后可以推出dp[i] += dp[j - 1] * dp[i - j]，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量 </p><p>五步走：</p><ol><li>确定dp数组（dp table）以及下标的含义： <strong>1到i为节点组成的二叉搜索树的个数为dp[i]</strong></li><li>确定递推公式：<ol><li><code>dp[i] += dp[j - 1] * dp[i - j]; </code></li><li><strong>j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</strong></li></ol></li><li>dp数组如何初始化：dp[0] = 1</li><li>确定遍历顺序：遍历i里面每一个数作为头结点的状态，用j来遍历。</li><li>举例推导dp数组</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="comment">// 主要是数学推导？</span></span><br><span class="line">        <span class="comment">// 递推公式：f(i)=G(i−1)∗G(n−i)</span></span><br><span class="line">        <span class="comment">// 以i为根节点的二叉搜索树的数量等于以i-1的总数的二叉搜索树的数量乘以以n-1的二叉搜索树的数量。</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化0个节点和1个节点的情况</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) {</span><br><span class="line">                <span class="comment">// 对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加</span></span><br><span class="line">                <span class="comment">// 一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j</span></span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/20210117171307407.png" alt="416.分割等和子集1"></p><p>对于面试，只需要掌握到01背包和完全背包就够了</p><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><p>题目：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>分析：</p><p>五步走：</p><ol><li><p>确定dp数组（dp table）以及下标的含义： <strong>即dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p></li><li><p>确定递推公式：<code>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</code></p><ol><li><strong>不放物品i</strong>：也就是dp[i - 1] [j]，即背包容量为j，里面不放物品i的最大价值，所以背包内的价值依然和前面相同。</li><li><strong>放物品i</strong>：也就是dp[i - 1] [j - weight[i]]  +  value[i] 推出<ol><li><code>dp[i - 1] [j - weight[i]]</code> 为背包容量为<code>j - weight[i]</code>的时候不放物品i的最大价值</li><li>那么<code>dp[i - 1] [j - weight[i]]</code>  + <code>value[i]</code> ，就是背包放物品i得到的最大价值</li></ol></li></ol></li><li><p>dp数组如何初始化：</p><ol><li><p>首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。</p><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/2021011010304192.png" alt="动态规划-背包问题2"></p></li><li><p>状态转移方程 dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p></li></ol></li><li><p>确定遍历顺序：</p><ol><li><strong>先遍历物品还是先遍历背包重量呢？</strong></li></ol></li><li><p>举例推导dp数组</p></li></ol><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><h2 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h2><h2 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让万物穿过自己</title>
      <link href="/posts/rwwcgzj/"/>
      <url>/posts/rwwcgzj/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【播客】让万物穿过自己"><a href="#【播客】让万物穿过自己" class="headerlink" title="【播客】让万物穿过自己"></a>【播客】让万物穿过自己</h1><p>刷到xhs说这一期很治愈就去听了</p><p>一边在图书馆一楼写数据库实验报告一边听 </p><p>可能是更多把注意力放在实验报告上了 </p><p>也可能是这期播客就是这种风格 </p><p>这一期听得挺平淡的 </p><p>感觉就是允许一切发生，坦然地面对所有 </p><p>心态已经从21年的想拼命卷到出人头地 </p><p>到现在的珍惜当下过好此刻就行 </p><p>虽然也还保持着之前卷的惯性 </p><p>但是也变得更加不在乎别人的看法了</p><p>所以也会直接在宿床下敲代码到两点多而不是在床上偷偷学 </p><p>可能也真的是前两年到处折腾累了吧 </p><p>总说青春和对青春的感悟无法同时拥有 </p><p>因为在这句话的青春是同一时间段的 </p><p>总得长大才能回忆以前的自己 </p><p>我还是可以拥有对这个时间段之前的感悟 </p><p>这就够了</p>]]></content>
      
      
      <categories>
          
          <category> 怎么认识这个世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么精英都是时间控</title>
      <link href="/posts/wsmsjdsjyk/"/>
      <url>/posts/wsmsjdsjyk/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="充分利用早上的大好时光，因为那是大脑的黄金时间"><a href="#充分利用早上的大好时光，因为那是大脑的黄金时间" class="headerlink" title="充分利用早上的大好时光，因为那是大脑的黄金时间"></a>充分利用早上的大好时光，因为那是大脑的黄金时间</h2><ol><li>早晨起床之后的大脑是最为清醒的，就像收拾后干净整洁的办公桌</li><li>上班最初的30min是最重要的<ol><li>比如说九点钟上班，对于日本人来说是开始准备上班（进行泡咖啡、查看邮件等活动），而对于美国人来说，九点是开始全力以赴投入工作了</li><li>早上的30min ≈晚上的2h</li></ol></li><li>几个轻松起床术<ol><li>早上冲个澡（通过提高体温、加快心跳、呼吸的速度，让控制身体从放松神经变成活动神经）</li><li>开着窗帘睡觉（阳光促进分泌血清素，不想起床的话就是血清素分泌不够）</li><li>睁眼5min（也是合成血清素）</li><li>有节奏的运动持续5min（散步、慢跑、上楼梯、扭脖子运动、广播体操、游泳、高尔夫球挥杆练习、深呼吸、大声朗读、发声练习、唱歌等）</li><li>细嚼慢咽吃早餐（吃一口，嚼20次再咽下去。咀嚼也算一种有节奏的运动，但是很多人为了吃得快节省时间，早餐大多数是牛奶、麦片等不需要咀嚼的东西，也难以刺激血清素的分泌）</li><li>早上一定不要看电视（你的话就是刷wb了），这会让往你的大脑塞进很多有用无用的信息，就想把很多资料、文件胡乱地堆放在办公桌上【为了让黄金之间持续更长时间，造成不要接收多余的信息，尽量与外界隔绝，专心工作】</li></ol></li><li>提前起床真的可以干很多事情<ol><li>上班第一件事情ToDoList【不然心里老是会惦记着接下来要干什么，就会有杂念】</li><li>优先处理最重要紧迫的事情</li></ol></li></ol><h2 id="把白天时间利用到极致的午后重启术"><a href="#把白天时间利用到极致的午后重启术" class="headerlink" title="把白天时间利用到极致的午后重启术"></a>把白天时间利用到极致的午后重启术</h2><ol><li>同样是提升血清素的三种方法：日光浴、有节奏的运动、咀嚼<ol><li>走出去晒太阳，在太阳下散步一段距离</li><li>在做有节奏的运动和咀嚼时，尽量不要同时使用语言机能【不要一边吃饭一边读书、说话、工作或思考太多问题】</li><li>咀嚼10min以上</li></ol></li><li>提高记忆力的“场所神经元”<ol><li>通过移动、改变场所，可以激发人脑活性<ol><li>场所神经元可以让我们记住自己在什么地方，它被激活后整个海马体都会活跃起来，记忆力也随之增强；来到陌生的地方，场所神经元就会异常活跃 ==》（推荐去不常去的餐馆</li><li>做出新奇的决定也有利于提高大脑的创造活力</li></ol></li></ol></li><li>午睡20-30min<ol><li>午睡前喝点咖啡或茶水，午睡后刚好发挥效力</li></ol></li><li>下班前的冲刺<ol><li>2-4点时人最不清醒的时候，但只要运动就可以恢复活力【快爬几层楼 / 慢慢深蹲10次】</li><li>更换场所，看看不一样的景色</li><li>除了创造性的工作，都可以作为穿插工作使用，用来转换心情，重启大脑</li><li>在感到疲惫前进行休息（就像在口渴前喝水）：45 + 5</li></ol></li><li>最不好的休息方法就是手机啦！<ol><li>人脑处理视觉信息要占用90%的机能，手机会让大脑兴奋，反而更得不到休息</li><li>采取闭目养神是最好的休息方式【没有视觉】，最重要得一个点就是头脑放空</li></ol></li><li>困意最强烈的时候就小睡一会，不要硬抗波谷，而是利用波谷的这段时间顺利进入清醒度上升的波形中</li><li>不要有“做不完的话就加班”的想法，这会让你的注意力难以集中</li><li>和自己约定“xx点前做完所有工作，然后xx点后去做一个不可更改的约定（如买了七点的电影票）”</li></ol><h2 id="把夜晚时间利用到极致的运动-睡眠重启术"><a href="#把夜晚时间利用到极致的运动-睡眠重启术" class="headerlink" title="把夜晚时间利用到极致的运动&amp;睡眠重启术"></a>把夜晚时间利用到极致的运动&amp;睡眠重启术</h2><h3 id="运动类"><a href="#运动类" class="headerlink" title="运动类"></a>运动类</h3><p>下午运动，但是不要运动过度（30min左右的有氧运动就够了）<br>运动还可以长寿诶！<br>四点左右人的体温较高，运动减肥效果最好<br>接近傍晚人运动的新陈代谢最旺盛<br>也要在睡觉前3个小时就结束运动<br>推掉社交去运动其实根本不会影响什么，应该让别人适应你，而不是你适应别人<br>先每周运动一次，再每周运动两次，循序渐进</p><h3 id="不让压力和疲惫过夜"><a href="#不让压力和疲惫过夜" class="headerlink" title="不让压力和疲惫过夜"></a>不让压力和疲惫过夜</h3><p>大多数人会以周调整工作和休息的平衡，一周就是一个生活周期<br>但是也可以考虑以天为生活周期，一天之内进行工作和休息的平衡【也就是不让压力和疲惫过夜的生活方式】</p><p>晚上可以通过交流进行恢复【人与人交流的时候，脑下垂体会分泌一种叫作“后叶催产素”的激素。后叶催产素被称为“爱的物质”。当脑内分泌后叶催产素的时候，人就会感到“爱和被爱的感觉”。】</p><p>把握好轻重缓急的节奏<br>白天重急，晚上轻缓（不然第二天无法到100%的专注力，那不是相当于白加班了吗？</p><p>离开公司，就不要再想工作的事情<br>（但是如果真的有人找怎么办诶🤔也不急你这么一点时间，完全可以摆完后再回</p><h3 id="对睡眠极好的生活习惯"><a href="#对睡眠极好的生活习惯" class="headerlink" title="对睡眠极好的生活习惯"></a>对睡眠极好的生活习惯</h3><p>睡前2个小时千万不能做的事情有吃东西、饮酒、剧烈运动、洗澡水水温过高、视觉系娱乐（玩电子游戏、看电影等）、看闪亮的东西（看手机、看电脑、看电视等）、待在灯光过于明亮的场所（特别是使用荧光灯的便利店、公司办公室等）。</p><p>反过来，睡前2个小时适宜享受放松。比如，听音乐、闻香薰灯、非视觉系娱乐、和家人聊天、爱抚宠物、使身体放松的轻微运动、温水浴、读书等。</p><p>睡前吃东西 —— 减少分泌生长激素 —— 不能消除疲劳 </p><h3 id="睡前15min运用好"><a href="#睡前15min运用好" class="headerlink" title="睡前15min运用好"></a>睡前15min运用好</h3><p>一天记忆中最牢固的时候，因为马上就钻进被窝睡觉了，不会产生任何记忆上的冲突<br>只要睡前记忆后不再输入多余的信息，不产生记忆冲突，这个记忆黄金时间完全可以延长</p><p>反面例子：睡前进行大量视觉性娱乐/琢磨今天的惨事</p><p>睡前想什么，你就会变成什么样的人【人在睡觉前会进入一种“心理暗示”的状态】<br>所以可以把今天发生的趣事想想，记录下来，发表在社交媒体上<br>经常这样做的话，“快乐的记忆”就会充满我们的大脑。以后回忆起来，过去的生活全都是幸福快乐的事，让我们的人生充满幸福感。</p><h3 id="周末不用刻意补觉"><a href="#周末不用刻意补觉" class="headerlink" title="周末不用刻意补觉"></a>周末不用刻意补觉</h3><p>如果周一感到郁闷，反而很有可能是因为周末睡了懒觉，养成了生物钟<br>（周末11点起平时8点起，相当于8点起再让你5点起，当然会困困的啦</p><p>储备睡眠【现在有时间就睡个够，储备睡眠为以后忙的时候做准备】是不合理的<br>一天的疲惫就在当天消除掉</p><p>平时睡眠不足，周末睡得再多也没用</p><ol start="6"><li>生长激素恢复术</li></ol><p>越是疲惫的时候越是要去运动<br>（注意是运动产生生长激素让你消除疲惫，不是运动让你疲惫<br>【推荐连续1个小时以上的有氧运动，快走、慢跑、游泳、徒手有氧训练、球类运动等】</p><p>疲劳是指反复使用肌肉或者大脑的同一部位，由于过度使用而产生累的感觉。<br>==》互补，周末进行和工作也不同类型的活动</p><p>每天有规律地做同样的事情：反复使用肌肉或者大脑的同一部位，由于过度使用而产生累的感觉。</p><h2 id="充分利用工作时间"><a href="#充分利用工作时间" class="headerlink" title="充分利用工作时间"></a>充分利用工作时间</h2><p>一般思维：把时间看作“消耗品”，使用完就没了<br>作者思维：把时间看作“创造品”，时间生时间</p><h3 id="for-you-工作术"><a href="#for-you-工作术" class="headerlink" title="for you 工作术"></a>for you 工作术</h3><p>为别人着想，珍惜别人的时间【❌不好意思来晚了，之前的工作耽误了一会】</p><p>”和人有约的时候，对方发来一条短信：‘不好意思，我要迟到10分钟。’结果对方往往会被谅解，我们还会回复一条短信：’不着急，慢慢来。‘似乎这已经成为一种习惯。但非常遗憾的是，这绝对是一种恶劣的习惯。”</p><p>提前半个小时来到约会地点，这半个小时你可以干自己的事情<br>如果对方提前10min到场，你们就可以提前10min结束<br>如果对方迟到10min到场，你也可以多工作10min</p><p>大部分讲师的讲座都会比预定时间晚几分钟甚至十几分钟才开始，这是对准时达到听众的不尊重</p><p>我们如果能在别人心目中留下“守时的人”的印象，无疑可以提高别人对我们的信任度</p><h3 id="趁现在-工作术"><a href="#趁现在-工作术" class="headerlink" title="趁现在 工作术"></a>趁现在 工作术</h3><p>马上就能做完的工作，一定不要往后拖，趁热打铁现在就把它处理完。【2min能做完的就马上完成】</p><p>日常工作中的决断，只需30秒思考就可以了。【灵感闪现”或“直觉”的正确率是相当高的。思考再长的时间，也不会得到更好的判断。】</p><p>有些决定30s无法决定，那就设置决断时间。【这样一来，在真正做决断之前的这段时间里，我们就不用再翻来覆去地思考这件事情了。】</p><p>不是“到什么时间为止”而是“什么时间做”【但很多人在推迟工作时间的时候，都会以“到××时间为止”的形式设定期限。因为没有设定什么时候开始做，所以往往到期限的时候，依然没有做完。】</p><p>立即就预约</p><ul><li>一旦说出“回头再联络”，日后对方再次联络我们的概率就很低了。那么现在这10分钟、15分钟的交流，就成了美丽的肥皂泡，很快就破灭了。</li><li>即使对方真的和我们联络了，也要通过反复多次互发邮件、短信，花很长时间才能协调好彼此的时间，确定会面时间和场所。</li><li>而且如果真的想和你详谈的话，如果你定下时间，他也会很乐意去安排；但如果不感兴趣就会开始推辞。这也算一种高级的心里技巧</li></ul><p>善于把握现在的人，大多也是“趁现在”工作术的实践者。类似“做，还是不做？”“参加，还是不参加？”的问题，他们立刻就能做出决断，要做的话，马上就能定下时间。和这样的人一起工作，我能感受到工作中的速度感，很带劲。<br>善于“把握现在”的人，会在第一时间回复我的邮件或短信，他们的工作保证按时完成，而且质量相当高且细致。和这样的人合作，我们都会相互尊重对方的时间，工作起来很舒心。</p><h3 id="并行-工作术"><a href="#并行-工作术" class="headerlink" title="并行 工作术"></a>并行 工作术</h3><p>乘地铁、泡澡、散步等非常简单、机械的动作，就可以同时进行学习、工作或思考</p><p>设定目标之后，人体就会分泌多巴胺，从而增强实现目标的动机，提高专注力，学习效率和效果也会随之提升。</p><p><strong>读书：</strong>读书之后一定要有输出：用3个要点来总结这本书带给您的收获，每一点只需写一行字就够了。用这种方法为一本书写读后感，只需3分钟即可。<br><strong>耳学</strong>：播客等等<br><strong>思考</strong>：每天早晨起床后，洗澡前，我会先给自己设定一个思考的主题，比如“今天的网络杂志该写些什么呢？”。<br>上厕所的时间、从家走到地铁站的时间、从乘上地铁到下车的时间。</p><h2 id="自由时间"><a href="#自由时间" class="headerlink" title="自由时间"></a>自由时间</h2><h3 id="自由时间不要用来工作！"><a href="#自由时间不要用来工作！" class="headerlink" title="自由时间不要用来工作！"></a>自由时间不要用来工作！</h3><p>我们首先应该把每天的工作时间限定在9个小时，不要加班，然后考虑该如何在固定的时间里做尽量多的工作。如何提高工作的效率、密度、质量和精度才是重点。</p><h3 id="投资自己"><a href="#投资自己" class="headerlink" title="投资自己"></a>投资自己</h3><ol><li>投资自己的主要专长【那不就是工作吗？？或者是非工作的学习，像你现在在学习juc，但是目前的工作是不需要用到juc的】</li></ol><p>工作技巧一旦掌握，就会陪伴我们一生。</p><ol start="2"><li>投资“短期投资”  ==》锻炼也是一种投资哇</li></ol><h3 id="主动性娱乐"><a href="#主动性娱乐" class="headerlink" title="主动性娱乐"></a>主动性娱乐</h3><p>多读书【主动性娱乐，需要专注力、设定目标并不断提高技巧】相当于锻炼专注力，而看太多电视【被动性娱乐】只能分散专注力。</p><ul><li><p>把想看的东西录下来，这样就能防止一不小心又跳到不想看的东西。实际操作起来您还会发现，录之前可能对这个节目非常期待，特别想看。可是录好之后，那种强烈的欲望已经变淡了。录像带放在那里，日后不知道还会不会看。【sos好像b站的稍后再看】</p></li><li><p>把看电视变成主动性娱乐【有输出——就会变专注】<br>和朋友聚会喝酒——主动聊一些深入的话题，交流思想，再记下来<br>把输出变成一种习惯，那么您的被动性娱乐都能转化为主动性娱乐，原本浪费的时间也就变成了自我投资的时间，您也能得到更快的成长。</p></li></ul><h3 id="改变人生的放松时间"><a href="#改变人生的放松时间" class="headerlink" title="改变人生的放松时间"></a>改变人生的放松时间</h3><p>工作中的专注力和玩乐中的专注力，从性质上来说是一致的。在爱好或玩乐中能够发挥100%专注力的人，在工作中也能发挥100%的专注力</p><p>“痴迷于兴趣爱好之中”其实是锻炼专注力的最好方法。因为真心喜欢，我们才会忘记时间、忘记自我，不觉得辛苦，也只有这样才能发挥出最高的专注力和潜能</p><p>首先要了解自己最快乐的瞬间是什么时候，然后不断增加这样的瞬间，人生就会越来越幸福！  ==》<br>一个时间段干完了很多事情！<br>代码一次跑通没bug！<br>找到可以学习的新地方<br>吃完饭边听歌边散步！<br>散完步回来后看书整理笔记！<br>看别人的博客or语雀空间，学习人生哲学！<br>打羽毛球！<br>举哑铃！<br>晚上和阿白唠嗑！</p><p>为了未来，“忍受”现在的人，一生都会在“忍受”中度过。<br>制作玩乐TODO清单</p><p>【突然发现日本的很多这种书都会以美国人为学习/比较例子，这也算一种时代影响吧】</p>]]></content>
      
      
      <categories>
          
          <category> 怎么认识这个世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>掌控习惯</title>
      <link href="/posts/zkxg/"/>
      <url>/posts/zkxg/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>缓慢的转变速度让好习惯难以保持，也让坏习惯驻留不去</li><li>忽略目标只关注体系还是能成功，但是反过来却不行</li><li>你毫无必要认定只有某个特定场景的出现，才能让你对自己的人生感到满意…当你爱上过程而不是结果时，你不必等待容许自己享受快乐的那一刻的到来。只要你创建的体系在正常运行，你就会在整个过程中感受到快乐</li><li>身份——过程——结果。基于结果重点在于你想要达到的目标；基于身份重点在于你想成为谁</li><li>在戒烟vs不抽烟了</li><li>与身份不相符的行为不会持续太久</li><li>决定你想成为哪类人——用小赢证明自己【通过结果回推什么样的人才能得到这些结果】</li><li>基于身份的习惯   反馈回路</li><li>习惯不是为了让你获得什么，而是为了让你成为什么样的人</li></ol><p><a name="WjtPX"></a></p><h3 id="第三章：培养良好习惯的四步法"><a href="#第三章：培养良好习惯的四步法" class="headerlink" title="第三章：培养良好习惯的四步法"></a>第三章：培养良好习惯的四步法</h3><p>提示——显而易见<br>渴求——有吸引力<br>反应——简便易行<br>奖励——令人愉悦</p><p>习惯不会限制自由，它们会创造自由</p><ul><li>如果缺乏良好的理财习惯，你将永远为生计苦苦挣扎</li><li>没有良好的健康习惯，你似乎总会觉得肾虚气短</li><li>没有良好的学习习惯，你会觉得自己跟不上时代进步前进的步伐</li></ul><p>如果你总是被迫做简单的决定，诸如我改什么时候去健身，我去哪里写文章比较好等等，你自由支配的时间相对应的就会减少<br>只有让生活的基本要素变得容易，你才能创造自由思考和创造力需要的精神空间</p><p><a name="KSQKt"></a></p><h2 id="第一定律：让它显而易见"><a href="#第一定律：让它显而易见" class="headerlink" title="第一定律：让它显而易见"></a>第一定律：让它显而易见</h2><p><a name="HQOna"></a></p><h3 id="第四章：看着不对劲的那个人"><a href="#第四章：看着不对劲的那个人" class="headerlink" title="第四章：看着不对劲的那个人"></a>第四章：看着不对劲的那个人</h3><p>除非你让下意识意识化，否则他将支配你的生活，而你称之为命运<br>说出你的行动，指差确认将你的意识程度从下意识地习惯状态提升到警觉地水平</p><p><a name="QOgdn"></a></p><h3 id="第五章：培养新习惯地最佳方式"><a href="#第五章：培养新习惯地最佳方式" class="headerlink" title="第五章：培养新习惯地最佳方式"></a><strong>第五章：</strong>培养新习惯地最佳方式</h3><p>执行意图：<br>一旦设定了执行意图，你就不必等待灵机一动地那一刻。我今天该不该写再写一章？我今天该在早上还是午餐时间打坐？当行动的时刻到来时，根本就不需要再做决定，简单的按照你的预定计划去做即可</p><p>当你的梦想模糊不清的时候，你很容易整天任由时间耗费在一些琐事上，无暇顾及为了取得成功而必须做的具体事宜，并且总是能给自己这种状态找借口</p><p>习惯叠加：是执行意图时的一种特殊形式。与其在特定的时间和地点培养新习惯，不然将它与当前习惯整合</p><ul><li>起床、洗澡、刷牙、穿好衣服、吃早餐、工作日开始结束、吃午晚饭、关灯、上床睡觉</li></ul><p><a name="F9xWu"></a></p><h3 id="第六章：原动力被高估，环境往往更重要"><a href="#第六章：原动力被高估，环境往往更重要" class="headerlink" title="第六章：原动力被高估，环境往往更重要"></a><strong>第六章：</strong>原动力被高估，环境往往更重要</h3><p>行为时环境中人的函数<br>如果想让习惯成为你生活中的重要组成部分，就让提示成为你生活中环境中的重要组成部分</p><p><a name="oSA8g"></a></p><h2 id="第七章：自我控制的秘密"><a href="#第七章：自我控制的秘密" class="headerlink" title="第七章：自我控制的秘密"></a>第七章：自我控制的秘密</h2><p>自我控制力强的人通常最不需要使用它，因为他们会尽量远离充满诱惑的环境，逃避诱惑比抗拒诱惑容易</p><p>坏习惯具有自身催化的能力：这个过程会自我滋养，他们一边激发人们的某些感觉一边麻痹他们。看电视会让你感到慵懒，于是你会看更多电视，因为你打不起精神去做其他任何事情，你担忧自己的健康状况，于是你通过吸烟来缓解焦虑情绪，这反过来会让你的健康状态更加糟糕，不久后你会感到更焦虑…</p><p>提示：</p><ol><li>填写习惯记分卡，记下你当前的习惯并留意他们</li><li>应用执行意图，我将于[时间]在[地点][行为]</li><li>应用习惯叠加，继[当前习惯]之后，我将会[新习惯]</li><li>设计你的环境，让好习惯的提示清晰明了</li></ol><p><a name="KYxqz"></a></p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>当你获得奖励时，大脑中激活的奖励系统与你期待奖励时激活的系统是同一个，这就是对一种体验的期待往往比体验本身，更令人感到愉悦的原因之一。作为一个成年人，憧憬即将到来的假期或许比度假本身更令人激动。科学家称之为“渴求”和“喜欢”之前的区别。</p><p>绑定喜好的工作原理，就是把你需要做的事与原意做的事绑定<br>正式对奖励的期待，而不是奖励本身，促使我们采取行动。预期越高，多巴胺峰值越大</p><p><a name="InnfX"></a></p><h2 id="第九章-在习惯中"><a href="#第九章-在习惯中" class="headerlink" title="第九章 在习惯中"></a>第九章 在习惯中</h2><p>培养好习惯的最有效方式之一就是加入一种文化，在这种文化中，你偏爱的行为被认定为是正常行为。所以尽量和那些具备你想拥有的习惯的人在一起，你们会相互促进。<br>没有什么比群体归属感更能维持一个人做事的动力了。<br>但是一旦我们融入集体，我们就开始寻找脱颖而出的途径</p><p><a name="hvNLv"></a></p><h2 id="10-如何找到并消除你坏习惯的根源"><a href="#10-如何找到并消除你坏习惯的根源" class="headerlink" title="10 如何找到并消除你坏习惯的根源"></a>10 如何找到并消除你坏习惯的根源</h2><p>你的习惯其实是用以满足古老欲望的现代方法，也就是旧恶习的新形式，隐藏在人类行为背后的潜在动机一致没变。我们的特定习惯随历史阶段的不同而有所演变。<br>但有许多不同的方法来满足相同的潜在动机。一个人可能会通过吸烟缓解情绪，另一个人通过跑步减轻焦虑。你么前的习惯不一定是解决你面临的问题的最佳方式；它们只是你掌握的方法。一旦你把一个解决方案和你需要解决的问题联系起来，你就会不断地反复加以应用。</p><p>每当一个习惯成功满足一个动机，你就会产生一种再次尝试地渴望。经过一段时间的操作，你了解到原来浏览社交媒体会帮助你感受到爱，或者观看B站上的视频会让你忘记恐惧。当我们将习惯与积极地情感联系起来时，习惯就有了吸引力，我们有了这种认识就可以为己所用，不断寻求乐趣，同时避免烦心事</p><p>如果你能学会将高难度的习惯和记记的内心体验联系起来，你就能使他具备吸引力，有时候只需要稍微改变一下心态，不是“得”而是“想”做那些事…如果我们从正面解读赛前紧张感受，就能以流畅和优雅的方式做出回应，可以将“我很紧张”定义为“我很兴奋，肾上腺素的增加帮助我集中注意力。”<br>这些小小的思维定式并不神奇，但它们可以帮助你改变与特定习惯或情况相关联的感觉</p><p><a name="e4Nsl"></a></p><h2 id="11-漫步前行-但绝不后退"><a href="#11-漫步前行-但绝不后退" class="headerlink" title="11 漫步前行 但绝不后退"></a>11 漫步前行 但绝不后退</h2><p>试图找到最佳转变方便的努力，比如试图寻找减肥捷径，强身健体的最优方案，以及开展副业的好点子等，很容易陷入困境。我们一门心思地想要找到做事的最佳方案，却从来也不付诸行动。对此伏尔泰这样写道：因追求最佳而丢掉了足够好</p><p>酝酿意味着你在计划、策划和学习。这些都是好东西，但是它们不会产生结果（我抄他吗的，想越想越多问题，做越做做多方法<br>如果酝酿并不能带来结果，我们为什么还要这么做？有时我们这样做是因为我们确实需要计划或者了解更多情况，但通常我们这样做的理由是它可以让我们感觉自己在取得进展，同时又不必承担失败的风险。我们大多数人都是回避批评的专家，遭遇失败或被公开批判令人感觉不好，所以我们倾向于避免落入那种境地。这就是你总是酝酿却不采取行动的最大原因：你是想让遭遇的失败来得晚一些。</p><p>养成新习惯的最关键步骤之一就是不断重复<br>就习惯的培养而言，不在于时间长短。不管你连续做了21天，20天还是300天，重要的是你这种行为的频率。你可以在30天内做两次，或者200次，起决定性作用的是频率。</p><p><a name="kHWgT"></a></p><h2 id="12-最省力法则"><a href="#12-最省力法则" class="headerlink" title="12 最省力法则"></a>12 最省力法则</h2><p>当我们消除消耗我们时间和精力的阻力点是，我们就能取得事半功倍的效果（这就是整理房间让人感觉非常好的一个原因：我们减轻了环境施予我们的认知负荷，从此可以轻装前进了）</p><p>看完电视后就会把遥控器放回电视机架上，整理好沙发上的靠垫，并把毛毯折叠起来。在他下车后，就会随手扔掉车上的全部垃圾；每当洗澡的时候，都会加热水的间隙擦洗马桶…”每当我走进一个房间，一切都尽然有序，因为我每天都在每个房间这样做，所以房间内的各种东西都各安其位……人们认为我很勤劳，可实际上我很懒，我只是创造一个将来可以偷懒的条件。这样做会还给你很多时间。”</p><p>反之，如果每次看点电视就拔下电源插头，并取出遥控器里的电池，这样以来下次再看时至少需要额外的10秒才能打开，也可以把电视机从客厅搬到壁橱……一件事做起来越麻烦，你越不可能想要继续做<br><a name="JuJxk"></a></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p><a name="WwKbl"></a></p><h2 id="习惯记分卡"><a href="#习惯记分卡" class="headerlink" title="习惯记分卡"></a>习惯记分卡</h2><ol><li>早起再睡一会</li><li>起床去刷牙，并且拿上收集</li><li>刷完牙开始工作</li><li>工作累了玩会手机</li><li>工作需要等待的时候看微信消息或玩手机</li><li>一整个上午都坐在显示屏前不怎么动</li><li>中午大约11.30散步去陶园吃饭</li><li>吃完饭要绕校园散会步</li><li>回到宿舍后刷B站</li><li>中午会午休10-20分钟</li><li>下午同上午工作状态</li><li>上课的话会坐后排干自己的事情，但效率都比较低</li><li>不经常喝水</li><li>物品在桌面上随意放置</li><li>很晚洗澡</li><li>有时会带ipad上床，这种情况一般一点半后才会睡觉</li><li>早上六点多会醒一次，然后继续睡去</li><li>会习惯列时间线todolist</li><li>习惯带手机上床</li><li>没有按照todolist完成任务会很焦虑地往后退任务或者乱搞任务</li></ol>]]></content>
      
      
      <categories>
          
          <category> 怎么认识这个世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析 JWT</title>
      <link href="/posts/jwt/"/>
      <url>/posts/jwt/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>对jwt总是一知半解，而且项目打算写个关于JWT登录的点，所以总结关于JWT的知识及面试考察过的点</p><p>参考资料：</p><p><a href="https://blog.csdn.net/kagurawill/article/details/103764296?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-103764296-blog-136887367.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-103764296-blog-136887367.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;utm_relevant_index=1">Cookie、Session、Token、JWT_通俗地讲就是验证当前用户的身份,证明-CSDN博客</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程 - 阮一峰的网络日志</a></p><p><a href="https://cloud.tencent.com/developer/article/2231547">https://cloud.tencent.com/developer/article/2231547</a></p><p><a href="https://developer.aliyun.com/article/995894#slide-0">JWT详细讲解(保姆级教程)-阿里云开发者社区</a></p><p><a href="https://blog.csdn.net/weixin_43973161/article/details/127012976">JWT双令牌(双token)实现登录验证_双token三验证-CSDN博客</a></p></blockquote><h1 id="零、前置知识"><a href="#零、前置知识" class="headerlink" title="零、前置知识"></a>零、前置知识</h1><p>cookie、session、token的区别</p><p>cookie：用于在客户端存储会话信息，并在之后每个请求中都会通过HTTP头部再将cookie发给服务器 ==》对于敏感信息不安全（跨站脚本、跨站请求伪造）</p><p>session：是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中，然后请求服务器的时候只发送Sessionid==》用户量特别大时，服务器容易分配。 </p><p>token：可以存储在客户端或者服务器端，具体取决于实现方式。常见的做法是将 Token 存储在客户端，比如在 localStorage、sessionStorage 或者浏览器的内存中。///无状态///可拓展性强，可以包含任何信息</p><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><ul><li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><p>为什么session比cookie安全？</p><p>可被篡改性：Cookie 存储在客户端，可以在客户端被修改。相比之下，Session 数据通常存储在服务器端，攻击者无法直接修改。</p><p>可被窃取性：同上</p><p>持久性：这意味着即使用户关闭浏览器，这些 Cookie 也会被保存在用户的设备上。长时间的持久性可能增加了攻击者窃取 Cookie 的机会</p><h3 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h3><ul><li>Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。</li><li>而 Token 是访问资源接口（API）时所需要的资源凭证，使服务端无状态化，不会存储会话信息。</li></ul><h1 id="一、出现背景"><a href="#一、出现背景" class="headerlink" title="一、出现背景"></a>一、出现背景</h1><p>在传统的 Web 开发中，为了保持用户的会话状态，通常会使用基于 cookie 和 session 的方式保存相关数据，如用户角色、登陆时间。但也有一些问题，比如跨域资源共享（CORS）和无状态（Stateless）服务。</p><p>如果是服务器集群或者需要CORS的架构，要求session数据库共享</p><p>解决办法：</p><ol><li>session数据持久化——写到数据库或者别的持久层，工程量较大；稳定性不高，持久层挂了就会单点失败</li><li>服务器不保存session数据，数据保存在客户端，每次请求带上发回给服务器</li></ol><p><strong>JSON Web Token（缩写 JWT）是2方案的一个代表，是目前最流行的跨域认证解决方案</strong></p><table><thead><tr><th>基于session的认证流程</th><th>基于JWT的认证流程</th></tr></thead><tbody><tr><td>用户在浏览器中输入用户名和密码，服务器通过密码校验后生成一个session并保存到数据库服务器为用户生成一个sessionId，并将具有sesssionId的cookie放置在用户浏览器中，同时 Cookie 记录此 SessionID 属于哪个域名，在后续的该域名的请求中都将带有这个cookie信息进行访问服务器获取cookie，通过获取cookie中的sessionId查找数据库判断当前请求是否有效</td><td>用户在浏览器中输入用户名和密码，服务器通过密码校验后生成一个token并保存到数据库前端获取到token，存储到cookie或者local storage中，在后续的请求中都将带有这个token信息进行访问服务器获取token值，通过查找数据库判断当前token是否有效</td></tr></tbody></table><h1 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h1><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>JWT 的原理基于三部分组成：Header、Payload 和 Signature。它们通过点（<code>.</code>）连接在一起，形成一个紧凑的字符串，可以通过 URL、POST 参数或 HTTP 头部发送。</p><ol><li>Header：包含了两部分信息：令牌的类型（即JWT），以及所使用的签名算法（例如HMAC SHA256或RSA）。</li><li>Payload：存放着声明（claims），即关于实体（通常是用户）和其他数据的信息。Payload包含了一些预定义的标准声明（如issuer、subject、audience等），同时也可以包含自定义的声明。</li><li>Signature：用于验证消息的完整性的签名部分。它由将编码的 header、payload 和一个秘密（例如，使用 HMAC 算法时的密钥）进行签名生成。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/asynccode" alt="img"></p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><ol><li><code>Header</code>部分是一个 JSON 对象，描述 JWT 的元数据,使用 Base64URL 算法转成字符串</li></ol><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"alg"</span><span class="punctuation">:</span> <span class="string">"HS256"</span><span class="punctuation">,</span>  <span class="comment">// 签名算法</span></span><br><span class="line">    <span class="attr">"typ"</span><span class="punctuation">:</span> <span class="string">"JWT"</span>     <span class="comment">// 令牌类型</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><ol><li><code>Payload</code>:服务器认证以后，生成一个 JSON 对象用来存放实际需要传递的数据，再使用 Base64URL 算法转成字符串</li></ol><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// JWT 规定了7个官方字段供选用，也可以定义私有字段</span></span><br><span class="line">- iss (issuer)：签发人</span><br><span class="line">- exp (expiration time)：过期时间</span><br><span class="line">- sub (subject)：主题</span><br><span class="line">- aud (audience)：受众</span><br><span class="line">- nbf (Not Before)：生效时间</span><br><span class="line">- iat (Issued At)：签发时间</span><br><span class="line">- jti (JWT ID)：编号</span><br><span class="line"></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"姓名"</span><span class="punctuation">:</span> <span class="string">"张三"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"角色"</span><span class="punctuation">:</span> <span class="string">"管理员"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"到期时间"</span><span class="punctuation">:</span> <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><ol><li><code>Signature</code>:通过将 Base64 编码后的 Header 和 Payload 与一个秘密（例如，使用 HMAC 算法时的密钥）进行签名生成的。 指定一个密钥，密钥只有服务器知道，然后使用 Header 里面指定的签名算法alg算出签名</li><li>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。此后，客户端每次与服务器通信，都要带上这个 JWT(也可以放在HTTP请求头信息里的<code>Authorization</code>字段,方便跨域)</li></ol><h1 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h1><p>参考：<a href="https://blog.csdn.net/weixin_43973161/article/details/127012976">JWT双令牌(双token)实现登录验证_双token三验证-CSDN博客</a></p><p>双令牌：无感登录刷新</p><ol><li>access_token  泄露概率比较大</li><li>refresh_token 泄露概率比较小,只有每次access_token  失效时才会使用它,所以二者组合可以很好的避免token泄露带来的安全风险,同时又能保证用户体验</li><li>userService的login方法<ol><li>保存refresh token到数据库</li><li>access token返回给前端</li></ol></li><li>刷新accessToken</li></ol><p>当短时间的token过期，前端需要通过长时间的token来访问后端，并且生成一个短时间的token返回给前端，也就是刷新短时间的token。</p><ol><li>删除refreshToken</li></ol><p>当用户退出的时候我们需要删除数据库中的refreshToken。</p><h1 id="四、相关面试题（来源牛客）"><a href="#四、相关面试题（来源牛客）" class="headerlink" title="四、相关面试题（来源牛客）"></a>四、相关面试题（来源牛客）</h1><h2 id="TODO-为什么token要放在redis"><a href="#TODO-为什么token要放在redis" class="headerlink" title="TODO:为什么token要放在redis"></a>TODO:为什么token要放在redis</h2><h2 id="1-jwt的token怎么生成的-jwt的参数是什么样的，有什么意义"><a href="#1-jwt的token怎么生成的-jwt的参数是什么样的，有什么意义" class="headerlink" title="1. jwt的token怎么生成的?/jwt的参数是什么样的，有什么意义"></a>1. jwt的token怎么生成的?/jwt的参数是什么样的，有什么意义</h2><p>由三个部分组成：Header、Payload 和 Signature。其中，Header 和 Payload 部分是基于 Base64 编码的 JSON 对象，而 Signature 是通过对 Header 和 Payload 进行签名生成的。</p><p>+运行流程</p><h2 id="2-jwt-是明文的吗？"><a href="#2-jwt-是明文的吗？" class="headerlink" title="2. jwt 是明文的吗？"></a>2. jwt 是明文的吗？</h2><p>Header 和 Payload 是基于 BaseURL64 编码的 JSON 对象，明文存放的</p><p>Signature 是加密的，但是它主要适用于验证JWT的真实性防止被篡改，不存放信息</p><p>所以整体来说，JWT还是明文的</p><h2 id="3-JWT用到了什么摘要算法"><a href="#3-JWT用到了什么摘要算法" class="headerlink" title="3. JWT用到了什么摘要算法"></a>3. JWT用到了什么摘要算法</h2><p>摘要算法：摘要算法又称哈希算法、散列算法。它通过一个函数，<strong>把任意长度的数据转换为一个长度固定的数据串</strong>（通常用16进制的字符串表示）。</p><p>要注意摘要算法<strong>不是加密算法</strong>，不能用于加密（因为无法通过摘要反推明文），<strong>只能用于防篡改</strong>。</p><p>SHA256是一种哈希算法，用于将任意长度的输入数据转换成固定长度的输出（256 位，即 32 字节）</p><p>工作原理：</p><ol><li>填充数据：首先SHA256 将输入数据填充至满足特定要求的长度，通常在数据末尾添加比特位，以确保数据长度满足要求。</li><li>分块处理：将填充后的数据按照固定长度分割成多个块，每个块的长度为 512 比特。</li><li>初始哈希值：设定初始的 256 比特哈希值，作为计算的起始点。</li><li>迭代运算：对每个块进行迭代运算，结合前一个块的哈希值，计算得到新的哈希值，直到处理完所有块。</li><li>输出结果：将最后一个块计算得到的哈希值作为最终的 SHA256 哈希值输出。</li></ol><p>特点：</p><ul><li><strong>固定长度输出</strong>：SHA256 输出固定长度的哈希值，即使输入数据的长度不同，输出的哈希值长度仍然相同。</li><li><strong>不可逆性</strong>：SHA256 是一种单向哈希函数，即无法通过哈希值反推出原始数据，保证了数据的安全性。</li><li><strong>抗碰撞性</strong>：SHA256 具有较高的抗碰撞性，即使对不同的输入数据计算得到相同的哈希值的可能性极低，保证了数据的唯一性和完整性。</li></ul><h2 id="4-可以使用md5摘要算法吗？"><a href="#4-可以使用md5摘要算法吗？" class="headerlink" title="4. 可以使用md5摘要算法吗？"></a>4. 可以使用md5摘要算法吗？</h2><p>MD5 摘要算法不建议用于 JWT 的签名，因为 MD5 已经被证明不安全，容易受到碰撞攻击。碰撞攻击是指攻击者能够生成两个不同的输入，但产生相同的哈希值。</p><p>为什么选sha256不选md5</p><ol><li>摘要长度：SHA256 生成的摘要长度（256 比特）比 MD5 长度（128 比特）更长，因此具有更大的输出空间，更难以发生碰撞（即两个不同的消息产生相同的摘要）。</li><li>算法结构：SHA256 是基于 Merkle–Damgard 结构的散列函数，而 MD5 是基于 MD4 结构的。SHA256 的算法结构更为复杂，使用了更多的轮次和更复杂的运算，提高了其抵抗碰撞攻击的能力。</li><li>算法安全性：MD5 算法在安全性上存在一些漏洞，如碰撞攻击、预图片攻击等，已经被证明不再安全。而 SHA256 目前尚未出现有效的攻击方法，因此被认为更安全。</li></ol><h2 id="5-了解RAS算法吗？"><a href="#5-了解RAS算法吗？" class="headerlink" title="5. 了解RAS算法吗？"></a>5. 了解RAS算法吗？</h2><p>rsa是一种非对称加密算法，数据可以使用公钥进行加密，然后只有持有相应私钥的一方才能解密该数据。反之，数据也可以使用私钥进行签名，然后任何持有相应公钥的一方都可以验证该签名。</p><p>在JWT的应用：私钥用于生成签名，而公钥用于验证签名。这样即使公钥泄露，攻击者也无法伪造有效的签名，从而确保了 JWT 的安全性。</p><blockquote><p>我趣那不是又能深入到对称加密和非对称加密</p><p>对称加密：相同密钥、快速高效</p><p>非对称加密：不同密钥、安全性较高</p></blockquote><h2 id="6-base64算法？base64的流程是什么？"><a href="#6-base64算法？base64的流程是什么？" class="headerlink" title="6. base64算法？base64的流程是什么？"></a>6. base64算法？base64的流程是什么？</h2><p>Base64 编码算法：Base64 算法将二进制数据编码成文本字符串，但并不对数据进行加密或者隐藏。它的主要目的是将二进制数据转换成纯文本格式，以便于传输或者存储。【24位转32位】</p><ol><li>把数据按照24位（3 字节）为一组进行划分</li><li>转成ASCII编码——转成二进制编码（24位）——每6位一组转成十进制（4个数字）——转成对应的ASCII编码——转成二进制（32位）</li><li>如果输入数据的长度不是 3 的整数倍，则需要添加一定数量的填充字符 “=”，使得每个 24 位的组都能够被正确地转换成四个 Base64 字符。</li></ol><p><a href="https://blog.csdn.net/qq_19782019/article/details/88117150">https://blog.csdn.net/qq_19782019/article/details/88117150</a></p><h2 id="7-双令牌认证方案是怎么实现的"><a href="#7-双令牌认证方案是怎么实现的" class="headerlink" title="7. 双令牌认证方案是怎么实现的"></a>7. 双令牌认证方案是怎么实现的</h2><p>同时使用访问令牌（Access Token）和刷新令牌（Refresh Token）来实现用户认证和无感登录刷新。这种方案可以有效地提高安全性和用户体验，具体实现方式如下：</p><ol><li>认证过程：<ol><li>用户使用用户名和密码等凭据进行登录，服务器验证用户身份并生成 Access Token 和 Refresh Token。</li><li>Access Token 用于访问受保护的资源，通常具有较短的有效期，比如几分钟到几小时。</li><li>Refresh Token 用于获取新的 Access Token，通常具有较长的有效期，比如几天到几个月。</li></ol></li><li>Access Token 过期处理：当 Access Token 过期时，用户需要使用 Refresh Token 来获取新的 Access Token，而无需重新输入用户名和密码。</li><li>Refresh Token 安全性：<ol><li>Refresh Token 通常具有较长的有效期，因此需要确保其安全性，防止被盗用。可以通过以下方式提高其安全性：<ul><li>将 Refresh Token 存储在安全的地方，比如 HTTP-only Cookie 或者安全存储。</li><li>使用 HTTPS 加密传输 Refresh Token，防止被中间人窃取。</li></ul></li></ol></li><li>Access Token 的定期刷新：在获取新的 Access Token 时，可以同时返回新的 Refresh Token，以确保用户持续的访问权限。</li></ol><p>通过双令牌认证方案，用户可以在不影响用户体验的情况下持续访问受保护的资源，并且可以有效地提高安全性，防止令牌被截取或滥用。</p><h2 id="8-为什么需要JWT？-解决了什么问题？相比之前的-cookie-session-，改用-jwt-有什么好处？"><a href="#8-为什么需要JWT？-解决了什么问题？相比之前的-cookie-session-，改用-jwt-有什么好处？" class="headerlink" title="8 .为什么需要JWT？/解决了什么问题？相比之前的 cookie + session ，改用 jwt 有什么好处？"></a>8 .为什么需要JWT？/解决了什么问题？相比之前的 cookie + session ，改用 jwt 有什么好处？</h2><p>JWT 和cookie + session功能类似，都是用于身份验证和授权</p><p>优点：</p><ol><li>无状态：服务器不需要再内存中保存用户的会话信息，因为JWT中已经包含了用户的所有必要信息</li><li>跨域支持：因为JWT是在网络请求的头部中传输的，而cookie+session跨域访问需要额外的配置和处理</li><li>可扩展性强：可以包含任意的Json数据，满足不同场景的需求</li><li>性能更好：减少服务器负载，还可以通过缓存或者CDN进行缓存，进一步提升性能</li><li>安全性：数字签名和加密算法</li></ol><h2 id="9-整个JWT是怎么设计的"><a href="#9-整个JWT是怎么设计的" class="headerlink" title="9. 整个JWT是怎么设计的"></a>9. 整个JWT是怎么设计的</h2><ol><li>令牌类型：JWT（JSON Web Token）</li><li>令牌内容：确定令牌中包含的信息，如用户<strong>身份信息、权限信息</strong>、过期时间等。</li><li>令牌签名或加密：使用后SHA256进行签名</li><li>令牌传输： HTTPS 加密通信</li><li>令牌存储：本地存储（如 Local Storage 或者 Session Storage）、HTTP Only Cookie 中</li><li>令牌刷新机制：双令牌认证方案</li><li>令牌管理：好像没有</li></ol><p>Or 见代码实现part</p><h2 id="10-令牌存储-为什么用redis存jwt"><a href="#10-令牌存储-为什么用redis存jwt" class="headerlink" title="10. 令牌存储/为什么用redis存jwt"></a>10. 令牌存储/为什么用redis存jwt</h2><p>本地：Local Storage</p><p>服务器：Redis</p><p>提高性能、减轻数据库负担、高可用性、分布式系统、数据持久化</p><h2 id="11-怎么防止别人用你的token干坏事"><a href="#11-怎么防止别人用你的token干坏事" class="headerlink" title="11. 怎么防止别人用你的token干坏事"></a>11. 怎么防止别人用你的token干坏事</h2><p>分两步：防止别人拿到token；防止别人干坏事</p><p> 防止别人拿到token：</p><ol><li>使用安全的<strong>传输</strong>协议：比如使用 HTTPS 协议来加密通信，防止中间人窃取 token。</li><li>限制 token 的<strong>使用</strong>有效期，刷新 token 机制</li><li>使用<strong>签名验证</strong>：在验证 token 时，确保 token 的签名是有效的，并且是由信任的签发者签发的。这可以防止伪造 token 或者篡改 token 内容。</li></ol><p> 防止别人干坏事：</p><ol><li>限制 token 的<strong>使用范围</strong>：限制 token 只能用于特定的 API 路径或者特定的操作</li><li><strong>定期监控</strong> token 的使用情况</li></ol><h2 id="12-使用JWT时，如果一个用户把token给了另外一个用户恶意同时登录怎么处理"><a href="#12-使用JWT时，如果一个用户把token给了另外一个用户恶意同时登录怎么处理" class="headerlink" title="12. 使用JWT时，如果一个用户把token给了另外一个用户恶意同时登录怎么处理 ?"></a>12. 使用JWT时，如果一个用户把token给了另外一个用户恶意同时登录怎么处理 ?</h2><ol><li>限制令牌的使用范围：可以在 JWT 中包含一些额外的声明（Claims），如用户的 IP 地址、用户角色等信息</li><li>实施单点登录（SSO）限制用户同时登录的设备数量</li><li>限制有效期</li><li>定期监控</li></ol><h2 id="13-对比jwt与token"><a href="#13-对比jwt与token" class="headerlink" title="13. 对比jwt与token"></a>13. 对比jwt与token</h2><ul><li>格式：JWT 是一种特定的令牌格式，它使用 JSON 对象作为载荷，并使用签名或加密来保证其完整性和安全性。而 Token 则是一个更广义的概念，可以是任何形式的凭证。</li><li>安全性：JWT 通过签名或加密来保证其安全性，而普通的 Token 可能没有这种安全保障。</li><li>使用场景：JWT 主要用于实现无状态的身份验证和授权，而 Token 可以用于各种场景，包括 OAuth 授权、访问令牌、刷新令牌等。</li></ul><p>总的来说，<strong>JWT 是 Token 的一种特定格式</strong>，它具有一定的安全性和标准化，适用于实现无状态的身份验证和授权。而 Token 则是一个更广义的概念，可以是各种形式的凭证，用于各种身份验证和授权场景。</p><h2 id="14-cookie了解吗"><a href="#14-cookie了解吗" class="headerlink" title="14. cookie了解吗"></a>14. cookie了解吗</h2><p>存储在<strong>客户端</strong>的小型文本文件，用于跟踪用户在网站上的活动，并且在用户访问同一网站时发送回服务器。</p><p>它们经常被用来实现用户认证、会话跟踪、个性化设置等功能。</p><p>由一组名称/值对组成，以及一些可选的属性。</p><blockquote><p>属性：name——表示名称</p><p>expires——过期时间</p><p>path——可以访问路径</p><p>domain——可访问域名</p><p>secure—— 只能通过 HTTPS 连接传输</p><p>HttpOnly——只能通过 HTTP 或 HTTPS 协议访问，而不能通过客户端脚本（如 JavaScript）访问，以防止跨站脚本（XSS）攻击。</p></blockquote><p>使用cookie需要注意安全性：跨站脚本（XSS）攻击和跨站请求伪造（CSRF）</p><h2 id="15-再让你优化项目还能怎么优化"><a href="#15-再让你优化项目还能怎么优化" class="headerlink" title="15. 再让你优化项目还能怎么优化"></a>15. 再让你优化项目还能怎么优化</h2><ol><li>减小 JWT 的大小：只包含必要的信息</li><li>缓存用户信息：减少每次请求都需要解析 JWT 的开销。</li><li>实现 Token 的刷新机制：减少用户频繁登录的次数，提高用户体验。</li><li>限制 Token 的访问权限：可以减少对数据库的访问次数，提高性能。</li><li>使用 CDN 和反向代理：可以使用 CDN（内容分发网络）和反向代理来缓存和分发 JWT Token，减轻服务器的负载，提高响应速度。</li></ol><h2 id="16-如何防止jwt传输途中被截取"><a href="#16-如何防止jwt传输途中被截取" class="headerlink" title="16. 如何防止jwt传输途中被截取"></a>16. 如何防止jwt传输途中被截取</h2><ol><li>使用 HTTPS 加密传输：最有效的方式是通过使用 HTTPS 协议来加密通信。HTTPS 使用了 TLS/SSL 加密技术</li><li>避免在 URL 中传输 JWT：不要将 JWT 直接作为 URL 参数传递，因为 URL 参数可能会被记录在日志中或者在浏览器历史记录中留下痕迹，增加了被截取的风险。而是应该将 JWT 放在 HTTP 头部的 Authorization 字段中进行传输。</li><li>实现 Token 的签名验证：在服务器端对接收到的 JWT 进行签名验证，确保 JWT 的完整性。</li><li>使用短期有效的 JWT</li><li>实现 Token 的刷新机制</li><li>额外的安全层：在 JWT 中添加额外的安全层，如 CSRF Token，防止 CSRF 攻击；或者在敏感操作中使用双因素身份验证等。</li></ol><h2 id="17-JWT缺点"><a href="#17-JWT缺点" class="headerlink" title="17. JWT缺点"></a>17. JWT缺点</h2><ol><li>无法撤销：一旦 JWT 被签发，除非它达到了过期时间，否则它就是有效的。</li><li>体积较大：JWT 包含了一些额外的信息，如标头、声明和签名等</li><li>无法进行会话管理：无法像传统的基于会话的身份验证那样进行会话管理，如主动注销或者强制用户重新验证。</li><li>安全性依赖于密钥安全性</li><li>不适用于敏感信息存储</li></ol><h2 id="18-JWT能够保证安全性吗？"><a href="#18-JWT能够保证安全性吗？" class="headerlink" title="18. JWT能够保证安全性吗？"></a>18. JWT能够保证安全性吗？</h2><p>Or 保证token存储在本地安全？</p><p>JWT 本身并不能完全保证安全性，它只是一种规范和标准，用于生成和传递令牌。安全性取决于如何使用 JWT 以及其他安全措施的配合。如：</p><ol><li>使用安全的存储机制：选择适合的存储机制来存储 Token，如浏览器的本地存储（如 Local Storage 或者 Session Storage）、HTTP Only Cookie 等</li><li>服务端管理好密钥</li><li>定期更新令牌</li><li>限制令牌访问范围</li><li>HTTPS加密传输</li><li>避免在url中传递敏感信息</li><li>避免XSS（跨站脚本）攻击</li></ol><h2 id="19-如何保证token过期刷新"><a href="#19-如何保证token过期刷新" class="headerlink" title="19. 如何保证token过期刷新"></a>19. 如何保证token过期刷新</h2><p>使用刷新令牌：除了访问令牌（Access Token）外，还可以为用户颁发一个刷新令牌（Refresh Token）</p><p>在访问令牌过期之前，每次访问可以通过向服务器发送特定的请求来刷新令牌</p><h2 id="20-无状态登录和有状态登录的区别"><a href="#20-无状态登录和有状态登录的区别" class="headerlink" title="20. 无状态登录和有状态登录的区别"></a>20. 无状态登录和有状态登录的区别</h2><ol><li>无状态登录（Stateless Login）：<ol><li>在无状态登录中，服务器不需要保存用户的会话状态。客户端在之后的每次请求中都会将该 JWT 作为身份凭证发送给服务器，服务器只需要验证 JWT 的有效性，而不需要在服务器端保存任何会话信息。</li><li>由于服务器不保存会话状态，因此无状态登录适用于分布式和跨域应用环境，具有更好的可扩展性和性能。</li></ol></li><li>有状态登录（Stateful Login）：<ol><li>在有状态登录中，服务器需要在服务器端保存用户的会话状态。每次用户进行身份验证时，服务器会将用户的会话信息保存在服务器端，并返回一个会话标识符（Session ID）给客户端。</li><li>客户端在之后的每次请求中都会将会话标识符发送给服务器，服务器通过会话标识符来识别用户的会话状态，从而进行身份验证和授权。</li></ol></li></ol><h2 id="21-退出登录、注册怎么通过JWT实现？"><a href="#21-退出登录、注册怎么通过JWT实现？" class="headerlink" title="21. 退出登录、注册怎么通过JWT实现？"></a>21. 退出登录、注册怎么通过JWT实现？</h2><ol><li>退出登录：退出登录通常意味着销毁客户端保存的 JWT 令牌。<ol><li>客户端发送一个特殊的请求，如注销请求，到服务器端。</li><li>服务器端收到注销请求后，将相应用户的 JWT 令牌加入一个黑名单列表或者删除相应的令牌信息。</li><li>客户端收到服务器的响应后，删除本地存储的 JWT 令牌，使用户被注销。</li></ol></li><li>注册：<ol><li>客户端向服务器发送注册请求，包含新用户的注册信息，如用户名和密码等。</li><li>服务器接收到注册请求后，验证注册信息的合法性，并创建新用户。随后，服务器生成相应用户的 JWT 令牌，并将其返回给客户端。</li><li>客户端收到服务器返回的 JWT 令牌后，将其保存在本地，以便在以后的请求中使用。</li></ol></li></ol><h2 id="22-如果用户更改了密码，如何处理jwt令牌"><a href="#22-如果用户更改了密码，如何处理jwt令牌" class="headerlink" title="22. 如果用户更改了密码，如何处理jwt令牌"></a>22. 如果用户更改了密码，如何处理jwt令牌</h2><p>让令牌失效：</p><ol><li>强制用户重新登录：当用户更改密码后，服务器端直接删除用户之前的所有 JWT 令牌，并要求用户重新登录。</li><li>使用密码加盐：在用户更改密码时，修改用户的密码同时也修改密码的盐值。</li><li>添加版本号或时间戳：在 JWT 的负载中添加一个版本号或者时间戳字段，表示用户的密码版本或者密码修改时间。</li></ol><h2 id="23-怎么让JWT提前失效"><a href="#23-怎么让JWT提前失效" class="headerlink" title="23. 怎么让JWT提前失效"></a>23. 怎么让JWT提前失效</h2><ol><li>设置过期时间（exp）：JWT 的playLoad中包含了一个名为 “exp” 的声明，可以设置</li><li>撤销令牌：维护一个令牌撤销列表，当用户注销或者改变了密码时，将相应的令牌加入到撤销列表中，以使这些令牌失效。</li><li>使用刷新令牌：刷新令牌有更长的有效期，可以获取访问令牌。一旦刷新令牌失效或者被使用，之前颁发的访问令牌就会提前失效。</li></ol><h2 id="24-强行让JWT失效会发生什么事情？"><a href="#24-强行让JWT失效会发生什么事情？" class="headerlink" title="24. 强行让JWT失效会发生什么事情？"></a>24. 强行让JWT失效会发生什么事情？</h2><p>JWT通常被设计为服务器不需要在数据库中存储任何关于令牌的信息</p><p>然而，如果强行让 JWT 失效，通常需要在服务器端维护一个令牌的黑名单或者撤销列表，这就涉及到在数据库或者其他持久化存储中存储令牌信息，违背了 JWT 无状态的初衷。</p><h2 id="25-除了JWT还有没有别的方案，它们之间的优缺点分别是什么"><a href="#25-除了JWT还有没有别的方案，它们之间的优缺点分别是什么" class="headerlink" title="25. 除了JWT还有没有别的方案，它们之间的优缺点分别是什么"></a>25. 除了JWT还有没有别的方案，它们之间的优缺点分别是什么</h2><ol><li>Cookie + session</li><li>OAuth：通常用于实现第三方登录</li><li>JWT：实现无状态的用户身份验证和授权，适用于需要在不同的应用之间传递用户身份信息的情况，如单点登录、跨域认证等。</li></ol><h2 id="26-介绍一下单点登录，jwt怎么实现单点登录？"><a href="#26-介绍一下单点登录，jwt怎么实现单点登录？" class="headerlink" title="26. 介绍一下单点登录，jwt怎么实现单点登录？"></a>26. 介绍一下单点登录，jwt怎么实现单点登录？</h2><p>单点登录（Single Sign-On，简称 SSO）是一种身份认证的机制，允许用户通过一次登录，就能够访问多个相关的系统或服务。</p><p> 在一个认证中心进行登录，获取JWT，然后访问其他服务都将这个JWT作为身份凭证发送给服务端</p><p> 而且JWT可以实现自定义声明，适用于单点登录</p><h2 id="27-跨域是什么，为什么会有跨域问题？"><a href="#27-跨域是什么，为什么会有跨域问题？" class="headerlink" title="27. 跨域是什么，为什么会有跨域问题？"></a>27. 跨域是什么，为什么会有跨域问题？</h2><p>跨域（Cross-Origin）是指在 Web 开发中，当一个域名下的文档或脚本试图去请求另一个域名下的资源时，就会产生跨域问题。</p><p>跨域流程：</p><ol><li>用户登录：用户在任意一个服务器上进行登录，登录成功后，服务器生成 JWT 并将其返回给客户端。</li><li>JWT 传递：客户端收到 JWT 后，将其保存在本地，通常是在浏览器的本地存储（如 Local Storage）或者 Cookie 中。</li><li>跨域请求：用户在其他服务器上进行访问时，客户端将 JWT 放入请求头中（通常是 Authorization 头），发送到另一个服务器。</li><li>JWT 验证：另一个服务器接收到请求后，验证 JWT 的签名和有效期。如果验证通过，则说明用户已经通过认证，可以继续处理请求；否则，返回相应的错误信息。</li><li>响应处理：另一个服务器处理完请求后，可以生成新的 JWT 并返回给客户端，以便客户端在下次请求时继续使用。</li></ol><p>跨域问题产生的原因主要有以下几点：</p><ol><li>同源策略（Same-Origin Policy）：同源策略是浏览器的一项安全策略，限制了一个域下的文档或脚本与另一个域下的资源进行交互。同源策略规定了只有当请求的协议、主机和端口号完全一致时，才允许进行跨域请求，否则就会产生跨域问题。</li><li>安全性考虑：跨域请求可能会带来安全隐患，比如跨站脚本（XSS）攻击和跨站请求伪造（CSRF）攻击等。浏览器为了保护用户的信息安全，因此默认情况下会阻止跨域请求。</li><li>浏览器限制：浏览器出于安全考虑，对跨域请求进行了限制，包括不允许跨域读取 Cookie、不允许跨域访问 DOM 和不允许跨域发送 AJAX 请求等。</li></ol><p>跨域问题会影响到 Web 开发中的很多场景，比如跨域 AJAX 请求、跨域资源共享（CORS）、跨文档消息传递（PostMessage）等。为了解决跨域问题，通常可以采取以下几种方法：</p><ul><li>CORS（Cross-Origin Resource Sharing）：通过服务端设置响应头来允许跨域请求，从而在客户端浏览器上解决跨域问题。<ul><li>使用 @CrossOrigin 注解</li><li>全局配置 CORS<code>public class CorsConfig implements WebMvcConfigurer</code></li><li>通过配置文件配置 CORS</li></ul></li><li>WebSocket：WebSocket 不受同源策略的限制，可以通过建立 WebSocket 连接来实现跨域通信。</li></ul><h2 id="28-企业有多个服务器多个域名怎么实现jwt？除了jwt还有哪些能实现跨域认证"><a href="#28-企业有多个服务器多个域名怎么实现jwt？除了jwt还有哪些能实现跨域认证" class="headerlink" title="28. 企业有多个服务器多个域名怎么实现jwt？除了jwt还有哪些能实现跨域认证"></a>28. 企业有多个服务器多个域名怎么实现jwt？除了jwt还有哪些能实现跨域认证</h2><ol><li>单点登录</li><li>JWT包含域名信息</li><li>使用统一的认证服务器，负责用户身份认证和生成 JWT。所有的服务器都向该认证服务器发送认证请求，验证用户身份后生成 JWT 返回给客户端。</li></ol><p>其他跨域认证方法：</p><p>1.OAuth2.0</p><h2 id="29-场景题：设计一个手机端扫码登录电脑端的的功能"><a href="#29-场景题：设计一个手机端扫码登录电脑端的的功能" class="headerlink" title="29. 场景题：设计一个手机端扫码登录电脑端的的功能"></a>29. 场景题：设计一个手机端扫码登录电脑端的的功能</h2><ol><li>生成登录二维码：<ol><li>在电脑端的登录页面上生成一个登录二维码。</li><li>二维码内容可以是一个唯一的标识符，代表着当前登录会话的标识。</li></ol></li><li>手机端扫码</li><li>验证二维码：<ol><li>手机端扫描到二维码后，将二维码的内容发送到服务器进行验证。</li><li>服务器验证二维码的有效性，并确定该二维码对应的登录会话是否有效。</li></ol></li><li>登录确认：<ol><li>如果二维码有效，服务器返回登录确认信息给手机端。</li><li>手机端接收到确认信息后，提示用户确认登录操作。</li></ol></li><li>登录处理：<ol><li>用户在手机端确认登录操作后，手机端发送登录请求给服务器，携带用户身份信息。</li><li>服务器验证用户身份信息，并在后台完成登录流程。</li></ol></li><li>登录状态同步：<ol><li>服务器在登录成功后，在电脑端和手机端均生成对应的登录状态信息（如登录令牌或者会话标识）。</li><li>电脑端和手机端均保存登录状态信息，以便在后续的操作中进行身份验证和授权。</li></ol></li><li>登录完成：<ol><li>登录完成后，电脑端和手机端均显示登录成功的提示。</li><li>用户可以在电脑端和手机端自由操作，并保持登录状态的同步。</li></ol></li></ol><h2 id="30-其他：websock……"><a href="#30-其他：websock……" class="headerlink" title="30. 其他：websock……"></a>30. 其他：websock……</h2><p>如何自定义登录接口以及jwt过滤器</p><p>websocket 轮询什么的</p><h2 id="扩展：集成-Sa-token-实现角色认证和权限认证，并使用Redis集成进行缓存，添加API签名参数增强"><a href="#扩展：集成-Sa-token-实现角色认证和权限认证，并使用Redis集成进行缓存，添加API签名参数增强" class="headerlink" title="扩展：集成 Sa-token 实现角色认证和权限认证，并使用Redis集成进行缓存，添加API签名参数增强"></a>扩展：集成 Sa-token 实现角色认证和权限认证，并使用Redis集成进行缓存，添加API签名参数增强</h2><p><a href="https://sa-token.cc/doc.html#/up/integ-redis">Sa-Token</a></p><p>oauth2.0 vs sso，jwt 双token</p><p>为什么不选择SpringSecurity 、Shiro</p><ol><li>需求能否被胜任：单点登录, 身份切换, 等等等等, 以及可能产生的需求, auth2, 动态鉴权</li><li>上手难度小：SaToken最简单, Shiro中规中矩, SpringSecurity最繁琐</li><li>友好程度：文档是否友好, demo是否完善, 以及各大论坛博客文章错误内容多不多. 如果是中文的话SaToken更友好, 英文则SpringSecurity</li></ol><p>登录的逻辑，需要从请求发到服务端开始，说清楚springmvc的处理流程，然后在到业务处理，包括方法的返回值都要说清楚。</p><p>API签名参数</p><p><img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/asynccode" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 项目设计 </tag>
            
            <tag> JWT </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气</title>
      <link href="/posts/btydyq/"/>
      <url>/posts/btydyq/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原因论：如果一味地关注过去的原因，企图仅仅靠原因去解释事务，那就会陷入决定论。也就是说，我们的现在甚至未来全部都由过去的事情决定，而且根本无法改变</p><p>心理创伤学：感到痛苦是因为过去的事情，进而简单安慰地错不在你，在于那些抽象的“过去的事情”  ==&gt;很多心理咨询都是这样的？还是只是偏安慰型的心理咨询是这样的？</p><p>目的论：<br>比如说，发怒是一种工具，而不是结果<br>是先产生大发雷霆的目的，作为对应手段，捏造了愤怒这种感情，希望通过发怒这种工具迫使他人屈服你的权力，并不是不可控制的情绪<br>最简单的例子就是当家长对小孩生气时，如果此时被班主任的电话打断，会马上转换心态去进入一个新的对话场景<br>除了发怒我们还有许多有效交流工具</p><p>怎么理解利己的善</p><p>我的性格是悲观的 —— 我具有悲观的世界观<br>前者的性格带有”不可改变“性的感觉<br>但如果是世界观，那就有改变的可能性</p><p>那为什么不喜欢改变呢<br>因为感觉现在的生活方式更好，如果一致保持现在的我，那么如何应对眼前的事情以及结果等问题都可以更具经验进行推测，即使遇到状况也能够想办法对付过去 ==》【我趣这不就是拖延症的根本原因：就算拖延我也可以在ddl前干完所有事请】</p><p>如果我有时间的话也可以<br>反过来就是对现状的认知：现在我没时间，所以我不行<br>但是真的是时间的原因吗？怕的是就算有时间也不行，那就不能把原因推给外界了，只能是自身的原因</p><p>无法接受自己<br>原因论：因为有很多缺点，所以不喜欢自己<br>目的论：是先下定了“不要喜欢自己”的决心，为了达到这个目的，所以只看缺点不看优点<br>那为什么要下定这种决心，因为害怕被他人否定，所以先自己否定自己【这里感觉还是不太顺，难道是不能接收别人否定自己，所以先否定自己，这就就会心里好受点？】</p><p>之所以感到孤独并不是因为只有自己一个人，而是感觉自己被周围的他人、社会和共同体所疏远才会孤独<br>我们就算想体会孤独也需要他人的存在<br>【太对了我靠，怪不得觉得宿舍有人反而孤独，一个人在宿舍还自由(●’◡’●)】</p><p>虽然苦于强烈的自卑感，但却没有勇气通过努力或者成长之类的健全手段去进行改变<br>即便如此，也没办法忍受“因为有A才做不到B ”之类的自卑情节，无法接收无能的自己<br>如此一来，人就会想用更加简便的方法来进行补偿–》表现得自己好像很优秀，继而沉浸在一种虚假的优越感中，也就是权势张扬</p><p>还有一个自夸的复杂实例——通过把自卑感尖锐化来实现优越感的模式——夸耀不幸<br>即使别人想要去安慰或者帮助，它们也会用“你无法了解我的心情”来推开援手<br>以自己的不幸为武器来支配对方，通过诉说自己如何痛苦来让周围的人担心或束缚其言行<br>弱势具有强权</p><p>原因论：因为父母用这样的方式教育，所以孩子变成这样<br>目的论：如果孩子变成这样，父母会烦恼不已，孩子正是因为这一点才出现问题（报复父母）</p><p>如果我是正确的，那么对方持什么意见都应该无所谓<br>但是很多人都通过证明别人是错的来说明自己是对的<br>所以承认自己的错误 = 承认失败【这里为什么？】</p>]]></content>
      
      
      <categories>
          
          <category> 怎么认识这个世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慢慢填坑</title>
      <link href="/posts/da6a/"/>
      <url>/posts/da6a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>博客待更新Plan:</p><ol><li>搜索功能失效</li><li>首页图片加载过慢</li><li>各文章暂未进行分类  ✅</li><li>生活模块的听歌(wyy音乐播放器)、读书、小记(artitalk)页面待完善</li><li>个人模块的友链、留言区、关于我页面待新增</li><li>每次hexo g都会把所有文章更新一次  ✅</li></ol><blockquote><p>2024 - 09 - 28 更新</p></blockquote><ol><li>初步完成文章分类</li><li>完成友链、聊点小天页面内容</li><li>关于hexo g<ol><li>作用就是重新生成public文件夹下的所有内容</li><li>现在采用的是Github Page静态页面部署方式，如果更改了config配置，则必须使用hexo g，如果没有的话可以直接hexo c&amp;&amp;hexo d</li></ol></li></ol><blockquote><p>2024 - 12 - 30 fix</p></blockquote><ol><li>修复了hexo g 不生成index.html的bug</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫-3.基本库的使用</title>
      <link href="/posts/3fe0/"/>
      <url>/posts/3fe0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用-urllib"><a href="#使用-urllib" class="headerlink" title="使用 urllib"></a>使用 urllib</h1><p>首先，了解一下 urllib 库，它是 Python 内置的 HTTP 请求库，也就是说不需要额外安装即可使用。它包含如下 4 个模块。</p><ul><li>request：它是最基本的 HTTP 请求模块，可以用来模拟发送请求。就像在浏览器里输入网址然后回车一样，只需要给库方法传入 URL 以及额外的参数，就可以模拟实现这个过程了。</li><li>error：异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。</li><li>parse：一个工具模块，提供了许多 URL 处理方法，比如拆分、解析、合并等。</li><li>robotparser：主要是用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用得比较少。</li></ul><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h3><ul><li><p>构造方法</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">urllib.request.urlopen(url, data=<span class="literal">None</span>, [timeout,]-, cafile=<span class="literal">None</span>, capath=<span class="literal">None</span>, cadefault=<span class="literal">False</span>, context=<span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>基本使用</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://www.python.org'</span>)</span><br><span class="line"><span class="comment"># 获取返回类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response))</span><br><span class="line"><span class="comment"># 获取返回结果的状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.status)</span><br><span class="line"><span class="comment"># 获取响应头的各数据</span></span><br><span class="line"><span class="built_in">print</span>(response.getheaders())</span><br><span class="line"><span class="comment"># 获取了响应头中的 Server 值，结果是 nginx，意思是服务器是用 Nginx 搭建的。</span></span><br><span class="line"><span class="built_in">print</span>(response.getheader(<span class="string">'Server'</span>))</span><br><span class="line"><span class="comment">#获取读取信息，即网页的源代码</span></span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></tbody></table></figure></li><li><p>data参数<br>将参数转化为字节流编码格式的内容，即 bytes 类型，POST请求方式</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse  </span><br><span class="line"><span class="keyword">import</span> urllib.request  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取hello！xxz，会传送到运行结果的word --POST模拟表单获取</span></span><br><span class="line"><span class="comment">#  urlencode 方法来将参数字典转化为字符串</span></span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode({<span class="string">'word'</span>: <span class="string">'hello'</span>}), encoding=<span class="string">'utf8'</span>)  </span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://httpbin.org/post'</span>, data=data)  </span><br><span class="line"><span class="built_in">print</span>(response.read())</span><br></pre></td></tr></tbody></table></figure></li><li><p>timeout参数</p><p>  用于设置超时时间，单位为秒；如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常  </p><blockquote><p>可以通过设置这个超时时间来控制一个网页如果长时间未响应，就跳过它的抓取</p></blockquote>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line"><span class="keyword">import</span> urllib.request  </span><br><span class="line"><span class="keyword">import</span> urllib.error  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'http://httpbin.org/get'</span>, timeout=<span class="number">0.1</span>)  </span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="comment"># socket.timeout --超时异常</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(e.reason, socket.timeout):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'TIME OUT'</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>其他参数</p><p>context 参数，它必须是 ssl.SSLContext 类型，用来指定 SSL 设置</p><p>……</p><p>详见文档：<a href="https://docs.python.org/3/library/urllib.request.html">urllib.request — 用于打开 URL 的可扩展库 — Python 3.11.4 文档</a></p></li></ul><h3 id="Requset-power"><a href="#Requset-power" class="headerlink" title="Requset[power!]"></a>Requset[power!]</h3><p>如果请求中需要加入 Headers 等信息，就可以利用更强大的 Request 类来构建</p><ul><li><p>Request构造方法</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">urllib</span>.request.Request(url, data=<span class="literal">None</span>, headers={}, origin_req_host=<span class="literal">None</span>, unverifiable=<span class="literal">False</span>, method=<span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure><ul><li><p>url 用于请求 URL，这是必传参数，其他都是可选参数。</p></li><li><p>data 如果要传，必须传 bytes（字节流）类型的。如果它是字典，可以先用 urllib.parse 模块里的 urlencode() 编码。</p></li><li><p>headers 是一个字典，它就是请求头，我们可以在构造请求时通过 headers 参数直接构造，也可以通过调用请求实例的 add_header() 方法添加。</p></li><li><p>unverifiable 表示这个请求是否是无法验证的，默认是 False，意思就是说用户没有足够权限来选择接收这个请求的结果。例如，我们请求一个 HTML 文档中的图片，但是我们没有自动抓取图像的权限，这时 unverifiable 的值就是 True。</p></li><li><p>method 是一个字符串，用来指示请求使用的方法，比如 GET、POST 和 PUT 等。</p></li></ul></li><li><p>初步使用</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse  </span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span>  </span><br><span class="line">headers = {<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>,  </span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'httpbin.org'</span>  </span><br><span class="line">}  </span><br><span class="line"><span class="built_in">dict</span> = {<span class="string">'name'</span>: <span class="string">'Germey'</span>}  </span><br><span class="line"><span class="comment"># data用 urlencode 和 bytes 方法转成字节流</span></span><br><span class="line">data = <span class="built_in">bytes</span>(parse.urlencode(<span class="built_in">dict</span>), encoding=<span class="string">'utf8'</span>)  </span><br><span class="line">req = request.Request(url=url, data=data, headers=headers, method=<span class="string">'POST'</span>)  </span><br><span class="line"><span class="comment"># headers 也可以用 add_header 方法来添加</span></span><br><span class="line"><span class="comment"># req.add_header('User-Agent', 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)')</span></span><br><span class="line">response = request.urlopen(req)  </span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="power"><a href="#power" class="headerlink" title="power!"></a>power!</h3><ul><li><p>Handler</p><p>把它理解为各种处理器，有专门处理登录验证的，有处理 Cookies 的，有处理代理设置的。利用它们，我们几乎可以做到 HTTP 请求中所有的事情</p><p>父类BaseHandler，各种子类：</p><ul><li>HTTPDefaultErrorHandler 用于处理 HTTP 响应错误，错误都会抛出 HTTPError 类型的异常。</li><li>HTTPRedirectHandler 用于处理重定向。</li><li>HTTPCookieProcessor 用于处理 Cookies。</li><li>ProxyHandler 用于设置代理，默认代理为空。</li><li>HTTPPasswordMgr 用于管理密码，它维护了用户名密码的表。</li><li>HTTPBasicAuthHandler 用于管理认证，如果一个链接打开时需要认证，那么可以用它来解决认证问题。</li><li>详情可以参考官方文档： <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler">https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler</a></li></ul></li><li><p>OpenerDirector<br>就是利用 Handler 来构建 Opener</p><ul><li><p>验证  </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#通过代码模拟访问需要验证的页面，并获取验证后的内容</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener  </span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError  </span><br><span class="line"></span><br><span class="line">username = <span class="string">'username'</span>  </span><br><span class="line">password = <span class="string">'password'</span>  </span><br><span class="line">url = <span class="string">'http://localhost:5000/'</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用add_password方法将用户名、密码和URL添加到HTTPPasswordMgrWithDefaultRealm对象中，以建立用户名和密码的映射关系。</span></span><br><span class="line">p = HTTPPasswordMgrWithDefaultRealm()  </span><br><span class="line">p.add_password(<span class="literal">None</span>, url, username, password)  </span><br><span class="line"><span class="comment"># 创建HTTPBasicAuthHandler对象，并将HTTPPasswordMgrWithDefaultRealm对象作为参数传入。这样就建立了一个处理验证的Handler</span></span><br><span class="line">auth_handler = HTTPBasicAuthHandler(p) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用build_opener方法，Opener对象在发送请求时会自动携带验证信息</span></span><br><span class="line">opener = build_opener(auth_handler)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment"># 通过Opener对象的open方法打开指定的URL，完成验证过程。获取到验证后的页面源码内容</span></span><br><span class="line">    result = opener.<span class="built_in">open</span>(url)  </span><br><span class="line">    html = result.read().decode(<span class="string">'utf-8'</span>)  </span><br><span class="line">    <span class="built_in">print</span>(html)  </span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></tbody></table></figure></li><li><p>代理</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 在爬虫中设置代理，以便在访问目标网站时使用指定的代理服务器</span></span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError  </span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过ProxyHandler创建了一个代理处理器，将代理的信息传递给处理器</span></span><br><span class="line"><span class="comment"># 在本地搭建了一个代理，它运行在 9743 端口上。可以添加多个代理，以适应不同协议的请求</span></span><br><span class="line">proxy_handler = ProxyHandler({  </span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'http://127.0.0.1:9743'</span>,  </span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'https://127.0.0.1:9743'</span>  </span><br><span class="line">})  </span><br><span class="line"><span class="comment"># 用build_opener方法将代理处理器与其他可能的处理器（如身份验证处理器）一起构建成一个 Opener。</span></span><br><span class="line"><span class="comment"># opener是用于发送请求的对象</span></span><br><span class="line">opener = build_opener(proxy_handler)  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">'https://www.baidu.com'</span>)  </span><br><span class="line">    <span class="built_in">print</span>(response.read().decode(<span class="string">'utf-8'</span>))  </span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></tbody></table></figure></li><li><p>Coookies</p><ul><li>在爬虫中处理 Cookies</li><li>从网站获取并使用 Cookies</li><li>将 Cookies 保存到文件中以供后续使用</li></ul></li></ul></li></ul><h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><h3 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a>URLError</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/index.htm'</span>)  </span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></tbody></table></figure><p>打开一个不存在的页面，照理来说应该会报错，但是这时我们捕获了 URLError 这个异常，运行结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Not Found</span><br></pre></td></tr></tbody></table></figure><p>程序没有直接报错，而是输出了如上内容，这样通过如上操作，我们就可以避免程序异常终止，同时异常得到了有效处理。</p><h3 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h3><p> URLError 的子类，专门用来处理 HTTP 请求错误，比如认证请求失败等。它有如下 3 个属性。</p><ul><li><p>code：返回 HTTP 状态码，比如 404 表示网页不存在，500 表示服务器内部错误等</p></li><li><p>reason：同父类一样，用于返回错误的原因</p></li><li><p>headers：返回请求头</p></li></ul><p>示例：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/index.htm'</span>)  </span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason, e.code, e.headers, sep=<span class="string">'\n'</span>)</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Not Found</span><br><span class="line">404</span><br><span class="line">Server: nginx/1.4.6 (Ubuntu)</span><br><span class="line">Date: Wed, 03 Aug 2016 08:54:22 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: close</span><br><span class="line">X-Powered-By: PHP/5.5.9-1ubuntu4.14</span><br><span class="line">Vary: Cookie</span><br><span class="line">Expires: Wed, 11 Jan 1984 05:00:00 GMT</span><br><span class="line">Cache-Control: no-cache, must-revalidate, max-age=0</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Link: &lt;https://cuiqingcai.com/wp-json/&gt;; rel="https://api.w.org/"</span><br></pre></td></tr></tbody></table></figure><h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p>因为 URLError 是 HTTPError 的父类，所以可以先选择捕获子类的错误，再去捕获父类的错误</p><p>先捕获 HTTPError，获取它的错误状态码、原因、headers 等信息。如果不是 HTTPError 异常，就会捕获 URLError 异常，输出错误原因。最后，用 else 来处理正常的逻辑。这是一个较好的异常处理写法。</p><p>reason返回字符串</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/index.htm'</span>)  </span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason, e.code, e.headers, sep=<span class="string">'\n'</span>)  </span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(e.reason)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Request Successfully'</span>)</span><br></pre></td></tr></tbody></table></figure><p>reason返回对象</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line"><span class="keyword">import</span> urllib.request  </span><br><span class="line"><span class="keyword">import</span> urllib.error  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'https://www.baidu.com'</span>, timeout=<span class="number">0.01</span>)  </span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(e.reason))  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(e.reason, socket.timeout):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'TIME OUT'</span>)</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span><span class="string">'socket.timeout'</span>&gt;</span><br><span class="line"><span class="comment">#reason 属性的结果是 socket.timeout 类，可以用 isinstance 方法来判断它的类型，作出更详细的异常判断。</span></span><br><span class="line">TIME OUT</span><br></pre></td></tr></tbody></table></figure><h2 id="解析链接"><a href="#解析链接" class="headerlink" title="解析链接"></a>解析链接</h2><h3 id="urlparse-解析URL"><a href="#urlparse-解析URL" class="headerlink" title="urlparse  -解析URL"></a>urlparse  -解析URL</h3><ul><li><p>构造方法</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">urllib.parse.urlparse(urlstring, scheme=<span class="string">''</span>, allow_fragments=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><p>  3 个参数：</p><ul><li><p>urlstring：这是必填项，即待解析的 URL。</p></li><li><p>scheme：它是默认的协议（比如 http 或 https 等）。假如这个链接没有带协议信息，会将这个作为默认的协议。</p><blockquote><p>scheme 参数只有在 URL 中不包含 scheme 信息时才生效。如果 URL 中有 scheme 信息，就会返回解析出的 scheme</p></blockquote></li><li><p>allow_fragments：即是否忽略 fragment。如果它被设置为 False，fragment 部分就会被忽略，它会被解析为 path、parameters 或者 query 的一部分，而 fragment 部分为空。</p></li></ul></li><li><p>实现 URL 的识别和分段</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse  </span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">'http://www.baidu.com/index.html;user?id=5#comment'</span>, scheme=<span class="string">'https'</span>, allow_fragments=<span class="literal">False</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result), result)</span><br></pre></td></tr></tbody></table></figure><p>  运行结果如下：</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">'urllib.parse.ParseResult'</span>&gt;</span><br><span class="line">ParseResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html'</span>, params=<span class="string">'user'</span>, query=<span class="string">'id=5#comment'</span>,</span><br><span class="line">fragment=<span class="string">''</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>返回结果是一个 ParseResult 类型的对象，<br>  它包含 6 个部分，分别是 scheme、netloc、path、params、query 和 fragment。可以得出一个标准的链接格式，具体如下： <code>scheme://netloc/path;params?query#fragment</code></p></li><li><p>返回结果 ParseResult 实际上是一个元组<br>  我们可以用索引顺序来获取，也可以用属性名获取。示例如下：</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse  </span><br><span class="line">  </span><br><span class="line">result = urlparse(<span class="string">'http://www.baidu.com/index.html#comment'</span>, allow_fragments=<span class="literal">False</span>)  </span><br><span class="line"><span class="built_in">print</span>(result.scheme, result[<span class="number">0</span>], result.netloc, result[<span class="number">1</span>], sep=<span class="string">'\n'</span>)</span><br></pre></td></tr></tbody></table></figure><p>  分别用索引和属性名获取了 scheme 和 netloc，其运行结果如下：</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http  </span><br><span class="line">http  </span><br><span class="line">www.baidu.com  </span><br><span class="line">www.baidu.com</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="urlunparse-构造URL"><a href="#urlunparse-构造URL" class="headerlink" title="urlunparse  -构造URL"></a>urlunparse  -构造URL</h3><p>有了 urlparse 方法，相应地就有了它的对立方法 urlunparse。它接受的参数是一个可迭代对象，但是它的长度必须是 6，否则会抛出参数数量不足或者过多的问题。先用一个实例看一下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunparse  </span><br><span class="line"></span><br><span class="line">data = [<span class="string">'http'</span>, <span class="string">'www.baidu.com'</span>, <span class="string">'index.html'</span>, <span class="string">'user'</span>, <span class="string">'a=6'</span>, <span class="string">'comment'</span>]  </span><br><span class="line"><span class="built_in">print</span>(urlunparse(data))</span><br></pre></td></tr></tbody></table></figure><p>这里参数 data 用了列表类型。也可以用其他类型，比如元组或者特定的数据结构。运行结果如下： </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://www.baidu.com/index.html;user?a=6#comment</span><br></pre></td></tr></tbody></table></figure><h3 id="urlsplit-解析URL"><a href="#urlsplit-解析URL" class="headerlink" title="urlsplit  -解析URL"></a>urlsplit  -解析URL</h3><p>它不再单独解析 params 这一部分，只返回 5 个结果， params 会合并到 path 中</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlsplit  </span><br><span class="line">result = urlsplit(<span class="string">'http://www.baidu.com/index.html;user?id=5#comment'</span>)  </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：  </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">SplitResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html;user'</span>, query=<span class="string">'id=5'</span>, fragment=<span class="string">'comment'</span>)</span><br></pre></td></tr></tbody></table></figure><p>返回结果是 SplitResult，也是一个元组类型，既可以用属性获取值，也可以用索引来获取</p><h3 id="urlunsplit-构造URL"><a href="#urlunsplit-构造URL" class="headerlink" title="urlunsplit  -构造URL"></a>urlunsplit  -构造URL</h3><p>与 urlunparse 方法类似，它也是将链接各个部分组合成完整链接的方法，传入的参数也是一个可迭代对象，例如列表、元组等，唯一的区别是长度必须为 5。</p><p>示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunsplit  </span><br><span class="line"></span><br><span class="line">data = [<span class="string">'http'</span>, <span class="string">'www.baidu.com'</span>, <span class="string">'index.html'</span>, <span class="string">'a=6'</span>, <span class="string">'comment'</span>]  </span><br><span class="line"><span class="built_in">print</span>(urlunsplit(data))</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下： </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://www.baidu.com/index.html?a=6#comment</span><br></pre></td></tr></tbody></table></figure><h3 id="urljoin-解析URL"><a href="#urljoin-解析URL" class="headerlink" title="urljoin -解析URL"></a>urljoin -解析URL</h3><p>提供一个 base_url（基础链接）作为第一个参数，将新的链接作为第二个参数，该方法会分析 base_url 的 scheme、netloc 和 path 这 3 个内容并对新链接缺失的部分进行补充，最后返回结果。</p><p>示例：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com'</span>, <span class="string">'FAQ.html'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com'</span>, <span class="string">'https://cuiqingcai.com/FAQ.html'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com/about.html'</span>, <span class="string">'https://cuiqingcai.com/FAQ.html'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com/about.html'</span>, <span class="string">'https://cuiqingcai.com/FAQ.html?question=2'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com?wd=abc'</span>, <span class="string">'https://cuiqingcai.com/index.php'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'http://www.baidu.com'</span>, <span class="string">'?category=2#comment'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'www.baidu.com'</span>, <span class="string">'?category=2#comment'</span>))  </span><br><span class="line"><span class="built_in">print</span>(urljoin(<span class="string">'www.baidu.com#comment'</span>, <span class="string">'?category=2'</span>))</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://www.baidu.com/FAQ.html  </span><br><span class="line">https://cuiqingcai.com/FAQ.html  </span><br><span class="line">https://cuiqingcai.com/FAQ.html  </span><br><span class="line">https://cuiqingcai.com/FAQ.html?question=2  </span><br><span class="line">https://cuiqingcai.com/index.php  </span><br><span class="line">http://www.baidu.com?category=2#comment  </span><br><span class="line">www.baidu.com?category=2#comment  </span><br><span class="line">www.baidu.com?category=2</span><br></pre></td></tr></tbody></table></figure><h3 id="urlencode-转GET请求参数"><a href="#urlencode-转GET请求参数" class="headerlink" title="urlencode  -转GET请求参数"></a>urlencode  -转GET请求参数</h3><p>示例：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode  </span><br><span class="line"></span><br><span class="line">params = {  </span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'germey'</span>,  </span><br><span class="line">    <span class="string">'age'</span>: <span class="number">22</span>  </span><br><span class="line">}  </span><br><span class="line">base_url = <span class="string">'http://www.baidu.com?'</span>  </span><br><span class="line">url = base_url + urlencode(params)  </span><br><span class="line"><span class="built_in">print</span>(url)</span><br></pre></td></tr></tbody></table></figure><p>这里首先声明了一个字典来将参数表示出来，然后调用 urlencode 方法将其序列化为 GET 请求参数。运行结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://www.baidu.com?name=germey&amp;amp;age=22</span><br></pre></td></tr></tbody></table></figure><p>这个方法非常常用。有时为了更加方便地构造参数，我们会事先用字典来表示。要转化为 URL 的参数时，只需要调用该方法即可。</p><h3 id="parse-qs-转字典"><a href="#parse-qs-转字典" class="headerlink" title="parse_qs    -转字典"></a>parse_qs    -转字典</h3><p>利用 parse_qs 方法，就可以将它转回字典，示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs  </span><br><span class="line"></span><br><span class="line">query = <span class="string">'name=germey&amp;amp;age=22'</span>  </span><br><span class="line"><span class="built_in">print</span>(parse_qs(query))</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{<span class="string">'name'</span>: [<span class="string">'germey'</span>], <span class="string">'age'</span>: [<span class="string">'22'</span>]}</span><br></pre></td></tr></tbody></table></figure><h3 id="parse-qsl-转元组"><a href="#parse-qsl-转元组" class="headerlink" title="parse_qsl   -转元组"></a>parse_qsl   -转元组</h3><p>将参数转化为元组组成的列表，示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qsl  </span><br><span class="line"></span><br><span class="line">query = <span class="string">'name=germey&amp;amp;age=22'</span>  </span><br><span class="line"><span class="built_in">print</span>(parse_qsl(query))</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">[(<span class="string">'name'</span>, <span class="string">'germey'</span>), (<span class="string">'age'</span>, <span class="string">'22'</span>)]</span><br></pre></td></tr></tbody></table></figure><h3 id="quote-URL-编码"><a href="#quote-URL-编码" class="headerlink" title="quote  -URL 编码"></a>quote  -URL 编码</h3><p>将内容（中文）转化为 URL 编码的格式</p><p>示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote  </span><br><span class="line"></span><br><span class="line">keyword = <span class="string">' 壁纸 '</span>  </span><br><span class="line">url = <span class="string">'https://www.baidu.com/s?wd='</span> + quote(keyword)  </span><br><span class="line"><span class="built_in">print</span>(url)</span><br></pre></td></tr></tbody></table></figure><p>这里我们声明了一个中文的搜索文字，然后用 quote 方法对其进行 URL 编码，最后得到的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.baidu.com/s?wd=% E5% A3%81% E7% BA% B8</span><br></pre></td></tr></tbody></table></figure><h3 id="unquote-–URL-解码"><a href="#unquote-–URL-解码" class="headerlink" title="unquote  –URL 解码"></a>unquote  –URL 解码</h3><p>进行 URL 解码，示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote  </span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.baidu.com/s?wd=% E5% A3%81% E7% BA% B8'</span>  </span><br><span class="line"><span class="built_in">print</span>(unquote(url))</span><br></pre></td></tr></tbody></table></figure><p>这是上面得到的 URL 编码后的结果，这里利用 unquote 方法还原，结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.baidu.com/s?wd = 壁纸</span><br></pre></td></tr></tbody></table></figure><h2 id="分析Robots"><a href="#分析Robots" class="headerlink" title="分析Robots"></a>分析Robots</h2><h3 id="Robots-协议"><a href="#Robots-协议" class="headerlink" title="Robots 协议"></a>Robots 协议</h3><p>Robots 协议也称作爬虫协议，用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取。它通常是一个叫作 robots.txt 的文本文件，一般放在网站的根目录下。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#其设置为 * 则代表该协议对任何爬取爬虫有效</span></span><br><span class="line">User-agent: *         </span><br><span class="line"><span class="comment">#指定了不允许抓取的目录，比如上例子中设置为 / 则代表不允许抓取所有页面。</span></span><br><span class="line">Disallow: /  </span><br><span class="line"><span class="comment">#Allow一般不会单独使用，用来排除某些限制,表示只可以抓取 public 目录</span></span><br><span class="line">Allow: /public/</span><br></pre></td></tr></tbody></table></figure><h3 id="爬虫名称"><a href="#爬虫名称" class="headerlink" title="爬虫名称"></a>爬虫名称</h3><p>一些常见搜索爬虫的名称及其对应的网站</p><table><thead><tr><th>爬虫名称</th><th>名　　称</th><th>网　　站</th></tr></thead><tbody><tr><td>BaiduSpider</td><td>百度</td><td><a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td>Googlebot</td><td>谷歌</td><td><a href="http://www.google.com/">www.google.com</a></td></tr><tr><td>360Spider</td><td>360 搜索</td><td><a href="http://www.so.com/">www.so.com</a></td></tr><tr><td>YodaoBot</td><td>有道</td><td><a href="http://www.youdao.com/">www.youdao.com</a></td></tr><tr><td>ia_archiver</td><td>Alexa</td><td><a href="http://www.alexa.cn/">www.alexa.cn</a></td></tr><tr><td>Scooter</td><td>altavista</td><td><a href="http://www.altavista.com/">www.altavista.com</a></td></tr></tbody></table><h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h3><p>使用 robotparser 模块来解析 robots.txt</p><ul><li><p>构造方法  (very easy啦</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">urllib.robotparser.RobotFileParser(url=<span class="string">''</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>模块常用方法</p><ul><li>set_url ：用来设置 robots.txt 文件的链接</li><li>read：读取 robots.txt 文件并进行分析，一般为ture</li><li>parse：用来解析 robots.txt 文件</li><li>can_fetch：该方法传入两个参数 User-agent&amp; URL。返回的内容是该搜索引擎是否可以抓取这个 URL，返回结果是 True 或 False</li><li>mtime：返回的是上次抓取和分析 robots.txt 的时间</li><li>modified：将当前时间设置为上次抓取和分析 robots.txt 的时间</li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.robotparser <span class="keyword">import</span> RobotFileParser</span><br><span class="line">rp = RobotFileParser()</span><br><span class="line"><span class="comment">#rp = RobotFileParser('http://www.jianshu.com/robots.txt')</span></span><br><span class="line">rp.set_url(<span class="string">'http://www.jianshu.com/robots.txt'</span>)</span><br><span class="line">rp.read()</span><br><span class="line"><span class="comment">#也可以使用 parse 方法执行读取和分析</span></span><br><span class="line"><span class="comment">#rp.parse(urlopen('http://www.jianshu.com/robots.txt').read().decode('utf-8').split('\n'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用 can_fetch 方法判断了网页是否可以被抓取   True + False</span></span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">'*'</span>, <span class="string">'http://www.jianshu.com/p/b67554025d7d'</span>))</span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">'*'</span>, <span class="string">"http://www.jianshu.com/search?q=python&amp;page=1&amp;type=collections"</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="request和urllib的区别"><a href="#request和urllib的区别" class="headerlink" title="request和urllib的区别"></a>request和urllib的区别</h1><ul><li>urllib 是Python标准库中的模块，不需要安装额外的包</li><li>request是一个三方库，它在<code>urllib</code>的基础上提供了更简洁、更高级的接口和功能。<code>requests</code>库的设计目标是提供更人性化的API，使发送HTTP请求变得更加简单和方便。它支持更多的HTTP功能，例如自动处理重定向、会话管理、上传文件、处理Cookies等</li><li>需要进行HTTP请求的基本操作，学习和使用<code>requests</code>库会更加便捷和高效。如果你对Python标准库感兴趣，或者有特定的需求需要使用<code>urllib</code>的功能，也可以深入学习<code>urllib</code>库。</li><li>需要进行HTTP请求的基本操作，学习和使用<code>requests</code>库会更加便捷和高效。如果你对Python标准库感兴趣，或者有特定的需求需要使用<code>urllib</code>的功能，也可以深入学习<code>urllib</code>库。</li></ul><h1 id="使用-requests"><a href="#使用-requests" class="headerlink" title="使用 requests"></a>使用 requests</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="GET请求方法"><a href="#GET请求方法" class="headerlink" title="GET请求方法:"></a>GET请求方法:</h3><ul><li><p>基本用法 </p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/get'</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r))  </span><br><span class="line"><span class="built_in">print</span>(r.status_code)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.text))  </span><br><span class="line"><span class="built_in">print</span>(r.text)  </span><br><span class="line"><span class="built_in">print</span>(r.cookies)</span><br></pre></td></tr></tbody></table></figure><p>  调用 get 方法得到一个 Response 对象，然后分别输出了 Response 的类型、状态码、响应体的类型、内容以及 Cookies。</p></li><li><p>利用 params 参数附加额外信息</p><p>  请求的链接自动被构造成了：<a href="http://httpbin.org/get?age=22&amp;name=germey">http://httpbin.org/get?age=22&amp;name=germey</a>。</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"></span><br><span class="line">data = {  </span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'germey'</span>,  </span><br><span class="line">    <span class="string">'age'</span>: <span class="number">22</span>  </span><br><span class="line">}  </span><br><span class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=data)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.text))  </span><br><span class="line"><span class="comment">#返回类型是str类型的json格式，使用json方法解析返回结果，得到字典格式，如果返回结果不是JSON格式，会抛出json.decoder.JSONDecodeError异常</span></span><br><span class="line"><span class="built_in">print</span>(r.json())  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.json()))</span><br></pre></td></tr></tbody></table></figure></li><li><p>获取图片、音频和视频文件</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">"https://github.com/favicon.ico"</span>)</span><br><span class="line"><span class="comment">#wb：二进制写的形式打开</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'favicon.ico'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(r.content)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="其他请求方法："><a href="#其他请求方法：" class="headerlink" title="其他请求方法："></a>其他请求方法：</h3><ul><li><p>直接  .请求方法</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>)  </span><br><span class="line">r = requests.put(<span class="string">'http://httpbin.org/put'</span>)  </span><br><span class="line">r = requests.delete(<span class="string">'http://httpbin.org/delete'</span>)  </span><br><span class="line">r = requests.head(<span class="string">'http://httpbin.org/get'</span>)  </span><br><span class="line">r = requests.options(<span class="string">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>POST请求方法示例</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">data = {<span class="string">'name'</span>: <span class="string">'germey'</span>, <span class="string">'age'</span>: <span class="string">'22'</span>}</span><br><span class="line">r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=data)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure><p>运行结果的 form 部分就是提交的数据，这就证明 POST 请求发送成功</p></li></ul><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://www.jianshu.com'</span>)</span><br><span class="line"><span class="comment">#状态码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.status_code), r.status_code)</span><br><span class="line"><span class="comment">#响应头   --CaseInsensitiveDict 类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.headers), r.headers)</span><br><span class="line"><span class="comment">#cookies  --RequestsCookieJar 类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.cookies), r.cookies)</span><br><span class="line"><span class="comment">#URL</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.url), r.url)</span><br><span class="line"><span class="comment">#请求历史</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.history), r.history)</span><br><span class="line"><span class="comment">#状态码查询对象requests.codes</span></span><br><span class="line">exit() <span class="keyword">if</span> <span class="keyword">not</span> r.status_code == requests.codes.ok <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">'Request Successfully'</span>)</span><br></pre></td></tr></tbody></table></figure><p>下面列出了返回码和相应的查询条件：</p><figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line"># 信息性状态码  </span><br><span class="line">100: ('continue',),  </span><br><span class="line">101: ('switching_protocols',),  </span><br><span class="line">102: ('processing',),  </span><br><span class="line">103: ('checkpoint',),  </span><br><span class="line">122: ('uri_too_long', 'request_uri_too_long'),  </span><br><span class="line"></span><br><span class="line"># 成功状态码  </span><br><span class="line">200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\o/', '✓'),  </span><br><span class="line">201: ('created',),  </span><br><span class="line">202: ('accepted',),  </span><br><span class="line">203: ('non_authoritative_info', 'non_authoritative_information'),  </span><br><span class="line">204: ('no_content',),  </span><br><span class="line">205: ('reset_content', 'reset'),  </span><br><span class="line">206: ('partial_content', 'partial'),  </span><br><span class="line">207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),  </span><br><span class="line">208: ('already_reported',),  </span><br><span class="line">226: ('im_used',),  </span><br><span class="line"></span><br><span class="line"># 重定向状态码  </span><br><span class="line">300: ('multiple_choices',),  </span><br><span class="line">301: ('moved_permanently', 'moved', '\\o-'),  </span><br><span class="line">302: ('found',),  </span><br><span class="line">303: ('see_other', 'other'),  </span><br><span class="line">304: ('not_modified',),  </span><br><span class="line">305: ('use_proxy',),  </span><br><span class="line">306: ('switch_proxy',),  </span><br><span class="line">307: ('temporary_redirect', 'temporary_moved', 'temporary'),  </span><br><span class="line">308: ('permanent_redirect',  </span><br><span class="line">      'resume_incomplete', 'resume',), # These 2 to be removed in 3.0  </span><br><span class="line"></span><br><span class="line"># 客户端错误状态码  </span><br><span class="line">400: ('bad_request', 'bad'),  </span><br><span class="line">401: ('unauthorized',),  </span><br><span class="line">402: ('payment_required', 'payment'),  </span><br><span class="line">403: ('forbidden',),  </span><br><span class="line">404: ('not_found', '-o-'),  </span><br><span class="line">405: ('method_not_allowed', 'not_allowed'),  </span><br><span class="line">406: ('not_acceptable',),  </span><br><span class="line">407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),  </span><br><span class="line">408: ('request_timeout', 'timeout'),  </span><br><span class="line">409: ('conflict',),  </span><br><span class="line">410: ('gone',),  </span><br><span class="line">411: ('length_required',),  </span><br><span class="line">412: ('precondition_failed', 'precondition'),  </span><br><span class="line">413: ('request_entity_too_large',),  </span><br><span class="line">414: ('request_uri_too_large',),  </span><br><span class="line">415: ('unsupported_media_type', 'unsupported_media', 'media_type'),  </span><br><span class="line">416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),  </span><br><span class="line">417: ('expectation_failed',),  </span><br><span class="line">418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),  </span><br><span class="line">421: ('misdirected_request',),  </span><br><span class="line">422: ('unprocessable_entity', 'unprocessable'),  </span><br><span class="line">423: ('locked',),  </span><br><span class="line">424: ('failed_dependency', 'dependency'),  </span><br><span class="line">425: ('unordered_collection', 'unordered'),  </span><br><span class="line">426: ('upgrade_required', 'upgrade'),  </span><br><span class="line">428: ('precondition_required', 'precondition'),  </span><br><span class="line">429: ('too_many_requests', 'too_many'),  </span><br><span class="line">431: ('header_fields_too_large', 'fields_too_large'),  </span><br><span class="line">444: ('no_response', 'none'),  </span><br><span class="line">449: ('retry_with', 'retry'),  </span><br><span class="line">450: ('blocked_by_windows_parental_controls', 'parental_controls'),  </span><br><span class="line">451: ('unavailable_for_legal_reasons', 'legal_reasons'),  </span><br><span class="line">499: ('client_closed_request',),  </span><br><span class="line"></span><br><span class="line"># 服务端错误状态码  </span><br><span class="line">500: ('internal_server_error', 'server_error', '/o\\', '✗'),  </span><br><span class="line">501: ('not_implemented',),  </span><br><span class="line">502: ('bad_gateway',),  </span><br><span class="line">503: ('service_unavailable', 'unavailable'),  </span><br><span class="line">504: ('gateway_timeout',),  </span><br><span class="line">505: ('http_version_not_supported', 'http_version'),  </span><br><span class="line">506: ('variant_also_negotiates',),  </span><br><span class="line">507: ('insufficient_storage',),  </span><br><span class="line">509: ('bandwidth_limit_exceeded', 'bandwidth'),  </span><br><span class="line">510: ('not_extended',),  </span><br><span class="line">511: ('network_authentication_required', 'network_auth', 'network_authentication')</span><br></pre></td></tr></tbody></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#rb -只读二进制打开文件</span></span><br><span class="line">files = {<span class="string">'file'</span>: <span class="built_in">open</span>(<span class="string">'favicon.ico'</span>, <span class="string">'rb'</span>)}</span><br><span class="line"><span class="comment">#post方法--提交数据</span></span><br><span class="line"><span class="comment">#将打开的文件favicon.ico作为文件对象传递给requests.post()方法，以进行文件上传。</span></span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, files=files)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="comment">#返回响应，里面包含 files 这个字段</span></span><br></pre></td></tr></tbody></table></figure><h3 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h3><ul><li><p>获取cookies</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">  r = requests.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">  <span class="built_in">print</span>(r.cookies)</span><br><span class="line">  <span class="comment">#用items方法转化成元组 ，遍历输出每一个cookies的名称和值</span></span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> r.cookies.items():</span><br><span class="line">      <span class="built_in">print</span>(key + <span class="string">'='</span> + value)</span><br><span class="line">  ````</span><br><span class="line"></span><br><span class="line">- 设置cookies并维持登录状态</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">  headers = {</span><br><span class="line">      <span class="string">'Cookie'</span>: <span class="string">'q_c1=31653b264a074fc9a57816d1ea93ed8b|1474273938000|1474273938000; d_c0="AGDAs254kAqPTr6NW1U3XTLFzKhMPQ6H_nc=|1474273938"; __utmv=51854390.100-1|2=registration_date=20130902=1^3=entry_date=20130902=1;a_t="2.0AACAfbwdAAAXAAAAso0QWAAAgH28HQAAAGDAs254kAoXAAAAYQJVTQ4FCVgA360us8BAklzLYNEHUd6kmHtRQX5a6hiZxKCynnycerLQ3gIkoJLOCQ==";z_c0=Mi4wQUFDQWZid2RBQUFBWU1DemJuaVFDaGNBQUFCaEFsVk5EZ1VKV0FEZnJTNnp3RUNTWE10ZzBRZFIzcVNZZTFGQmZn|1474887858|64b4d4234a21de774c42c837fe0b672fdb5763b0'</span>,</span><br><span class="line">      <span class="string">'Host'</span>: <span class="string">'www.zhihu.com'</span>,</span><br><span class="line">      <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span>,</span><br><span class="line">  }</span><br><span class="line">  r = requests.get(<span class="string">'https://www.zhihu.com'</span>, headers=headers)</span><br><span class="line">  <span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用Cookies参数设置Cookies的方法</p><p>新建一个 RequestCookieJar 对象–&gt;将复制下来的 cookies 利用 split 方法分割–&gt;利用 set 方法设置好每个 Cookie 的 key 和 value–&gt;通过调用 requests 的 get() 方法并传递给 cookies 参数【可以但没必要？】</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookies = <span class="string">'q_c1=31653b264a074fc9a57816d1ea93ed8b|1474273938000|1474273938000; d_c0="AGDAs254kAqPTr6NW1U3XTLFzKhMPQ6H_nc=|1474273938"; __utmv=51854390.100-1|2=registration_date=20130902=1^3=entry_date=20130902=1;a_t="2.0AACAfbwdAAAXAAAAso0QWAAAgH28HQAAAGDAs254kAoXAAAAYQJVTQ4FCVgA360us8BAklzLYNEHUd6kmHtRQX5a6hiZxKCynnycerLQ3gIkoJLOCQ==";z_c0=Mi4wQUFDQWZid2RBQUFBWU1DemJuaVFDaGNBQUFCaEFsVk5EZ1VKV0FEZnJTNnp3RUNTWE10ZzBRZFIzcVNZZTFGQmZn|1474887858|64b4d4234a21de774c42c837fe0b672fdb5763b0'</span></span><br><span class="line">jar = requests.cookies.RequestsCookieJar()</span><br><span class="line">headers = {</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'www.zhihu.com'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies.split(<span class="string">';'</span>):</span><br><span class="line">    key, value = cookie.split(<span class="string">'='</span>, <span class="number">1</span>)</span><br><span class="line">    jar.<span class="built_in">set</span>(key, value)</span><br><span class="line">r = requests.get(<span class="string">'http://www.zhihu.com'</span>, cookies=jar, headers=headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h3><p>会话维持是指在进行多个请求时，保持相同的会话状态，而不是每个请求都创建一个新的会话。</p><p>解决问题：：第一个请求使用<code>post</code>方法登录了一个网站，然后想要获取登录后的个人信息，你再次使用<code>get</code>方法请求个人信息页面。实际上，这相当于在两个独立的会话中操作，它们并不相关，所以无法成功获取个人信息。</p><p>有一种解决方法是在每次请求时手动设置相同的Cookies，但这样做非常麻烦。我们有更简单的解决方法，那就是使用<code>Session</code>对象。</p><p><code>Session</code>对象可以方便地维护一个会话，并自动处理Cookies的问题。通过创建一个<code>Session</code>对象，我们可以在同一个会话中发送多个请求，会话对象会自动处理Cookies的传递和存储。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line"><span class="comment">#请求了一个测试网址，设置一个cookie名称叫作 number，内容是 123456789</span></span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line"><span class="comment">#随后又请求了http://httpbin.org/cookies，此网址可以获取当前的 Cookies</span></span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure><p>运行结果：(运行的好慢，建议直接点进网址)</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "cookies": {"number": "123456789"}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="SSL-证书验证"><a href="#SSL-证书验证" class="headerlink" title="SSL 证书验证"></a>SSL 证书验证</h3><p>当发送 HTTP 请求的时候，requests 会提供验证SSL 证书功能。通过<code>verify</code>参数控制是否验证证书，默认情况下<code>verify</code>为<code>True</code>，会自动验证证书。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line"><span class="comment">#当禁用证书验证或出现其他安全相关警告时，禁用urllib3库的警告信息来忽略警告</span></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">response = requests.get(<span class="string">'https://www.12306.cn'</span>, verify=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br></pre></td></tr></tbody></table></figure><p>指定本地证书用作客户端证书：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">'https://www.12306.cn'</span>, cert=(<span class="string">'/path/server.crt'</span>, <span class="string">'/path/key'</span>))</span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br></pre></td></tr></tbody></table></figure><h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><ul><li><p>proxies参数</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = {<span class="string">'https'</span>: <span class="string">'http://user:password@10.10.1.10:3128/'</span>,}</span><br><span class="line">requests.get(<span class="string">'https://www.taobao.com'</span>, proxies=proxies)</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用 HTTP Basic Auth</p>  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">proxies = {<span class="string">'https'</span>: <span class="string">'http://user:password@10.10.1.10:3128/'</span>,}</span><br><span class="line">requests.get(<span class="string">'https://www.taobao.com'</span>, proxies=proxies)</span><br></pre></td></tr></tbody></table></figure></li><li><p>SOCKS 协议的代理  <code>pip3 install "requests[socks]" </code></p> <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">   </span><br><span class="line">proxies = {</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'socks5://user:password@host:port'</span>,</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'socks5://user:password@host:port'</span></span><br><span class="line">}</span><br><span class="line">requests.get(<span class="string">'https://www.taobao.com'</span>, proxies=proxies)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><p>timeout参数</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#timeout=(5, 30)  连接+读取分别指定时间</span></span><br><span class="line">r = requests.get(<span class="string">'https://www.taobao.com'</span>, timeout=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></tbody></table></figure><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://localhost:5000'</span>, auth=(<span class="string">'username'</span>, <span class="string">'password'</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></tbody></table></figure><p>OAuth 认证   <code>pip3 install requests_oauthlib</code></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests_oauthlib <span class="keyword">import</span> OAuth1</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://api.twitter.com/1.1/account/verify_credentials.json'</span></span><br><span class="line">auth = OAuth1(<span class="string">'YOUR_APP_KEY'</span>, <span class="string">'YOUR_APP_SECRET'</span>,</span><br><span class="line">              <span class="string">'USER_OAUTH_TOKEN'</span>, <span class="string">'USER_OAUTH_TOKEN_SECRET'</span>)</span><br><span class="line">requests.get(url, auth=auth)</span><br></pre></td></tr></tbody></table></figure><h3 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h3><p>目的：</p><ol><li>请求定制化：可以设置请求的URL、请求方法、请求数据、请求头、超时时间等各种参数，以满足具体的需求</li><li>请求队列调度：可以将多个<code>Prepared Request</code>对象放入队列中，并按照一定的策略进行调度和发送，实现批量处理请求、并发请求、异步请求等功能，提高请求的效率和性能</li><li>会话状态保持：在一个会话中，你可以发送多个请求，并共享会话级别的参数，如cookies、认证信息等。这对于模拟登录、进行会话管理以及处理需要会话保持的操作非常有用</li></ol><p>构造<code>Prepared Request</code>对象  –  发送<code>Prepared Request</code></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">data = {<span class="string">'name'</span>: <span class="string">'germey'</span>}</span><br><span class="line">headers = {<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span></span><br><span class="line">}</span><br><span class="line">s = Session()</span><br><span class="line">req = Request(<span class="string">'POST'</span>, url, data=data, headers=headers)</span><br><span class="line"><span class="comment">#调用 Session 的 prepare_request 方法将其转换为一个 Prepared Request 对象   --  将请求表示为数据结构</span></span><br><span class="line">prepped = s.prepare_request(req)</span><br><span class="line"><span class="comment">#发送`Prepared Request`</span></span><br><span class="line">r = s.send(prepped)</span><br><span class="line"><span class="comment">#获取请求结果</span></span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">{</span><span class="punctuation">}</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">"data"</span><span class="punctuation">:</span> <span class="string">""</span><span class="punctuation">,</span><span class="attr">"files"</span><span class="punctuation">:</span> <span class="punctuation">{</span><span class="punctuation">}</span><span class="punctuation">,</span><span class="attr">"form"</span><span class="punctuation">:</span> <span class="punctuation">{</span><span class="attr">"name"</span><span class="punctuation">:</span><span class="string">"germey"</span><span class="punctuation">}</span><span class="punctuation">,</span><span class="attr">"headers"</span><span class="punctuation">:</span> <span class="punctuation">{</span><span class="attr">"Accept"</span><span class="punctuation">:</span><span class="string">"*/*"</span><span class="punctuation">,</span><span class="attr">"Accept-Encoding"</span><span class="punctuation">:</span><span class="string">"gzip, deflate"</span><span class="punctuation">,</span><span class="attr">"Connection"</span><span class="punctuation">:</span><span class="string">"close"</span><span class="punctuation">,</span><span class="attr">"Content-Length"</span><span class="punctuation">:</span><span class="string">"11"</span><span class="punctuation">,</span><span class="attr">"Content-Type"</span><span class="punctuation">:</span><span class="string">"application/x-www-form-urlencoded"</span><span class="punctuation">,</span><span class="attr">"Host"</span><span class="punctuation">:</span><span class="string">"httpbin.org"</span><span class="punctuation">,</span><span class="attr">"User-Agent"</span><span class="punctuation">:</span><span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36"</span><span class="punctuation">}</span><span class="punctuation">,</span><span class="attr">"json"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">"origin"</span><span class="punctuation">:</span><span class="string">"182.32.203.166"</span><span class="punctuation">,</span><span class="attr">"url"</span><span class="punctuation">:</span><span class="string">"http://httpbin.org/post"</span><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="常用的匹配规则"><a href="#常用的匹配规则" class="headerlink" title="常用的匹配规则"></a>常用的匹配规则</h2><table><thead><tr><th>模　　式</th><th>描　　述</th></tr></thead><tbody><tr><td>\w</td><td>匹配字母、数字及下划线</td></tr><tr><td>\W</td><td>匹配不是字母、数字及下划线的字符</td></tr><tr><td>\s</td><td>匹配任意空白字符，等价于 [\t\n\r\f]</td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于 [0-9]</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\A</td><td>匹配字符串开头</td></tr><tr><td>\Z</td><td>匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td></tr><tr><td>\z</td><td>匹配字符串结尾，如果存在换行，同时还会匹配换行符</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>^</td><td>匹配一行字符串的开头</td></tr><tr><td>$</td><td>匹配一行字符串的结尾</td></tr><tr><td>.</td><td>匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符</td></tr><tr><td>[…]</td><td>用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k</td></tr><tr><td>[^…]</td><td>不在 [] 中的字符，比如 [^abc] 匹配除了 a、b、c 之外的字符</td></tr><tr><td>*</td><td>匹配 0 个或多个表达式</td></tr><tr><td>+</td><td>匹配 1 个或多个表达式</td></tr><tr><td>?</td><td>匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td>{n}</td><td>精确匹配 n 个前面的表达式</td></tr><tr><td>{n, m}</td><td>匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式</td></tr><tr><td>a</td><td>b</td></tr><tr><td>( )</td><td>匹配括号内的表达式，也表示一个组</td></tr></tbody></table><h2 id="match-：从头找"><a href="#match-：从头找" class="headerlink" title="match ：从头找"></a>match ：从头找</h2><h3 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h3><p>如果匹配，就返回匹配成功的结果；如果不匹配，就返回 None</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">'^Hello\s\d\d\d\s\d{4}\s\w{10}'</span>, content)</span><br><span class="line"><span class="comment">#^ 是匹配字符串的开头，也就是以 Hello 开头</span></span><br><span class="line"><span class="comment">#\s 匹配空白字符</span></span><br><span class="line"><span class="comment">#\d 匹配数字 \d{4}匹配 4 个数字</span></span><br><span class="line"><span class="comment">#\w{10} 匹配 10 个字母及下划线</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">#SRE_Match 对象的group方法：匹配的内容</span></span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br><span class="line"><span class="comment">#span方法：匹配的范围</span></span><br><span class="line"><span class="built_in">print</span>(result.span())</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">41</span></span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">25</span>), <span class="keyword">match</span>=<span class="string">'Hello 123 4567 World_This'</span>&gt;</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This</span><br><span class="line">(<span class="number">0</span>, <span class="number">25</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配(./*)"></a>通用匹配(./*)</h3><p>.(点)匹配任意字符</p><p><em>(星)匹配前面的字符*<em>无限次</em></em></p><p>组合在一起就可以匹配任意字符( •̀ ω •́ )y</p><h3 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h3><p>.*：贪婪匹配，匹配尽可能多字符</p><p>.*?：非贪婪匹配，匹配尽量少字符</p><p>在做匹配的时候字符串中间尽量使用非贪婪匹配，以避免出现匹配结果缺失的情况</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table><thead><tr><th>修饰符</th><th>描　　述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使。匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据 Unicode 字符集解析字符。这个标志影响 \w、\W、\b 和 \B</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td></tr></tbody></table><p>在网页匹配中，较为常用的有 re.S 和 re.I</p><h3 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配 \"></a>转义匹配 \</h3><h2 id="search-：找一个"><a href="#search-：找一个" class="headerlink" title="search ：找一个"></a>search ：找一个</h2><p>在匹配时会扫描整个字符串，然后<strong>返回第一个成功匹配的结果</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'</span></span><br><span class="line">result = re.search(<span class="string">'Hello.*?(\d+).*?Demo'</span>, content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></tbody></table></figure><h2 id="findall-：找全部"><a href="#findall-：找全部" class="headerlink" title="findall ：找全部"></a>findall ：找全部</h2><p>返回列表类型，遍历获得每组内容</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">results = re.findall(<span class="string">'&lt;li.*?href="(.*?)".*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html, re.S)</span><br><span class="line"><span class="built_in">print</span>(results)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(results))  </span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:  </span><br><span class="line">    <span class="built_in">print</span>(result)  </span><br><span class="line">    <span class="built_in">print</span>(result[<span class="number">0</span>], result[<span class="number">1</span>], result[<span class="number">2</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="sub-：删除"><a href="#sub-：删除" class="headerlink" title="sub ：删除"></a>sub ：删除</h2><p>删除匹配到的文本</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#删掉数字</span></span><br><span class="line">content = <span class="string">'54aK54yr5oiR54ix5L2g'</span></span><br><span class="line">content = re.sub(<span class="string">'\d+'</span>, <span class="string">''</span>, content)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></tbody></table></figure><h2 id="compile-：复用"><a href="#compile-：复用" class="headerlink" title="compile ：复用"></a>compile ：复用</h2><p>将正则字符串编译成正则表达式对象，相当于做了一层封装，以便服用</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content1 = <span class="string">'2016-12-15 12:00'</span></span><br><span class="line">content2 = <span class="string">'2016-12-17 12:55'</span></span><br><span class="line">content3 = <span class="string">'2016-12-22 13:21'</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">'\d{2}:\d{2}'</span>)</span><br><span class="line">result1 = re.sub(pattern, <span class="string">''</span>, content1)</span><br><span class="line">result2 = re.sub(pattern, <span class="string">''</span>, content2)</span><br><span class="line">result3 = re.sub(pattern, <span class="string">''</span>, content3)</span><br><span class="line"><span class="built_in">print</span>(result1, result2, result3)</span><br></pre></td></tr></tbody></table></figure><h2 id="方法技巧"><a href="#方法技巧" class="headerlink" title="方法技巧"></a>方法技巧</h2><p><strong>在做匹配的时候，字符串中间尽量使用非贪婪匹配</strong></p><p>match：<strong>更适合用来检测某个字符串是否符合某个正则表达式的规则</strong></p><p>search：<strong>匹配方便</strong></p><p>findall：<strong>要提取多个内容时</strong></p><h1 id="案例：抓取猫眼电影排行"><a href="#案例：抓取猫眼电影排行" class="headerlink" title="案例：抓取猫眼电影排行"></a>案例：抓取猫眼电影排行</h1><p>先浅写一个思路</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>提取出猫眼电影 TOP100 的电影名称、时间、评分、图片等信息，提取的站点 URL 为 <a href="http://maoyan.com/board/4">http://maoyan.com/board/4</a>，提取的结果会以文件形式保存下来。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><a href="http://maoyan.com/board/4?offset=10">http://maoyan.com/board/4?offset=10</a>   的offset 代表偏移量值</p><h2 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.获取首页代码内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_one_page</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        headers = {</span><br><span class="line">            <span class="string">'Cookie'</span>: <span class="string">''</span>,</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                          <span class="string">'Chrome/73.0.3683.86 Safari/537.36'</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建Chrome浏览器的实例</span></span><br><span class="line">        driver = webdriver.Chrome()</span><br><span class="line">        driver.get(url)</span><br><span class="line">        <span class="comment"># 等待页面加载完成</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 获取页面内容</span></span><br><span class="line">        content = driver.page_source</span><br><span class="line">        driver.quit()</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment">#     response = requests.get(url, headers=headers)</span></span><br><span class="line">    <span class="comment">#     if response.status_code == 200:</span></span><br><span class="line">    <span class="comment">#         return response.text</span></span><br><span class="line">    <span class="comment"># except RequestException:</span></span><br><span class="line">    <span class="comment">#     return None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.正则获取相关内容，并进行格式处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_one_page</span>(<span class="params">html</span>):</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(</span><br><span class="line">        <span class="string">'&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>,</span><br><span class="line">        re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> {<span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">               <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">               <span class="string">'title'</span>: item[<span class="number">2</span>],</span><br><span class="line">               <span class="string">'actor'</span>: item[<span class="number">3</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">               <span class="string">'time'</span>: item[<span class="number">4</span>].strip()[<span class="number">5</span>:],</span><br><span class="line">               <span class="string">'score'</span>: item[<span class="number">5</span>] + item[<span class="number">6</span>]</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.写进文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_to_file</span>(<span class="params">content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'result.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">type</span>(json.dumps(content)))</span><br><span class="line">        f.write(json.dumps(content, ensure_ascii=<span class="literal">False</span>) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用main方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">offset</span>):</span><br><span class="line">    url = <span class="string">'http://maoyan.com/board/4?offset='</span> + <span class="built_in">str</span>(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">        write_to_file(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页爬取</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        main(offset=i * <span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 速度过快，则会无响应</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>存在的问题：</p><ol><li><p>首页验证码登录  –请求头添加cookies</p></li><li><p>添加了反爬虫-验证拼图-暂未解决</p><p>用selenium打开浏览器，进行了11-50页面的滑动验证，能保证代码继续运行，但是11-50的数据没有获得【？】</p><p>运行结果：<img src="/img/image-20230612220406176.png" alt="image-20230612220406176"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫-1.开发环境配置</title>
      <link href="/posts/50c7/"/>
      <url>/posts/50c7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>第一次装到tesserocr就累了╯︿╰，一开始根本不需要用装这么多  –2023.6.10  13:58:2</p></blockquote><h1 id="请求库的安装"><a href="#请求库的安装" class="headerlink" title="请求库的安装"></a>请求库的安装</h1><h2 id="requests安装"><a href="#requests安装" class="headerlink" title="requests安装"></a>requests安装</h2><ul><li><code>pip3 install requests</code></li><li>用于发送 HTTP 请求和处理响应</li><li>可以方便地进行 GET、POST 等请求，设置请求头、请求参数、处理响应结果等操作。</li><li>验证安装：进入python 输入<code>import requests</code>，如无错误提示即成功</li></ul><h2 id="selenium安装"><a href="#selenium安装" class="headerlink" title="selenium安装"></a>selenium安装</h2><ul><li><code>pip3 install selenium</code></li><li>模拟用户在浏览器中的操作,包括点击、输入、提交表单等</li><li>可以驱动真实的浏览器（如 Chrome、Firefox）来加载动态生成的网页内容，并提取或交互其中的数据。通常与浏览器驱动配合使用，如 ChromeDriver 和 GeckoDriver。</li><li>验证安装：同上</li></ul><h2 id="ChromeDriver-安装"><a href="#ChromeDriver-安装" class="headerlink" title="ChromeDriver 安装"></a>ChromeDriver 安装</h2><ul><li><p>浏览器驱动,用于控制 Chrome  浏览器的行为</p></li><li><p>作用：让 <code>selenium</code> 可以控制和与指定的浏览器进行交互</p></li><li><p><a href="https://sites.google.com/a/chromium.org/chromedriver">https://sites.google.com/a/chromium.org/chromedriver</a>  –exe文件放入环境变量配置</p></li><li><p>GeckoDriver 安装  –适用于 Firefox</p></li><li><p>验证安装：</p><ul><li><p>环境变量：终端输入<code>chromedriver</code></p></li><li><p>使用：  打开浏览器</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br></pre></td></tr></tbody></table></figure></li><li><p>出现闪退计版本出现问题【但是我在其他代码上用又不会闪退🤔–待解决】</p></li></ul></li></ul><h2 id="PhantomJS安装-【不维护了】"><a href="#PhantomJS安装-【不维护了】" class="headerlink" title="PhantomJS安装  【不维护了】"></a>PhantomJS安装  【不维护了】</h2><ul><li><p>无界面的浏览器</p></li><li><p>在后台执行网页加载和操作，无需显示浏览器界面</p></li><li><p><a href="http://phantomjs.org/download.html">http://phantomjs.org/download.html</a>  –放入环境变量配置</p></li><li><p>验证安装</p><ul><li><p>环境变量：终端输入<code>phantomjs</code></p></li><li><p>使用</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.PhantomJS()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.current_url)</span><br></pre></td></tr></tbody></table></figure></li><li><p>报错显示<code>module 'selenium.webdriver' has no attribute 'PhantomJS'</code>    –由于维护困难和性能问题，Selenium 社区决定不再支持 PhantomJS 驱动。</p></li><li><p>推荐使用无头浏览器（如 Chrome 或 Firefox）的 Headless 模式替代。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ChromeOptions 对象，并设置无界面模式</span></span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>)  <span class="comment"># 启用无界面模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Chrome WebDriver，将 ChromeOptions 作为参数传递</span></span><br><span class="line">browser = webdriver.Chrome(options=chrome_options)</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.current_url)</span><br><span class="line"></span><br><span class="line">browser.quit()  <span class="comment"># 关闭浏览器</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="aiohttp的安装"><a href="#aiohttp的安装" class="headerlink" title="aiohttp的安装"></a>aiohttp的安装</h2><ul><li><code>pip3 install aiohttp</code>   +   <code>pip3 install cchardet aiodns</code><ul><li>字符编码检测库 cchardet</li><li>加速 DNS 的解析库 aiodns</li></ul></li><li>基于异步请求的 HTTP 客户端/服务器框架，适用于高性能、高并发的网络请求场景</li><li>在处理大规模异步请求时具有优势，可以加快网络爬虫的速度。</li><li>验证安装：进入python输入<code>import aiohttp</code>，如无错误提示即成功</li></ul><h1 id="解析库的安装"><a href="#解析库的安装" class="headerlink" title="解析库的安装"></a>解析库的安装</h1><h2 id="lxml-的安装"><a href="#lxml-的安装" class="headerlink" title="lxml 的安装"></a>lxml 的安装</h2><ul><li><code>pip3 install lxml</code></li><li>支持 HTML 和 XML 的解析，支持 XPath 解析方式，而且解析效率非常高</li><li>验证安装：进入python 输入<code>import lxml</code>，如无错误提示即成功</li></ul><h2 id="Beautiful-Soup-的安装"><a href="#Beautiful-Soup-的安装" class="headerlink" title="Beautiful Soup 的安装"></a>Beautiful Soup 的安装</h2><ul><li><p><code>pip3 install beautifulsoup4</code></p></li><li><p>HTML 或 XML 的解析库，我们可以用它来方便地从网页中提取数据。它拥有强大的 API 和多样的解析方式</p></li><li><p>验证安装</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  </span><br><span class="line">soup = BeautifulSoup(<span class="string">'&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;'</span>, <span class="string">'lxml'</span>)  </span><br><span class="line"><span class="built_in">print</span>(soup.p.string)</span><br><span class="line"><span class="comment"># 输出hello即成功</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="pyquery-的安装"><a href="#pyquery-的安装" class="headerlink" title="pyquery 的安装"></a>pyquery 的安装</h2><ul><li><code>pip3 install pyquery</code></li><li>强大的网页解析工具，它提供了和 jQuery 类似的语法来解析 HTML 文档，支持 CSS 选择器</li><li>验证安装：进入python输入<code>import pyquery</code>，如无错误提示即成功</li></ul><h2 id="tesserocr-的安装"><a href="#tesserocr-的安装" class="headerlink" title="tesserocr 的安装"></a>tesserocr 的安装</h2><ul><li><a href="http://digi.bib.uni-mannheim.de/tesseract">http://digi.bib.uni-mannheim.de/tesseract</a> 下载不带 dev 的版本   + <code>pip3 install tesserocr pillow</code></li><li>用 OCR 来识别图形验证码</li></ul><h1 id="数据库的安装"><a href="#数据库的安装" class="headerlink" title="数据库的安装"></a>数据库的安装</h1><h2 id="MySQL-的安装"><a href="#MySQL-的安装" class="headerlink" title="MySQL 的安装"></a>MySQL 的安装</h2><p><a href="https://blog.csdn.net/SoloVersion/article/details/123760428">MySQL安装配置教程（超级详细、保姆级）_mysql安装教程_SoloVersion的博客-CSDN博客</a></p><h2 id="MongoDB-的安装"><a href="#MongoDB-的安装" class="headerlink" title="MongoDB 的安装"></a>MongoDB 的安装</h2><h2 id="Redis-的安装"><a href="#Redis-的安装" class="headerlink" title="Redis 的安装"></a>Redis 的安装</h2><h1 id="存储库的安装"><a href="#存储库的安装" class="headerlink" title="存储库的安装"></a>存储库的安装</h1><h2 id="PyMySQL-的安装"><a href="#PyMySQL-的安装" class="headerlink" title="PyMySQL  的安装"></a>PyMySQL  的安装</h2><h2 id="PyMongo-的安装"><a href="#PyMongo-的安装" class="headerlink" title="PyMongo 的安装"></a>PyMongo 的安装</h2><h2 id="redis-py-的安装"><a href="#redis-py-的安装" class="headerlink" title="redis-py 的安装"></a>redis-py 的安装</h2><h2 id="RedisDump-的安装"><a href="#RedisDump-的安装" class="headerlink" title="RedisDump 的安装"></a>RedisDump 的安装</h2><h1 id="Web-库的安装"><a href="#Web-库的安装" class="headerlink" title="Web 库的安装"></a>Web 库的安装</h1><h2 id="Flask-的安装"><a href="#Flask-的安装" class="headerlink" title="Flask 的安装"></a>Flask 的安装</h2><h2 id="Tornado-的安装"><a href="#Tornado-的安装" class="headerlink" title="Tornado 的安装"></a>Tornado 的安装</h2><h1 id="App-爬取相关库的安装"><a href="#App-爬取相关库的安装" class="headerlink" title="App 爬取相关库的安装"></a>App 爬取相关库的安装</h1><h2 id="Charles-的安装"><a href="#Charles-的安装" class="headerlink" title="Charles 的安装"></a>Charles 的安装</h2><h2 id="mitmproxy-的安装"><a href="#mitmproxy-的安装" class="headerlink" title="mitmproxy 的安装"></a>mitmproxy 的安装</h2><h2 id="Appium-的安装"><a href="#Appium-的安装" class="headerlink" title="Appium 的安装"></a>Appium 的安装</h2><h1 id="爬虫框架的安装"><a href="#爬虫框架的安装" class="headerlink" title="爬虫框架的安装"></a>爬虫框架的安装</h1><h2 id="pyspider-的安装"><a href="#pyspider-的安装" class="headerlink" title="pyspider 的安装"></a>pyspider 的安装</h2><h2 id="Scrapy-的安装"><a href="#Scrapy-的安装" class="headerlink" title="Scrapy 的安装"></a>Scrapy 的安装</h2><h2 id="Scrapy-Splash-的安装"><a href="#Scrapy-Splash-的安装" class="headerlink" title="Scrapy-Splash 的安装"></a>Scrapy-Splash 的安装</h2><h2 id="Scrapy-Redis-的安装"><a href="#Scrapy-Redis-的安装" class="headerlink" title="Scrapy-Redis 的安装"></a>Scrapy-Redis 的安装</h2><h1 id="部署相关库的安装"><a href="#部署相关库的安装" class="headerlink" title="部署相关库的安装"></a>部署相关库的安装</h1><h2 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h2><h2 id="Scrapyd-的安装"><a href="#Scrapyd-的安装" class="headerlink" title="Scrapyd 的安装"></a>Scrapyd 的安装</h2><h2 id="Scrapyd-Client-的安装"><a href="#Scrapyd-Client-的安装" class="headerlink" title="Scrapyd-Client 的安装"></a>Scrapyd-Client 的安装</h2><h2 id="Scrapyd-API-的安装"><a href="#Scrapyd-API-的安装" class="headerlink" title="Scrapyd API 的安装"></a>Scrapyd API 的安装</h2><h2 id="Scrapyrt-的安装"><a href="#Scrapyrt-的安装" class="headerlink" title="Scrapyrt 的安装"></a>Scrapyrt 的安装</h2><h2 id="Gerapy-的安装"><a href="#Gerapy-的安装" class="headerlink" title="Gerapy 的安装"></a>Gerapy 的安装</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫-2.爬虫基础</title>
      <link href="/posts/78a6/"/>
      <url>/posts/78a6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTP-基本原理"><a href="#HTTP-基本原理" class="headerlink" title="HTTP 基本原理"></a>HTTP 基本原理</h1><h2 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI&amp;URL"></a>URI&amp;URL</h2><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><ul><li>用于标识和定位资源的字符串序列</li><li>它是一种标准化的命名方式，用于唯一地标识一个资源，包括但不限于文件、网页、API 端点等</li><li>URI 是一个广义的概念，包括两个子集：URL 和 URN。</li></ul><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><ul><li>是 URI 的一种常见形式。它是一种特定格式的字符串，用于描述一个资源的位置（或地址）</li><li>提供了一种标准的方式来访问网络上的资源，例如网页、图片、文件等</li><li>例子：<code>https://www.example.com/index.html?id=12345</code><ul><li>协议是 HTTPS。</li><li>主机名是 <a href="http://www.example.com./">www.example.com。</a></li><li>路径是 /index.html。</li><li>查询参数是 id=12345。</li></ul></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>URI 和 URL 的区别在于 URI 是一个更广泛的概念，包含了所有用于标识和定位资源的方式。</li><li>而 URL 则是 URI 的一种具体实现形式。URL 提供了一种特定的语法和格式，用于指定资源的位置和访问方式</li></ul><h2 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h2><ul><li>网页的源代码 HTML 就可以称作超文本</li></ul><h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>协议类型</p></li><li><p>HTTP：超文本传输协议</p></li><li><p>HTTPS：HTTP 的安全版  ，HTTP 下加入 SSL 层</p></li></ul><h3 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h3><p>在浏览器中输入URL，回车之后浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来<br><img src="/img/image-20230610142848095.png" alt="image-20230610142848095"></p><p>网络请求具体含义<br><img src="/img/image-20230610143146951.png" alt="image-20230610143146951"></p><ul><li>第一列 Name：请求的名称，一般会将 URL 的最后一部分内容当作名称。</li><li>第二列 Status：响应的状态码，这里显示为 200，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。</li><li>第三列 Type：请求的文档类型。这里为 xhr，是一种在Web浏览器中进行异步数据传输的技术。它允许网页通过JavaScript发送HTTP请求并接收服务器返回的数据，而无需刷新整个页面</li><li>第四列 Initiator：请求源。用来标记请求是由哪个对象或进程发起的。</li><li>第五列 Size：从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示 from cache。</li><li>第六列 Time：发起请求到获取响应所用的总时间。</li><li>第七列 Waterfall：网络请求的可视化瀑布流。</li></ul><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><ul><li><p>GET      获取数据（访问网址</p></li><li><p>POST    发送数据（表单提取、上传文件</p></li><li><p>区别</p><ul><li>GET 请求中的参数包含在 URL 里面，数据可以在 URL 中看到</li><li>POST 请求的 URL 不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中</li><li>GET 请求提交的数据最多只有 1024 字节，而 POST 方式没有限制。</li></ul></li><li><p>其他请求方法</p><table><thead><tr><th>方　　法</th><th>描　　述</th></tr></thead><tbody><tr><td>GET</td><td>请求页面，并返回页面内容</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>CONNECT</td><td>把服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>本表参考：<a href="http://www.runoob.com/http/http-methods.html">http://www.runoob.com/http/http-methods.html</a>。</p></li></ul><h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址"></a>请求网址</h3><p>即统一资源定位符 URL，它可以唯一确定我们想请求的资源。</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>用来说明服务器要使用的附加信息，请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p><ul><li>Accept：指定客户端可以接受的响应内容的类型。服务器可以根据该头信息来确定发送何种类型的响应。</li><li>Accept-Language：指定客户端可接受的语言类型。</li><li>Accept-Encoding：指定客户端可接受的内容编码。</li><li>Host：用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。</li></ul><ul><li>User-Agent：可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。</li><li>Content-Type：指定请求或响应中的主体内容的类型。常见的值有text/plain、text/html、application/json等，用于指定文本、HTML、JSON等数据格式。更多对应关系可以查看此对照表：<a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a>。</li><li>Authorization：用于在请求中发送身份验证凭据，例如用户名和密码。常用于需要身份验证的请求，如访问受保护的资源。</li><li>Cookie：也常用复数形式 Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是 Cookies 的功劳。Cookies 里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上 Cookies 并将其发送给服务器，服务器通过 Cookies 识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li><li>Location：在重定向响应中使用，指定新的URL地址，用于将客户端重定向到其他位置。</li><li>Cache-Control：指定请求或响应的缓存行为，控制缓存的存储、验证和过期等策略。</li><li>Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。</li><li>Server：在服务器的响应中发送服务器的名称和版本信息。</li></ul><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>一般承载的内容是 POST 请求中的表单数据，对于 GET 请求请求体则为空。</p><p>请求体的格式：请求体可以使用多种格式来传输数据，常见Content-Type 和 POST 提交数据方式的关系包括：</p><ul><li>表单数据（Form Data）：使用<code>application/x-www-form-urlencoded</code>格式，类似于HTML表单的数据提交方式。</li><li>JSON数据：使用<code>application/json</code>格式，常用于发送结构化的数据对象。</li><li>文件上传：使用<code>multipart/form-data</code>格式，用于发送二进制文件数据。</li><li>XML数据：使用<code>text/xml</code>格式</li></ul><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>常见的错误代码及错误原因【感觉不用记这么多，找个简版的】</p><table><thead><tr><th>状态码</th><th>说　　明</th><th>详　　情</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换</td></tr><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一个源</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，内容被重置</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分请求</td></tr><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作</td></tr><tr><td>301</td><td>永久移动</td><td>请求的网页已永久移动到新位置，即永久重定向</td></tr><tr><td>302</td><td>临时移动</td><td>请求的网页暂时跳转到其他页面，即暂时重定向</td></tr><tr><td>303</td><td>查看其他位置</td><td>如果原来的请求是 POST，重定向目标文档应该通过 GET 提取</td></tr><tr><td>304</td><td>未修改</td><td>此次请求返回的网页未修改，继续使用上次的资源</td></tr><tr><td>305</td><td>使用代理</td><td>请求者应该使用代理访问该网页</td></tr><tr><td>307</td><td>临时重定向</td><td>请求的资源临时从其他位置响应</td></tr><tr><td>400</td><td>错误请求</td><td>服务器无法解析该请求</td></tr><tr><td>401</td><td>未授权</td><td>请求没有进行身份验证或验证未通过</td></tr><tr><td>403</td><td>禁止访问</td><td>服务器拒绝此请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的网页</td></tr><tr><td>405</td><td>方法禁用</td><td>服务器禁用了请求中指定的方法</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容响应请求的网页</td></tr><tr><td>407</td><td>需要代理授权</td><td>请求者需要使用代理授权</td></tr><tr><td>408</td><td>请求超时</td><td>服务器请求超时</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突</td></tr><tr><td>410</td><td>已删除</td><td>请求的资源已永久删除</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件</td></tr><tr><td>413</td><td>请求实体过大</td><td>请求实体过大，超出服务器的处理能力</td></tr><tr><td>414</td><td>请求 URI 过长</td><td>请求网址过长，服务器无法处理</td></tr><tr><td>415</td><td>不支持类型</td><td>请求格式不被请求页面支持</td></tr><tr><td>416</td><td>请求范围不符</td><td>页面无法提供请求的范围</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足期望请求标头字段的要求</td></tr><tr><td>500</td><td>服务器内部错误</td><td>服务器遇到错误，无法完成请求</td></tr><tr><td>501</td><td>未实现</td><td>服务器不具备完成请求的功能</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求</td></tr><tr><td>505</td><td>HTTP 版本不支持</td><td>服务器不支持请求中所用的 HTTP 协议版本</td></tr></tbody></table><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>简要说明一些常用的头信息。</p><ul><li>Date：标识响应产生的时间。</li><li>Last-Modified：指定资源的最后修改时间。</li><li>Content-Encoding：指定响应内容的编码。</li><li>Server：包含服务器的信息，比如名称、版本号等。</li><li>Content-Type：文档类型，指定返回的数据类型是什么，如 text/html 代表返回 HTML 文档，application/x-javascript 则代表返回 JavaScript 文件，image/jpeg 则代表返回图片。</li><li>Set-Cookie：设置 Cookies。响应头中的 Set-Cookie 告诉浏览器需要将此内容放在 Cookies 中，下次请求携带 Cookies 请求。</li><li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>网页的源代码，也就是响应体的内容，它是解析的目标</p><h1 id="Web网页基础"><a href="#Web网页基础" class="headerlink" title="Web网页基础"></a>Web网页基础</h1><h2 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h2><ul><li>HTML</li><li>CSS</li><li>JavaScript</li></ul><h2 id="网页的结构"><a href="#网页的结构" class="headerlink" title="网页的结构"></a>网页的结构</h2><p>就是HTML的结构啦</p><p><code>&lt;html&gt; </code> –<code>&lt;head&gt;</code> –<code>&lt;title&gt;</code>   ……</p><h2 id="节点树及节点间的关系"><a href="#节点树及节点间的关系" class="headerlink" title="节点树及节点间的关系"></a>节点树及节点间的关系</h2><p>通过 HTML DOM（针对 HTML 文档的标准模型），树中的所有节点均可通过 JavaScript 访问，所有 HTML 节点元素均可被修改，也可以被创建或删除。</p><p>节点树<br><img src="/img/image-20230610150803831.png" alt="image-20230610150803831"></p><p>节点树及节点间的关系<br><img src="/img/image-20230610150819021.png" alt="image-20230610150819021"></p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>在 CSS 中，我们使用 CSS 选择器来定位节点</p><p>CSS 选择器的其他语法规则</p><table><thead><tr><th>选　择　器</th><th>例　　子</th><th>例子描述</th></tr></thead><tbody><tr><td>.class</td><td>.intro</td><td>选择 class=”intro” 的所有节点</td></tr><tr><td>#id</td><td>#firstname</td><td>选择 id=”firstname” 的所有节点</td></tr><tr><td>*</td><td>*</td><td>选择所有节点</td></tr><tr><td>element</td><td>p</td><td>选择所有 p 节点</td></tr><tr><td>element,element</td><td>div,p</td><td>选择所有 div 节点和所有 p 节点</td></tr><tr><td>element element</td><td>div p</td><td>选择 div 节点内部的所有 p 节点</td></tr><tr><td>element&gt;element</td><td>div&gt;p</td><td>选择父节点为 div 节点的所有 p 节点</td></tr><tr><td>element+element</td><td>div+p</td><td>选择紧接在 div 节点之后的所有 p 节点</td></tr><tr><td>[attribute]</td><td>[target]</td><td>选择带有 target 属性的所有节点</td></tr><tr><td>[attribute=value]</td><td>[target=blank]</td><td>选择 target=”blank” 的所有节点</td></tr><tr><td>[attribute~=value]</td><td>[title~=flower]</td><td>选择 title 属性包含单词 flower 的所有节点</td></tr><tr><td>:link</td><td>a:link</td><td>选择所有未被访问的链接</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有已被访问的链接</td></tr><tr><td>:active</td><td>a:active</td><td>选择活动链接</td></tr><tr><td>:hover</td><td>a:hover</td><td>选择鼠标指针位于其上的链接</td></tr><tr><td>:focus</td><td>input:focus</td><td>选择获得焦点的 input 节点</td></tr><tr><td>:first-letter</td><td>p:first-letter</td><td>选择每个 p 节点的首字母</td></tr><tr><td>:first-line</td><td>p:first-line</td><td>选择每个 p 节点的首行</td></tr><tr><td>:first-child</td><td>p:first-child</td><td>选择属于父节点的第一个子节点的所有 p 节点</td></tr><tr><td>:before</td><td>p:before</td><td>在每个 p 节点的内容之前插入内容</td></tr><tr><td>:after</td><td>p:after</td><td>在每个 p 节点的内容之后插入内容</td></tr><tr><td>:lang(language)</td><td>p:lang</td><td>选择带有以 it 开头的 lang 属性值的所有 p 节点</td></tr><tr><td>element1~element2</td><td>p~ul</td><td>选择前面有 p 节点的所有 ul 节点</td></tr><tr><td>[attribute^=value]</td><td>a[src^=”https”]</td><td>选择其 src 属性值以 https 开头的所有 a 节点</td></tr><tr><td>[attribute$=value]</td><td>a[src$=”.pdf”]</td><td>选择其 src 属性以.pdf 结尾的所有 a 节点</td></tr><tr><td>[attribute*=value]</td><td>a[src*=”abc”]</td><td>选择其 src 属性中包含 abc 子串的所有 a 节点</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择属于其父节点的首个 p 节点的所有 p 节点</td></tr><tr><td>:last-of-type</td><td>p:last-of-type</td><td>选择属于其父节点的最后 p 节点的所有 p 节点</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择属于其父节点唯一的 p 节点的所有 p 节点</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择属于其父节点的唯一子节点的所有 p 节点</td></tr><tr><td>:nth-child(n)</td><td>p:nth-child</td><td>选择属于其父节点的第二个子节点的所有 p 节点</td></tr><tr><td>:nth-last-child(n)</td><td>p:nth-last-child</td><td>同上，从最后一个子节点开始计数</td></tr><tr><td>:nth-of-type(n)</td><td>p:nth-of-type</td><td>选择属于其父节点第二个 p 节点的所有 p 节点</td></tr><tr><td>:nth-last-of-type(n)</td><td>p:nth-last-of-type</td><td>同上，但是从最后一个子节点开始计数</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>选择属于其父节点最后一个子节点的所有 p 节点</td></tr><tr><td>:root</td><td>:root</td><td>选择文档的根节点</td></tr><tr><td>:empty</td><td>p:empty</td><td>选择没有子节点的所有 p 节点（包括文本节点）</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动的 #news 节点</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择每个启用的 input 节点</td></tr><tr><td>:disabled</td><td>input:disabled</td><td>选择每个禁用的 input 节点</td></tr><tr><td>:checked</td><td>input:checked</td><td>选择每个被选中的 input 节点</td></tr><tr><td>:not(selector)</td><td>:not</td><td>选择非 p 节点的所有节点</td></tr><tr><td>::selection</td><td>::selection</td><td>选择被用户选取的节点部分</td></tr></tbody></table><h1 id="爬虫的基本原理"><a href="#爬虫的基本原理" class="headerlink" title="爬虫的基本原理"></a>爬虫的基本原理</h1><h2 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h2><p>获取网页源代码 – 分析网页源代码 –数据保存</p><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>向网站的服务器发送一个请求(urllib、requests )–&gt;返回的响应体便是网页源代码(解析Body)</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>采用正则表达式提取(万能but比较复杂且容易出错)</p><p>根据网页节点属性、CSS 选择器或 XPath 来提取(Beautiful Soup、pyquery、lxml )</p><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>可以简单保存为 TXT 文本或 JSON 文本</p><p>也可以保存到数据库，如 MySQL 和 MongoDB 等</p><p>也可保存至远程服务器，如借助 SFTP 进行操作等</p><h3 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h3><p>在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行</p><h2 id="能抓怎样的数据"><a href="#能抓怎样的数据" class="headerlink" title="能抓怎样的数据"></a>能抓怎样的数据</h2><p>HTML 源代码 –常规网页</p><p>JSON 字符串– API 接口</p><p>二进制数据–图片、视频和音频等</p><p>各种扩展名的文件</p><h2 id="JavaScript-渲染页面"><a href="#JavaScript-渲染页面" class="headerlink" title="JavaScript 渲染页面"></a>JavaScript 渲染页面</h2><p>JavaScript 则会改变 HTML 中的节点，向其添加内容，最后得到完整的页面</p><p>但是在用 urllib 或 requests 等库请求当前页面时，我们得到的只是这个 HTML 代码，它不会帮助我们去继续加载这个 JavaScript 文件，这样也就看不到浏览器中的内容了</p><p>因此，使用基本 HTTP 请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，我们可以分析其后台 Ajax 接口，也可使用 Selenium、Splash 这样的库来实现模拟 JavaScript 渲染</p><h1 id="会话和-Cookies"><a href="#会话和-Cookies" class="headerlink" title="会话和 Cookies"></a>会话和 Cookies</h1><h2 id="静态网页和动态网页"><a href="#静态网页和动态网页" class="headerlink" title="静态网页和动态网页"></a>静态网页和动态网页</h2><p>静态网页：这种网页的内容是 HTML 代码编写的，文字、图片等内容均通过写好的 HTML 代码来指定。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据 URL 灵活多变地显示内容等。</p><p>动态网页：可以动态解析 URL 中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的 HTML，而是可能由 JSP、PHP、Python 等语言编写的，其功能比静态网页强大和丰富太多了</p><h2 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h2><p> 指HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话在服务端，也就是网站的服务器，用来保存用户的会话信息</p><p>会话对象用来存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在会话对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据</p><p>Cookies 在客户端，也可以理解为浏览器端，有了 Cookies，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别 Cookies 并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的响应。</p><p>Cookie属性</p><ul><li>Name，即该 Cookie 的名称。Cookie 一旦创建，名称便不可更改</li><li>Value，即该 Cookie 的值。如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码。</li><li>Max Age，即该 Cookie 失效的时间，单位秒，也常和 Expires 一起使用，通过它可以计算出其有效时间。Max Age 如果为正数，则该 Cookie 在 Max Age 秒之后失效。如果为负数，则关闭浏览器时 Cookie 即失效，浏览器也不会以任何形式保存该 Cookie。</li><li>Path，即该 Cookie 的使用路径。如果设置为 /path/，则只有路径为 /path/ 的页面可以访问该 Cookie。如果设置为 /，则本域名下的所有页面都可以访问该 Cookie。</li><li>Domain，即可以访问该 Cookie 的域名。例如如果设置为 .zhihu.com，则所有以 zhihu.com，结尾的域名都可以访问该 Cookie。</li><li>Size 字段，即此 Cookie 的大小。</li><li>Http 字段，即 Cookie 的 httponly 属性。若此属性为 true，则只有在 HTTP Headers 中会带有此 Cookie 的信息，而不能通过 document.cookie 来访问此 Cookie。</li><li>Secure，即该 Cookie 是否仅被使用安全协议传输。安全协议。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。</li></ul><p>会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效</p><p>持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。</p><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>代理网络用户去取得网络信息</p><p>此时本机不是直接向 Web 服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给 Web 服务器，接着由代理服务器再把 Web 服务器返回的响应转发给本机。–实现IP伪装</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>突破自身 IP 访问限制，访问一些平时不能访问的站点。</li><li>访问一些单位或团体内部资源，如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类 FTP 下载上传，以及各类资料查询共享等服务。</li><li>提高访问速度，通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li><li>隐藏真实 IP，上网者也可以通过这种方法隐藏自己的 IP，免受攻击，对于爬虫来说，我们用代理就是为了隐藏自身 IP，防止自身的 IP 被封锁。</li></ul><h2 id="爬虫代理"><a href="#爬虫代理" class="headerlink" title="爬虫代理"></a>爬虫代理</h2><p>由于爬虫爬取速度过快，在爬取过程中可能遇到同一个 IP 访问过于频繁的问题，此时网站就会让我们输入验证码登录或者直接封锁 IP，这样会给爬取带来极大的不便。</p><p>使用代理隐藏真实的 IP，让服务器误以为是代理服务器在请求自己。这样在爬取过程中通过不断更换代理，就不会被封锁，可以达到很好的爬取效果。</p><h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><h3 id="1-根据协议区分"><a href="#1-根据协议区分" class="headerlink" title="1. 根据协议区分"></a>1. 根据协议区分</h3><p>根据代理的协议，代理可以分为如下类别：</p><ul><li>FTP 代理服务器，主要用于访问 FTP 服务器，一般有上传、下载以及缓存功能，端口一般为 21、2121 等。</li><li>HTTP 代理服务器，主要用于访问网页，一般有内容过滤和缓存功能，端口一般为 80、8080、3128 等。</li><li>SSL/TLS 代理，主要用于访问加密网站，一般有 SSL 或 TLS 加密功能（最高支持 128 位加密强度），端口一般为 443。</li><li>RTSP 代理，主要用于 Realplayer 访问 Real 流媒体服务器，一般有缓存功能，端口一般为 554。</li><li>Telnet 代理，主要用于 telnet 远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为 23。</li><li>POP3/SMTP 代理，主要用于 POP3/SMTP 方式收发邮件，一般有缓存功能，端口一般为 110/25。</li><li>SOCKS 代理，只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为 1080。SOCKS 代理协议又分为 SOCKS4 和 SOCKS5，SOCKS4 协议只支持 TCP，而 SOCKS5 协议支持 TCP 和 UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说，SOCK4 能做到的 SOCKS5 都可以做到，但 SOCKS5 能做到的  SOCK4 不一定能做到。</li></ul><h3 id="2-根据匿名程度区分"><a href="#2-根据匿名程度区分" class="headerlink" title="2. 根据匿名程度区分"></a>2. 根据匿名程度区分</h3><p>根据代理的匿名程度，代理可以分为如下类别。</p><ul><li>高度匿名代理，高度匿名代理会将数据包原封不动的转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的 IP 是代理服务器的 IP。</li><li>普通匿名代理，普通匿名代理会在数据包上做一些改动，服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实 IP。代理服务器通常会加入的 HTTP 头有 HTTP_VIA 和 HTTP_X_FORWARDED_FOR。</li><li>透明代理，透明代理不但改动了数据包，还会告诉服务器客户端的真实 IP。这种代理除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</li><li>间谍代理，间谍代理指组织或个人创建的，用于记录用户传输的数据，然后进行研究、监控等目的代理服务器。</li></ul><h2 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h2><ul><li>使用网上的免费代理，最好使用高匿代理，使用前抓取下来筛选一下可用代理，也可以进一步维护一个代理池。</li><li>使用付费代理服务，互联网上存在许多代理商，可以付费使用，质量比免费代理好很多。</li><li>ADSL 拨号，拨一次号换一次 IP，稳定性高，也是一种比较有效的解决方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 学习笔记</title>
      <link href="/posts/9478/"/>
      <url>/posts/9478/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>理解并实现分模块开发</li><li>能够使用聚合工程快速构建项目</li><li>能够使用继承简化项目配置能够根据需求配置生成、开发、测试环境，并在各个环境间切换运行</li><li>了解Maven的私服</li></ul><h1 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h1><p>项目中的每一层都可以单独维护，也可以很方便被别人使用</p><ul><li>步骤<ol><li>创建新模块、放入内容</li><li>在原模块的pom.xml添加依赖</li><li>将新模块install到maven的本地仓库</li><li>注意新模块(如Dao)的pom.xml也要添加相关依赖</li></ol></li></ul><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><ul><li>依赖的优先级</li><li>可选依赖<code>optional</code> 不被别人用</li><li>排除依赖 <code>exclusions</code> 不用别人</li></ul><h1 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h1><ul><li><p>聚合</p><p>  将多个模块组织成一个整体，同时进行项目构建</p><ul><li>步骤<ol><li>创建一个空的maven项目</li><li>将项目的打包方式改为pom</li><li>pom.xml添加所要管理的项目(modules)</li></ol></li></ul></li><li><p>继承</p><p>  描述的是两个工程间的关系，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</p><ul><li>步骤<ol><li>创建一个Maven项目、打包方式为pom</li><li>在子项目中设置其父工程</li><li>优化子项目共有依赖导入问题<code>&lt;parent&gt;&amp;&lt;dependencyManagement&gt;</code></li></ol></li></ul></li></ul><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><ul><li>步骤<ol><li>父工程中定义属性  <code>—.properties</code></li><li><code>jdbc.properties</code>文件中引用属性</li><li>设置maven过滤文件范围  <code>&lt;filtering&gt;</code></li><li>修改依赖的versio <code>${spring.version}</code></li></ol></li></ul><h1 id="多环境配置与应用"><a href="#多环境配置与应用" class="headerlink" title="多环境配置与应用"></a>多环境配置与应用</h1><ul><li>步骤<ol><li>父工程配置多个环境,并指定默认激活环境 <code>—.properties</code></li><li>执行安装查看env_dep环境是否生效</li><li>切换默认环境为生产环境</li></ol></li><li>跳过测试<ol><li>IDEA—Toggle <code>Skip Test</code>Mode</li><li>pom.xml <code>&lt;skipTests&gt;false&lt;/skipTests&gt;</code></li><li><code>mvn 指令 -D skipTests</code></li></ol></li></ul><h1 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h1><p>公司内部搭建的用于存储Maven资源的服务器</p><p>没搞，感觉目前用不上</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Maven </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="/posts/7244/"/>
      <url>/posts/7244/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>基于MyBatisPlus完成标准Dao的增删改查功能</li><li>掌握MyBatisPlus中的分页及条件查询构建</li><li>掌握主键ID的生成策略</li><li>了解MyBatisPlus的代码生成器</li></ul><h1 id="入门步骤"><a href="#入门步骤" class="headerlink" title="入门步骤"></a>入门步骤</h1><ol><li>建表</li><li>建SpringBoot</li><li>pom.xml补全依赖</li><li>添加MP的相关配置信息  <code>application.yml</code></li><li>根据数据库表创建实体类</li><li>创建Dao接口</li><li>编写引导类   <code>Mybatisplus01QuickstartApplication</code></li><li>编写测试类</li></ol><h1 id="标准数据层开发"><a href="#标准数据层开发" class="headerlink" title="标准数据层开发"></a>标准数据层开发</h1><ul><li>增  <code>userDao.insert(user);</code></li><li>删   <code>userDao.deleteById(1L);</code></li><li>改   <code>userDao.updateById(user);</code></li><li>查<ul><li>查单个  <code>User user = userDao.selectById(2L);</code></li><li>查全部  <code>List&lt;User&gt; userList = userDao.selectList(null);</code></li><li>查分页  <code>userDao.selectPage(page,null);</code></li></ul></li><li>Lombko简化POJO实体类开发<ul><li>添加依赖</li><li>@Setter、@Getter、@ToString、@EqualsAndHashCode、@Data、@NoArgsConstructor、@AllArgsConstructor</li></ul></li></ul><h1 id="DQL编程控制"><a href="#DQL编程控制" class="headerlink" title="DQL编程控制"></a>DQL编程控制</h1><ul><li>条件查询方式<ul><li>QueryWrapper</li><li>QueryWrapper+lambda</li><li>LambdaQueryWrapper</li><li>单条件/多条件/null查询</li></ul></li><li>查询投影<ul><li>查询指定字段<code>lqw.select(User::getId,User::getName,User::getAge);</code></li><li>聚合查询<code>lqw.select("count() as count");</code></li><li>分组查询  <code>lqw.groupBy("tel");</code></li></ul></li><li>查询条件设定<ul><li>等值查询   <code>.eq(User::getName, "Jerry”)</code></li><li>范围查询   <code>.between(User::getAge, 10, 30);</code></li><li>模糊查询   <code>.likeLeft(User::getName, "J");</code></li><li>排序查询    <code>.orderBy(true,false, User::getId);</code></li></ul></li><li>字段映射与表名映射<ul><li>@TableFiled   <code>value\exit\true\select</code></li><li>@TableName  <code>value</code>    /—配置文件新增table-prefix</li></ul></li></ul><h1 id="DML编程控制"><a href="#DML编程控制" class="headerlink" title="DML编程控制"></a>DML编程控制</h1><ul><li>id生成策略控制<ul><li>@TableId   AUTO\INPUT\ASSING_ID\ASSING_UUID</li><li>简化配置    — 配置文件新增id-type</li></ul></li><li>多记录操作<ul><li><code>.deleteBatchIds(list);</code></li><li><code>.selectBatchIds(list);</code></li></ul></li><li>逻辑删除<ul><li>@TABLELOGIC    <code>value\deval</code></li></ul></li><li>乐观锁<ul><li>数据库&amp;模型类添加对应属性</li><li>添加拦截器</li><li>测试类<code>updateById</code></li></ul></li></ul><h1 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h1><ul><li>创建代码生成类—不用写<code>controller</code>,<code>service</code>，<code>mapper</code>和<code>entity</code>的基础框架辽！</li><li>代码地址：<code>https://mp.baomidou.com/guide/generator.html</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 笔记 </tag>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/posts/83dd/"/>
      <url>/posts/83dd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>掌握基于SpringBoot框架的程序开发步骤</li><li>熟练使用SpringBoot配置信息修改服务器</li><li>配置基于SpringBoot的完成SSM整合项目开发</li></ul><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ul><li><p>新建项目步骤</p><ol><li>新建模块 <code>Spring Initializr</code></li><li>创建controller</li><li>启动！</li></ol></li><li><p>Spring和SpringBoot对比<br>  <img src="/img/Spring%E5%92%8CSpringBoot%E5%AF%B9%E6%AF%94.png" alt="Untitled"></p></li><li><p>快速启动步骤</p><ol><li><code>packge</code>指令</li><li>进入jar包所在位置，在命令提示符中输入如下命令 <code>jar -jar 包名.jar</code></li></ol></li></ul><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><ul><li><p>yml</p><ul><li>类型</li><li>语法规则</li><li>读取配置数据</li><li>多环境配置</li></ul></li><li><p>配置文件分类</p><ul><li>1级：classpath：application.yml</li><li>2级：classpath：config/application.yml</li><li>3级：file ：application.yml</li><li>4级：file ：config/application.yml</li></ul></li></ul><h1 id="整合junit"><a href="#整合junit" class="headerlink" title="整合junit"></a>整合junit</h1><ol><li>在测试类上添加 <code>SpringBootTest</code> 注解</li><li>使用 <code>@Autowired</code> 注入要测试的资源</li><li>定义测试方法进行测试</li></ol><h1 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h1><ol><li>创建模块</li><li>定义实体类</li><li>定义Dao接口</li><li>定义测试类</li><li>编写配置  <code>application.yml</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Day03  — AOP</title>
      <link href="/posts/308c/"/>
      <url>/posts/308c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h1><ul><li>(Aspect Oriented Programming)面向切面编程，<strong>在不改原有代码的前提下对其进行增强  — 代理模式</strong></li><li>代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的</li><li>连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行</li><li>切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述</li><li>通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法</li><li>切面（Aspect）：描述通知与切入点的对应关系</li><li>目标对象（Target）：被代理的原始对象成为目标对象</li><li>通知类：定义通知的类</li></ul><h1 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>创建项目</li><li>添加spring依赖</li><li>添加Dao&amp;DaoImpl类</li><li>spring的配置类</li><li>编写app运行类</li></ol><h2 id="新增依赖"><a href="#新增依赖" class="headerlink" title="新增依赖"></a>新增依赖</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="定义通知类和通知-—-定义切入点-—-制作切面-—-将通知类配给容器并标识其为切面类"><a href="#定义通知类和通知-—-定义切入点-—-制作切面-—-将通知类配给容器并标识其为切面类" class="headerlink" title="定义通知类和通知 —> 定义切入点 —>  制作切面  —> 将通知类配给容器并标识其为切面类"></a>定义通知类和通知 —&gt; 定义切入点 —&gt;  制作切面  —&gt; 将通知类配给容器并标识其为切面类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>   <span class="comment">// 标注一个类为Spring容器的Bean</span></span><br><span class="line"><span class="meta">@Aspect</span>      <span class="comment">//告诉spring当成aop处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义通知类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> {</span><br><span class="line">    <span class="comment">//定义切入点   -- 只增强updata方法</span></span><br><span class="line">    <span class="meta">@Pointcut("execution(void com.itheima.dao.BookDao.update())")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//制作切面  --  描述通知和切入点之间的关系</span></span><br><span class="line">    <span class="meta">@Before("pt()")</span></span><br><span class="line">    <span class="comment">//定义通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="开启注解格式AOP功能"><a href="#开启注解格式AOP功能" class="headerlink" title="开启注解格式AOP功能"></a>开启注解格式AOP功能</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>   <span class="comment">//告诉spring这是注解开发 -- 去找@Aspect，进去识别@Pointcut</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        **bookDao.update();**</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h1><p>（好像不重要）</p><h2 id="Spring容器启动"><a href="#Spring容器启动" class="headerlink" title="Spring容器启动"></a>Spring容器启动</h2><ul><li>加载bean<ul><li>需要被增强的类，如:BookServiceImpl</li><li>通知类，如:MyAdvice</li></ul></li></ul><h2 id="读取所有切面配置中的切入点"><a href="#读取所有切面配置中的切入点" class="headerlink" title="读取所有切面配置中的切入点"></a>读取所有切面配置中的切入点</h2><h2 id="初始化bean"><a href="#初始化bean" class="headerlink" title="初始化bean"></a>初始化bean</h2><pre><code> * 匹配失败，创建原始对象 * 匹配成功，创建原始对象（目标对象）的代理对象</code></pre><h2 id="获取bean执行方法"><a href="#获取bean执行方法" class="headerlink" title="获取bean执行方法"></a>获取bean执行方法</h2><h1 id="AOP配置管理"><a href="#AOP配置管理" class="headerlink" title="AOP配置管理"></a><strong>AOP配置管理</strong></h1><h2 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h2><ul><li><code>*</code> ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">execution（public * com.itheima.*.UserService.find*(*))</span><br></pre></td></tr></tbody></table></figure><ul><li><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">execution（public User com..UserService.findById(..))</span><br></pre></td></tr></tbody></table></figure><ul><li>书写技巧<br>1. 按<strong>标准规范</strong>开发<br>2. 查询操作的返回值建议使用<em>匹配<br>3. 减少使用..的形式描述包<br>4. <strong>对接口进行描述</strong>，使用<em>表示模块名，例如UserService的匹配描述为</em>Service<br>5. 方法名书写保留动词，例如get，使用</em>表示名词，例如getById匹配描述为getBy*<br>6. 参数根据实际情况灵活调整</li></ul><h2 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h2><h2 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h2><pre><code>`@Before("pt()")`</code></pre><h2 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h2><pre><code>`@After("pt()")`</code></pre><h2 id="环绕通知-重点"><a href="#环绕通知-重点" class="headerlink" title="环绕通知(重点)"></a>环绕通知(重点)</h2><pre><code>`@Around("pt()")`</code></pre><ul><li><p>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用</p></li><li><p>环绕通知可以隔离原始方法的调用执行</p></li><li><p>环绕通知返回值设置为Object类型</p></li><li><p>环绕通知中可以对原始方法调用过程中出现的异常进行处理</p></li><li><p>返回后通知(了解)   <code>@AfterReturning("pt2()")</code></p></li><li><p>抛出异常后通知(了解)    <code>@AfterThrowing</code></p><p><img src="/img/%E5%90%84%E9%80%9A%E7%9F%A5%E5%AF%B9%E5%BA%94%E4%BD%8D%E7%BD%AE.png" alt="image-20230608112904274"></p></li></ul><h2 id="业务层接口执行效率"><a href="#业务层接口执行效率" class="headerlink" title="业务层接口执行效率"></a><strong>业务层接口执行效率</strong></h2><h2 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a><strong>AOP通知获取数据</strong></h2><h1 id="AOP事务管理"><a href="#AOP事务管理" class="headerlink" title="AOP事务管理"></a>AOP事务管理</h1><ul><li>在数据层或<strong>业务层</strong>保障一系列的数据库操作同成功同失败</li></ul><h2 id="转账案例-需求分析"><a href="#转账案例-需求分析" class="headerlink" title="转账案例-需求分析"></a><strong>转账案例-需求分析</strong></h2><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li><strong>准备数据库</strong></li></ol><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database spring_db <span class="keyword">character set</span> utf8;</span><br><span class="line">use spring_db;</span><br><span class="line"><span class="keyword">create table</span> tbl_account(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">35</span>),</span><br><span class="line">money <span class="keyword">double</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert into</span> tbl_account <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tom'</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert into</span> tbl_account <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Jerry'</span>,<span class="number">1000</span>);</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>创建项目导入jar包</strong></li></ol><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>根据表创建模型类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="comment">//setter...getter...toString...方法略    </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li><strong>创建Dao接口</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> {</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update("update tbl_account set money = money + #{money} where name = #{name}")</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param("name")</span> String name, <span class="meta">@Param("money")</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update("update tbl_account set money = money - #{money} where name = #{name}")</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param("name")</span> String name, <span class="meta">@Param("money")</span> Double money)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><strong>创建Service接口和实现类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> {</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li><strong>添加jdbc.properties文件</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/spring_db?useSSL=false</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li><strong>创建JdbcConfig配置类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> {</span><br><span class="line">    <span class="meta">@Value("${jdbc.driver}")</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value("${jdbc.url}")</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value("${jdbc.username}")</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value("${jdbc.password}")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="8"><li><strong>创建MybatisConfig配置类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>{</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">"com.itheima.domain"</span>);</span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">"com.itheima.dao"</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ol start="9"><li><strong>创建SpringConfig配置类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="meta">@PropertySource("classpath:jdbc.properties")</span></span><br><span class="line"><span class="meta">@Import({JdbcConfig.class,MybatisConfig.class})</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="10"><li>编写测试类</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransfer</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    accountService.transfer(<span class="string">"Tom"</span>,<span class="string">"Jerry"</span>,<span class="number">100D</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/img/%E6%9C%80%E7%BB%88%E5%88%9B%E5%BB%BA%E5%A5%BD%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="image-20230608113114611"></p><p> 最终项目结构如上</p><h2 id="实现事务管理具体步骤"><a href="#实现事务管理具体步骤" class="headerlink" title="实现事务管理具体步骤"></a>实现事务管理具体步骤</h2><h2 id="需要被事务管理的方法上添加注解-Transactional"><a href="#需要被事务管理的方法上添加注解-Transactional" class="headerlink" title="需要被事务管理的方法上添加注解@Transactional"></a>需要被事务管理的方法上添加注解<code>@Transactional</code></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> {</span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">        **<span class="meta">@Transactional</span>**</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> {</span><br><span class="line">            accountDao.outMoney(out,money);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            accountDao.inMoney(in,money);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="在JdbcConfig类中配置事务管理器"><a href="#在JdbcConfig类中配置事务管理器" class="headerlink" title="在JdbcConfig类中配置事务管理器"></a>在JdbcConfig类中配置事务管理器</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//配置事务管理器，mybatis使用的是jdbc事务</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>{</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="在SpringConfig的配置类中开启事务注解-EnableTransactionManagement"><a href="#在SpringConfig的配置类中开启事务注解-EnableTransactionManagement" class="headerlink" title="在SpringConfig的配置类中开启事务注解  @EnableTransactionManagement"></a>在SpringConfig的配置类中开启事务注解  <code>@EnableTransactionManagement</code></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="meta">@PropertySource("classpath:jdbc.properties")</span></span><br><span class="line"><span class="meta">@Import({JdbcConfig.class,MybatisConfig.class})</span></span><br><span class="line"><span class="comment">//开启注解式事务驱动</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行测试类"><a href="#运行测试类" class="headerlink" title="运行测试类"></a>运行测试类</h2><h2 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h2><ul><li><code>@Transactional</code>参数</li></ul><p><img src="/img/@transactional%E5%8F%82%E6%95%B0.png" alt="Untitled"></p><h2 id="转账业务追加日志"><a href="#转账业务追加日志" class="headerlink" title="转账业务追加日志"></a>转账业务追加日志</h2><h2 id="创建日志表"><a href="#创建日志表" class="headerlink" title="创建日志表"></a>创建日志表</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> tbl_log(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">info <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">createDate datetime</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h2 id="添加LogDao接口"><a href="#添加LogDao接口" class="headerlink" title="添加LogDao接口"></a>添加LogDao接口</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogDao</span> {</span><br><span class="line">    <span class="meta">@Insert("insert into tbl_log (info,createDate) values(#{info},now())")</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String info)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="添加LogService接口与实现类"><a href="#添加LogService接口与实现类" class="headerlink" title="添加LogService接口与实现类"></a>添加LogService接口与实现类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogService</span> {</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,Double money )</span> {</span><br><span class="line">    logDao.log(<span class="string">"转账操作由"</span>+out+<span class="string">"到"</span>+in+<span class="string">",金额："</span>+money);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="在转账的业务中添加记录日志"><a href="#在转账的业务中添加记录日志" class="headerlink" title="在转账的业务中添加记录日志"></a>在转账的业务中添加记录日志</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 转账操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span><span class="keyword">throws</span> IOException ;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> {</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> {</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            accountDao.outMoney(out,money);</span><br><span class="line">            accountDao.inMoney(in,money);</span><br><span class="line">            }<span class="keyword">finally</span> {</span><br><span class="line">            logService.log(out,in,money);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><ul><li>事务协调员对事务管理员所携带事务的处理态度</li><li>转账失败后，所有的事务都回滚，导致日志没有记录下来 — 让log方法单独是一个事务</li><li><strong>修改logService改变事务的传播行为</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">    <span class="comment">//propagation设置事务属性：传播行为设置为当前操作需要新事务</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,Double money )</span> {</span><br><span class="line">        logDao.log(<span class="string">"转账操作由"</span>+out+<span class="string">"到"</span>+in+<span class="string">",金额："</span>+money);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/posts/12ac/"/>
      <url>/posts/12ac/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a><strong>主要内容</strong></h1><ul><li>SpringMVC简介</li><li><strong>请求与响应</strong></li><li><strong>REST风格</strong></li><li><strong>SSM整合(注解版)</strong></li><li>拦截器</li></ul><h1 id="SpringMVC的制作过程"><a href="#SpringMVC的制作过程" class="headerlink" title="SpringMVC的制作过程"></a><strong>SpringMVC的制作过程</strong></h1><ol><li>创建maven项目，补全目录结构</li><li>导入jar包，添加SpringMVC需要的依赖与servlet；配置Tomcat环境</li><li>创建Controller类：声明bean、提供方法处理请求、设置访问路径、设置当前操作返回值</li><li>创建springmvc的配置类，加载controller对应的bean</li><li>使用servlet容器启动的配置类替换web.xml</li><li>启动项目、浏览器访问</li></ol><ul><li><p>相关注解</p><p>  <strong>@Controller：</strong> 设定SpringMVC的核心控制器bean【Controller类处】</p><p>  <strong>@RequestMapping：</strong> 设置当前控制器方法请求访问路径【Controller类具体方法前：(”/save”)】</p><p>  <strong>@ResponseBody：</strong> 设置当前控制器方法响应内容为当前返回值【Controller类具体方法前】</p></li></ul><h1 id="设置springmvc和spring的加载范围"><a href="#设置springmvc和spring的加载范围" class="headerlink" title="设置springmvc和spring的加载范围"></a>设置springmvc和spring的加载范围</h1><ul><li><p>SpringMVC加载其相关bean(表现层bean),也就是controller包下的类</p></li><li><p>Spring控制的bean</p><ul><li>业务bean(Service)</li><li>功能bean(DataSource,SqlSessionFactoryBean,MapperScannerConfigurer等)</li></ul></li><li><p>相关注解</p><p>  <strong>@ComponentScan</strong>：设置spring配置类扫描路径【类上方，属性：excludeFilters&amp;includeFilters&amp;type】</p>  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan({"com.itheima.service","comitheima.dao"})</span></span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value="com.itheima",</span></span><br><span class="line"><span class="meta">    excludeFilters=@ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">        type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">        classes = Controller.class  //过滤的注解类型</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="springmvc更简单的配置类"><a href="#springmvc更简单的配置类" class="headerlink" title="springmvc更简单的配置类"></a><strong>springmvc更简单的配置类</strong></h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> {</span><br><span class="line">        <span class="comment">//加载spring配置类</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]{SpringConfig.class};</span><br><span class="line">    }</span><br><span class="line">        <span class="comment">//加载指定(springmvcc)配置类</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]{SpringMvcConfig.class};</span><br><span class="line">    }</span><br><span class="line">        <span class="comment">//设置由springmvc控制器处理的请求映射路径</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"/"</span>};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a><strong>请求与响应</strong></h1><ul><li><p>区分访问不同controller相同名字的方法</p><ol><li>在访问路径前加controller区分</li><li>在类前面新增@RequestMapping(“/方法名”)</li></ol></li><li><p>接收页面传递的参数</p><ul><li><p>GET/POST  —发送单/多个参数</p><ul><li>直接在方法处接受参数</li><li>普通、POJO、嵌套POJO、数组、集合</li></ul></li><li><p>解决请求乱码问题</p><ul><li>GET：修改pom.xml</li><li>POST:配置过滤器</li></ul></li><li><p>形参与地址参数名不一致</p><p>  使用**@RequestParam**注解</p></li><li><p>接收日期/时间类型</p><p>  使用@DateTimeFormat注解</p></li></ul></li><li><p>相关注解</p><ol><li><strong>@REQUESTPARAM：</strong> 绑定请求参数与处理器方法形参间的关系【方法具体参数处】</li><li><strong>@ENABLEWEBMVC：</strong> 开启SpringMVC多项辅助功能【配置类定义上方】</li><li><strong>@RequestBody：</strong> 将请求中请求体所包含的数据传递给请求参数、设置当前控制器返回值作为响应体【方法形参定义前面】</li><li><strong>@DateTimeFormat</strong> ：设定日期时间型数据格式【方法具体参数处】</li></ol></li></ul><h1 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a><strong>REST风格</strong></h1><p>使用<strong>行为动作</strong>区分对资源进行了何种操作：查询(GET)新增(POST)修改(PUT)删除(DELETE)</p><p>页面访问：SpringMVC需要将静态资源进行放行</p><ul><li><p>相关注解</p><p>  <strong>@RestController：</strong> 等同于@Controller与@ResponseBody两个注解组合功能</p><p>  <strong>@GetMapping @PostMapping @PutMapping @DeleteMapping：</strong> 设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作【注意delete和get后面要有具体id】</p></li></ul><h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a><strong>SSM整合</strong></h1><blockquote><p>李老师大好人，就是把之前所有的代码都理了一遍</p></blockquote><ul><li><p>整合配置</p><ol><li>创建web项目</li><li>添加依赖</li><li>创建项目包结构</li><li>创建ssm+jdbc-config配置类</li></ol></li><li><p>功能模块开发</p><ol><li>table</li><li>domain</li><li>Dao</li><li>Service</li><li>Controller</li></ol></li><li><p>单元/PostMan测试</p></li><li><p>事务管理</p><ol><li>SpringConfig</li><li>jdbcConfig</li><li>BookService</li></ol></li><li><p><strong>统一结果封装</strong></p><ol><li>Result类</li><li>Code类</li><li>修改Controller类的返回值</li></ol></li><li><p><strong>统一异常处理</strong></p><ol><li>创建异常处理器类</li><li>搞个异常测试一下</li></ol></li><li><p>相关注解</p><p>  <strong>@RestControllerAdvice：</strong> 为Rest风格开发的控制器类做增强</p><p>  <strong>@ExceptionHandler：</strong> 设置指定异常的处理方案</p></li></ul><h1 id="前后台协议联调"><a href="#前后台协议联调" class="headerlink" title="前后台协议联调"></a>前后台协议联调</h1><ol><li>将静态资源进行放行</li><li>根据不同业务进行不同操作</li></ol><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><ul><li>开发步骤<ol><li>创建拦截器类interceptor</li><li>配置拦截器类SpringMvcConfig</li><li>修改拦截器拦截规则</li><li>配置多个拦截器</li></ol></li><li>拦截器参数<ul><li>request、response、<strong>handler、</strong> modelAndView</li></ul></li></ul><blockquote><p>一般环境准备步骤</p><ol><li>创建一个Web的Maven项目</li><li>pom.xml添加Spring依赖</li><li>创建对应的配置类（config）</li><li>编写controller、domain</li><li>（启动一下看是否能正常运行）</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 笔记 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Day02  —  注解开发</title>
      <link href="/posts/c1c1/"/>
      <url>/posts/c1c1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IOC-DI配置管理第三方bean"><a href="#IOC-DI配置管理第三方bean" class="headerlink" title="IOC/DI配置管理第三方bean"></a>IOC/DI配置管理第三方bean</h1><h2 id="案例：配置Druid"><a href="#案例：配置Druid" class="headerlink" title="案例：配置Druid"></a>案例：配置Druid</h2><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>创建maven项目</li><li>pom.xml添加依赖 <code>spring-context</code></li><li>resources下添加 <code>applicationContext.xml</code></li><li>编写运行类 <code>ApplicationContext ctx</code></li></ol><h2 id="pom-xml导入-druid-依赖"><a href="#pom-xml导入-druid-依赖" class="headerlink" title="pom.xml导入 druid 依赖"></a><strong>pom.xml导入 <code>druid</code> 依赖</strong></h2><h2 id="配置类配置第三方bean"><a href="#配置类配置第三方bean" class="headerlink" title="配置类配置第三方bean"></a><strong>配置类配置第三方bean</strong></h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--管理DruidDataSource对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring_db"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"950827"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="从IOC容器中获取对应的bean对象"><a href="#从IOC容器中获取对应的bean对象" class="headerlink" title="从IOC容器中获取对应的bean对象"></a><strong>从IOC容器中获取对应的bean对象</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) ctx.getBean(<span class="string">"dataSource"</span>);</span><br><span class="line">    System.out.println(dataSource);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>对于新的技术，不知道具体的坐标该如何查找?<ol><li>百度</li><li>从mvn的仓库<code>https://mvnrepository.com/</code>中进行搜索</li></ol></li><li>报的错为<strong>ClassNotFoundException</strong>，具体的类为<code>com.mysql.jdbc.Driver</code>错误的原因是缺少mysql的驱动包<ol><li>在pom.xml把驱动包引入即可</li></ol></li></ol><h2 id="加载properties文件"><a href="#加载properties文件" class="headerlink" title="加载properties文件"></a>加载properties文件</h2><p>原因： 属性写在Spring的配置文件中不利于后期维护<br>​                           —&gt; <strong>将这些值提取到一个外部的properties配置文件中</strong></p><p>具体步骤：</p><h2 id="resources下创建一个jdbc-properties文件"><a href="#resources下创建一个jdbc-properties文件" class="headerlink" title="resources下创建一个jdbc.properties文件"></a>resources下创建一个jdbc.properties文件</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></tbody></table></figure><h2 id="开启context命名空间、加载properties配置文件、完成属性注入"><a href="#开启context命名空间、加载properties配置文件、完成属性注入" class="headerlink" title="开启context命名空间、加载properties配置文件、完成属性注入"></a><strong>开启<code>context</code>命名空间、加载properties配置文件、完成属性注入</strong></h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line">**<span class="comment">&lt;!--开启context命名空间--&gt;</span>**</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载properties配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"jdbc.properties"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--**完成属性注入**--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"${jdbc.driver}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${jdbc.username}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="多个property文件需要加载时"><a href="#多个property文件需要加载时" class="headerlink" title="多个property文件需要加载时"></a>多个property文件需要加载时</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"jdbc.properties,jdbc2.properties"</span> <span class="attr">system-properties-mode</span>=<span class="string">"NEVER"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"*.properties"</span> <span class="attr">system-properties-mode</span>=<span class="string">"NEVER"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:*.properties"</span> <span class="attr">system-properties-mode</span>=<span class="string">"NEVER"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:*.properties"</span> <span class="attr">system-properties-mode</span>=<span class="string">"NEVER"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h1 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h1><p> 简单的理解为<code>ApplicationContext</code></p><h2 id="容器的创建方式"><a href="#容器的创建方式" class="headerlink" title="容器的创建方式"></a>容器的创建方式</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//类路径下的XML配置文件    掌握</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//文件系统下的XML配置文件  了解</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">"D:\\workspace\\spring\\spring_10_container\\src\\main\\resources\\applicationContext.xml"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="bean的三种获取方式"><a href="#bean的三种获取方式" class="headerlink" title="bean的三种获取方式"></a>bean的三种获取方式</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方式一   getBean("名称"):需要类型转换</span></span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">"bookDao"</span>);</span><br><span class="line"><span class="comment">//方式二    getBean("名称",类型.class):多了一个参数</span></span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">"bookDao"</span>，BookDao.class);</span><br><span class="line"><span class="comment">//方式三    容器中不能有多个该类的bean对象</span></span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br></pre></td></tr></tbody></table></figure><h2 id="容器类层次结构"><a href="#容器类层次结构" class="headerlink" title="容器类层次结构"></a>容器类层次结构</h2><ul><li><strong>容器的最上级的父接口为 BeanFactory</strong></li></ul><h2 id="BeanFactory-—额额不太懂"><a href="#BeanFactory-—额额不太懂" class="headerlink" title="BeanFactory  —额额不太懂"></a>BeanFactory  —额额不太懂</h2><h2 id="使用BeanFactory来创建IOC容器"><a href="#使用BeanFactory来创建IOC容器" class="headerlink" title="使用BeanFactory来创建IOC容器"></a>使用BeanFactory来创建IOC容器</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForBeanFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">//创建了一个bf的IOC容器</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resources);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用BeanFactory创建的容器是<strong>延迟加载</strong></li><li>使用ApplicationContext创建的容器是<strong>立即加载</strong></li><li>具体BeanFactory如何创建只需要了解即可</li></ul><h1 id="IOC-DI注解开发"><a href="#IOC-DI注解开发" class="headerlink" title="IOC/DI注解开发"></a>IOC/DI注解开发</h1><h2 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a><strong>注解开发定义bean</strong></h2><ol><li>环境准备</li><li>删除原XML配置的<code>&lt;bean&gt;</code>标签</li><li>Dao上添加<code>@Component</code>注解</li><li>配置Spring的注解包扫描 <code>@ComponentScan</code></li><li>ServiceImpl类上也添加<code>@Component</code></li><li>运行行为类测试</li></ol><p><img src="/img/XML%E4%B8%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="XML与注解配置的对应关系"></p><p><code>@Controller</code> 、<code>@Service</code>、<code>@Repository</code></p><h2 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h2><ul><li>将配置文件applicationContext.xml删除掉，使用类来替换</li></ul><h2 id="【❗更新】环境准备"><a href="#【❗更新】环境准备" class="headerlink" title="【❗更新】环境准备"></a>【❗更新】环境准备</h2><ol><li>创建maven</li><li>pom.xml</li><li><strong>springconfig【刚学的注解开发定义bean】</strong></li><li>添加类</li></ol><h2 id="创建一个配置类SpringConfig-、标识该类为配置类、用注解替换包扫描配置"><a href="#创建一个配置类SpringConfig-、标识该类为配置类、用注解替换包扫描配置" class="headerlink" title="创建一个配置类SpringConfig 、标识该类为配置类、用注解替换包扫描配置"></a>创建一个配置类<code>SpringConfig</code> 、标识该类为配置类、用注解替换包扫描配置</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//将其标识为一个配置类,替换`applicationContext.xml`</span></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="comment">//替换`&lt;context:component-scan base-package=""/&gt;`</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建运行类并执行"><a href="#创建运行类并执行" class="headerlink" title="创建运行类并执行"></a>创建运行类并执行</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">"bookDao"</span>);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        System.out.println(bookService);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注解开发bean的作用范围和生命周期管理"><a href="#注解开发bean的作用范围和生命周期管理" class="headerlink" title="注解开发bean的作用范围和生命周期管理"></a>注解开发bean的作用范围和生命周期管理</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Scope("prototype")</span>   <span class="comment">//@Scope设置bean的作用范围</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"book dao save ..."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//在构造方法之后执行，替换 init-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"init ..."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//在销毁方法之前执行,替换 destroy-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"destroy ..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注解对应关系图</strong><img src="/img/%E6%B3%A8%E8%A7%A3%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="Untitled"></p><h1 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h1><h2 id="bean和service的关系"><a href="#bean和service的关系" class="headerlink" title="bean和service的关系"></a>bean和service的关系</h2><ul><li>之前的配置文件application配置好的bean和service的关系还没用注解开发，所以bookDao对象为Null,调用其save方法就会报<strong>空指针异常</strong>。</li><li>解决办法：在BookServiceImpl类的bookDao属性上添加<code>@Autowired</code>注解<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">        <span class="comment">//  public void setBookDao(BookDao bookDao) {</span></span><br><span class="line">        <span class="comment">//        this.bookDao = bookDao;</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"book service save ..."</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="按照名称注入"><a href="#按照名称注入" class="headerlink" title="按照名称注入"></a>按照名称注入</h2><ul><li>如果Dao接口类有多个实现类，解决方案:<code>按照名称注入</code></li></ul><h2 id="DaoImpl文件"><a href="#DaoImpl文件" class="headerlink" title="DaoImpl文件"></a>DaoImpl文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//起别名</span></span><br><span class="line"><span class="meta">@Repository("bookDao")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"book dao save ..."</span> );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">    <span class="meta">@Repository("bookDao2")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"book dao save ...2"</span> );</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ServiceImpl文件"><a href="#ServiceImpl文件" class="headerlink" title="ServiceImpl文件"></a>ServiceImpl文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier("bookDao1")</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"book service save ..."</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="简单数据类型注入"><a href="#简单数据类型注入" class="headerlink" title="简单数据类型注入"></a>简单数据类型注入</h2><h2 id="DaoImpl文件-1"><a href="#DaoImpl文件-1" class="headerlink" title="DaoImpl文件"></a>DaoImpl文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Repository("bookDao")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    **<span class="keyword">private</span> String name;**</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"book dao save ..."</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ServiceImpl文件-1"><a href="#ServiceImpl文件-1" class="headerlink" title="ServiceImpl文件"></a>ServiceImpl文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Repository("bookDao")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    **<span class="meta">@Value("itheima")</span>**</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"book dao save ..."</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h2><h2 id="resource下准备properties文件"><a href="#resource下准备properties文件" class="headerlink" title="resource下准备properties文件"></a>resource下准备properties文件</h2><h2 id="springconfig加载properties配置文件"><a href="#springconfig加载properties配置文件" class="headerlink" title="springconfig加载properties配置文件"></a>springconfig加载properties配置文件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="comment">//如果要指定多个配置文件，不支持使用通配符*</span></span><br><span class="line"><span class="comment">//1.@PropertySource({"jdbc.properties","xxx.properties"})</span></span><br><span class="line"><span class="comment">//2.@PropertySource({"classpath:jdbc.properties"})</span></span><br><span class="line"><span class="meta">@PropertySource("jdbc.properties")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="DaoImpl读取配置文件中的内容"><a href="#DaoImpl读取配置文件中的内容" class="headerlink" title="DaoImpl读取配置文件中的内容"></a>DaoImpl读取配置文件中的内容</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Repository("bookDao")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> {</span><br><span class="line">    **<span class="meta">@Value("${name}")</span>**</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"book dao save ..."</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="IOC-DI注解开发管理第三方bean"><a href="#IOC-DI注解开发管理第三方bean" class="headerlink" title="IOC/DI注解开发管理第三方bean"></a>IOC/DI注解开发管理第三方bean</h1><pre><code>- 第三方的类都是在jar包中，我们没有办法在类上面添加注解？</code></pre><h2 id="案例：注解开发管理第三方bean"><a href="#案例：注解开发管理第三方bean" class="headerlink" title="案例：注解开发管理第三方bean"></a>案例：注解开发管理第三方bean</h2><h2 id="导入对应的jar包"><a href="#导入对应的jar包" class="headerlink" title="导入对应的jar包"></a><strong>导入对应的jar包</strong></h2><h2 id="在配置类中添加一个方法、添加-Bean注解"><a href="#在配置类中添加一个方法、添加-Bean注解" class="headerlink" title="在配置类中添加一个方法、添加@Bean注解"></a><strong>在配置类中添加一个方法、添加<code>@Bean</code>注解</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">    **<span class="meta">@Bean</span>**</span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        ds.setUrl(<span class="string">"jdbc:mysql://localhost:3306/spring_db"</span>);</span><br><span class="line">        ds.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        ds.setPassword(<span class="string">"950827"</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="从IOC容器中获取对象并打印"><a href="#从IOC容器中获取对象并打印" class="headerlink" title="从IOC容器中获取对象并打印"></a><strong>从IOC容器中获取对象并打印</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="引入外部配置类"><a href="#引入外部配置类" class="headerlink" title="引入外部配置类"></a><strong>引入外部配置类</strong></h2><h2 id="新建一个JdbcConfig配置类"><a href="#新建一个JdbcConfig配置类" class="headerlink" title="新建一个JdbcConfig配置类"></a>新建一个<code>JdbcConfig</code>配置类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        ds.setUrl(<span class="string">"jdbc:mysql://localhost:3306/spring_db"</span>);</span><br><span class="line">        ds.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        ds.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="在Spring配置类中引入-import"><a href="#在Spring配置类中引入-import" class="headerlink" title="在Spring配置类中引入 @import"></a><strong>在Spring配置类中引入 <code>@import</code></strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan("com.itheima.config")</span></span><br><span class="line"><span class="comment">//@Import参数需要的是一个数组，可以引入多个配置类</span></span><br><span class="line"><span class="meta">@Import({JdbcConfig.class})</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注解开发实现为第三方bean注入资源"><a href="#注解开发实现为第三方bean注入资源" class="headerlink" title="注解开发实现为第三方bean注入资源"></a>注解开发实现为第三方bean注入资源</h2><h2 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><p> —— 使用<code>@Value</code>注解引入值</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> {</span><br><span class="line">    <span class="meta">@Value("com.mysql.jdbc.Driver")</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value("jdbc:mysql://localhost:3306/spring_db")</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value("root")</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value("password")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><h3 id="在SpringConfig中扫描BookDao"><a href="#在SpringConfig中扫描BookDao" class="headerlink" title="在SpringConfig中扫描BookDao"></a>在SpringConfig中扫描BookDao</h3><p>—— <code>@ComponentScan("com.itheima.dao")</code></p><h3 id="在JdbcConfig类的方法上添加参数"><a href="#在JdbcConfig类的方法上添加参数" class="headerlink" title="在JdbcConfig类的方法上添加参数"></a><strong>在JdbcConfig类的方法上添加参数</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao bookDao)</span>{</span><br><span class="line">    <span class="comment">//在这里！</span></span><br><span class="line">    **System.out.println(bookDao);**</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(driver);</span><br><span class="line">    ds.setUrl(url);</span><br><span class="line">    ds.setUsername(userName);</span><br><span class="line">    ds.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h1><p><img src="/img/%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93.png" alt="Untitled"></p><h1 id="spring整合！-–整合Mybatis"><a href="#spring整合！-–整合Mybatis" class="headerlink" title="spring整合！  –整合Mybatis"></a>spring整合！  –整合Mybatis</h1><h2 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h2><h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database spring_db <span class="keyword">character set</span> utf8;</span><br><span class="line">use spring_db;</span><br><span class="line"><span class="keyword">create table</span> tbl_account(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">35</span>),</span><br><span class="line">    money <span class="keyword">double</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h2 id="创建项目导入jar包"><a href="#创建项目导入jar包" class="headerlink" title="创建项目导入jar包**"></a>创建项目导入jar包**</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="根据表创建模型类"><a href="#根据表创建模型类" class="headerlink" title="根据表创建模型类"></a><strong>根据表创建模型类</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Double money;</span><br><span class="line">        <span class="comment">//setter...getter...toString...方法略    </span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="创建Dao接口"><a href="#创建Dao接口" class="headerlink" title="创建Dao接口"></a><strong>创建Dao接口</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert("insert into tbl_account(name,money)values(#{name},#{money})")</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete("delete from tbl_account where id = #{id} ")</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update("update tbl_account set name = #{name} , money = #{money} where id = #{id} ")</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select("select * from tbl_account")</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select("select * from tbl_account where id = #{id} ")</span></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建Service接口和实现类"><a href="#创建Service接口和实现类" class="headerlink" title="创建Service接口和实现类"></a><strong>创建Service接口和实现类</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入依赖</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> {</span><br><span class="line">    accountDao.save(account);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>{</span><br><span class="line">    accountDao.update(account);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> {</span><br><span class="line">    accountDao.delete(id);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(Integer id)</span> {</span><br><span class="line">    <span class="keyword">return</span> accountDao.findById(id);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="添加jdbc-properties文件"><a href="#添加jdbc-properties文件" class="headerlink" title="添加jdbc.properties文件"></a><strong>添加jdbc.properties文件</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/spring_db?useSSL=false</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></tbody></table></figure><h2 id="添加Mybatis核心配置文件"><a href="#添加Mybatis核心配置文件" class="headerlink" title="添加Mybatis核心配置文件"></a><strong>添加Mybatis核心配置文件</strong></h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取外部properties配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--别名扫描的包路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.itheima.domain"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${jdbc.driver}"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${jdbc.username}"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--映射文件扫描包路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.itheima.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="编写应用程序"><a href="#编写应用程序" class="headerlink" title="编写应用程序"></a><strong>编写应用程序</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">// 1. 创建SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 2. 加载SqlMapConfig.xml配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml.bak"</span>);</span><br><span class="line">        <span class="comment">// 3. 创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        <span class="comment">// 4. 获取SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 5. 执行SqlSession对象执行查询，获取结果User</span></span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> sqlSession.getMapper(AccountDao.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountDao.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a><strong>运行程序</strong></h2><h2 id="正式整合！"><a href="#正式整合！" class="headerlink" title="正式整合！"></a>正式整合！</h2><h2 id="项目中导入整合需要的jar包"><a href="#项目中导入整合需要的jar包" class="headerlink" title="项目中导入整合需要的jar包"></a>项目中导入整合需要的jar包</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring操作数据库需要该jar包--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring与Mybatis整合的jar包</span></span><br><span class="line"><span class="comment">这个jar包mybatis在前面，是Mybatis提供的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>**mybatis-spring**<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="创建Spring的主配置类"><a href="#创建Spring的主配置类" class="headerlink" title="创建Spring的主配置类"></a><strong>创建Spring的主配置类</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//配置类注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//包扫描，主要扫描的是项目中的AccountServiceImpl类【有注解@Service】</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建数据源的配置类"><a href="#创建数据源的配置类" class="headerlink" title="创建数据源的配置类**"></a>创建数据源的配置类**</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> {</span><br><span class="line">    <span class="meta">@Value("${jdbc.driver}")</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value("${jdbc.url}")</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value("${jdbc.username}")</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value("${jdbc.password}")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="创建Mybatis配置类并配置SqlSessionFactory"><a href="#创建Mybatis配置类并配置SqlSessionFactory" class="headerlink" title="创建Mybatis配置类并配置SqlSessionFactory**"></a>创建Mybatis配置类并配置SqlSessionFactory**</h2><p>— 代替Mybatis核心配置文件</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> {</span><br><span class="line"><span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="comment">//引用注解 -- 直接在函数参数那放一个</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>{</span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    <span class="comment">//设置模型类的别名扫描</span></span><br><span class="line">    ssfb.setTypeAliasesPackage(<span class="string">"com.itheima.domain"</span>);</span><br><span class="line">    <span class="comment">//设置数据源</span></span><br><span class="line">    ssfb.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> ssfb;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">    msc.setBasePackage(<span class="string">"com.itheima.dao"</span>);</span><br><span class="line">    <span class="keyword">return</span> msc;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="主配置类中读properties并引入数据源配置类、Mybatis配置类"><a href="#主配置类中读properties并引入数据源配置类、Mybatis配置类" class="headerlink" title="主配置类中读properties并引入数据源配置类、Mybatis配置类"></a><strong>主配置类中读properties并引入数据源配置类、Mybatis配置类</strong></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line">**<span class="meta">@PropertySource("classpath:jdbc.properties")</span></span><br><span class="line"><span class="meta">@Import({JdbcConfig.class,MybatisConfig.class})</span>**</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索日记</title>
      <link href="/posts/think/"/>
      <url>/posts/think/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="我猜你猜不出来" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="50c3bc9c9108715c9d46b9cb8debf775208c73ca25c8b572d62cbe7d5b380761">f5d17c798287e6d27d0e8968f54a971ccdf5f4cb14b7bd9407445fe1e3cb43393281e9fbb57cec1b5877ad6c465d245ce0586701b8d37af175121863bc3d1346a6cbcee4a0f871c76fbb085703a4fc3b63b082768758e08d899ab34808144e1e40db48749bd8df6eef02507b3b388887dab48f0d48f132f66e13b8dd0966fa1b337ade879ef04e12d85adf8fb4e1d644b519b874111e1a6dbb38d683b3d1a19cfeff9c55fcd1d786d32fbd9a5c944ebb72c50f5bc783b7431446de101a08e9e7b6ceea14bbe265f43db84b1a854ce09be4877b9d5603fd8c30062d470a52275dc9d1b4e51cb437c63e51d3d9abfad7a0a949ca56ce295d136e25e6806bc3de5c1d5e1cf45825dd00d2403ccc50ef8725e1f6ebc3b70fc2bdd18ab42b2fc3484b6adb569f736c4ba21933aa3d88853f8a867c5ece8c695f28661804a41170c2b0da06c11a92c4124de615d004257a8fed518ad538728c82a6bbb470d110b24e7e7e525f7322428f5c2d22c81ca64db05073daea1ddd4641104ae651f06f9d295aa36b4f7a0bf937f8e9b1f8efe3d4dc9fa932385ebd6eab865a8c6a6dd186860f48999a4299ce9a5b11657023877c82c552975d514eb77e8527e6506fe6f6cc236195995a36db3eddee6831539695b640b4feb2724adabc9d08d14eaf8ee2fcb6ec214c03a74b511bfa2572c3e63646fa0f9da151b20cf63fb16ff023513f400bdb510317960a8d8eaa35a574b92b7ad4cfa5bac2870465a0674f9a604a95bee95910e4ff1a96c1da521d991a2b927978931e1c3df44841b125ccb42cd456a64008526185793f88ef145b12726ed6aee21ce992517bb1acac6e3ba060f12ebf1012af70ef18b82a9f1d0c02c323d5466dbbeadb565f11ac2b6e35e425d9a79b8a10c523987f7f7a49f9ebeaba63170ba20f76a45d58ff59fc9fd3c25986d8180901c6a3bf1faafbf40eb0993a3ec0ca3d6acf8a37392e4ad664039bc1763f1c77092eaaebd7eaa9489532f69addcc39d49f393185873a71415b5354e0b196697ad3d79cca3014938c042e290d8a55a9f171fd64990fec09246c1f061a7811b81eda2615c855630b76ccd519a9c6af1d559d333ef83874e47a58e449f08e50fc15057fcf1e31f98eaf12b9bb037212262931065184615fae204cec85fb26997986c33d429bd1565d17e61b22acfa45b84d9066e8c917a7739d84288867d559808565bcebd9e7cffe6272d5eb8634ae05c45b85826231b3f947fb681cf34992917ee08a0088a9c39054a8fc33497f1a8a4d013da13683ee25fdf083fc95ceebb1cc5f75e05aa5c930e82d9ff40e712ebb0212127da77b6dd2a9a5e8fe47b9388dabe1d53cf9ff7384dc0c00a7ece85ac4c5ffd4f2453641013c3f1a403ba6ffdc6fa6be007704a5736bd74c1d9f3090738b2beaf4c4f5c378e3880227150ccab27d98cc286ebb4b95a9bdc1778e9f3b3fabe58323c99daf0539265da70414ea9f4e56b7a300fda3f981a4a97689f54636348ff90745ceed483ca452a15d38b6185b8ff2ac7fcdc546736cb983f40771e5f57d16b179595a49645c929fd9b694a8297bd48a9eb67efdfdc0cbaf21883bd2c38f1c66467434a162c2226b6b8c5a61ec253bef3d2e0100bb7a7a1031a0d8a4bfd174886880f639e1f4185e13f6fc419bccf379f21e767b2fce85be8655109f2a13497d8e05d4ec7f2ae5db80457aa933d40ea8c247c257cef12fbda85d04590070d646231dd70f6201bcd501ff8f807f5b0ecc9eff5289b06648fbd6840ea80d62f6df2facefffac980d6ca13791c5b6e51a7a16eab16c4374ed50d29de5c3be3bc515c292948d0c733dfed352896007e659b1ea5e3c1028a330cb19557f6e1c77068307cd75855221795f7588724d679d47e3e97e7345d99f3726fce28db9590adc583fef8e615014cc33d275089da8536a06befabeafa1e6cfd9b2b681a565c553b153d52d9be5e46f20c18dcdb1b5ea1d4afc7bd7f657f063027e27cd79a671343b98ad772979f06ec0fb533510bca25179b2105dbaaa171947a8a64819e29a4b1721ddec8bcaac0be1764b375fd23a588b03ff46c7aac60e2f0f2b089d047bb6c26fbab7bd198f7887e99ed2068cd1f2b7f679b70ebca579a6b7e9ff43058d6ebed75cb48b3366ed544f7bd5f6f138c50bdaa9739b2ff967662919b643a3142bf961e456198e0a1c76c048e62c0e4ea8d9f1358409ebf24a37f018090850fe213babf580f08801e81b1dc61b1f934333bee10c6623e563b7ebc6af82dc998bee5f56e23d4646d030dd56f6fe67565a2685b2a2bf159a8e7f749dba4b448fa130c8c4c15a653e3947a564d0db5f21f7abdf32107737d85225d86edd8e1b8837bf52432984b43f8e0738d95b87e7ae09c1d6628c6b7c0100aa423c3ed1f7d30c9806118e01d9f7bfc753c810b2010647fb9215dd8dce66174cb4e20110ecbd4440b81a5842c0c0f966970a9b50cb1083d10169cda54ca5485e7e9dee494d51591dd0267afad1c7175c87262784de03e2eaa5acaf892f8e231b2d40ff50b87be3497a11426f7580b12adc3e0a85cb8fe1cd55102918f9597217174c23477a8d8fe531a8f9d015dc82f37fae8f7a659cdddf3e09e9ad849becc327d46e1003462c2052a7e0a870eac5ebfb0c583df04cae20a78046098113df9ea78c70d6d3b8fba13b504abc32a61612bb079e5510acbf6f51978f140a09a76b40738a886b4ee1ebac14296d3fc6008c7989075a04de8c3c7a042d55645a92a8c712956a96fe39c77e48dcc0eaaada0b42c4f85fc04fd09d26000c1e76c66e38a0a03a75eb8c0b5d483e81f5b4e42b1c40198d31041c0b299dae5c0c7d3bbab704dedba90d326b013a5a874b1a12bbc5806ac0e38ce6910def08234d9b32d9c4efd5a0318a36443f4eddde214550554099f18896ae2d8a9ce87f84b44aaf3022f2faf090ebc704682051155c0506485712ad6798a5e5c400b75724e92dfd4029ed430ad029b800a81f9f3deffd09ff334535e0b9b9facf2010a9835a96ea7f78fd78fbe97bf1767fdc29f9a85b4b9fa9d140154728d8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这个不能看的🐱</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Day01—  IOC&amp;DI</title>
      <link href="/posts/bfac/"/>
      <url>/posts/bfac/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Day1-—-IOC-DI"><a href="#Spring-Day1-—-IOC-DI" class="headerlink" title="Spring-Day1   —  IOC&amp;DI"></a>Spring-Day1   —  IOC&amp;DI</h1><h2 id="学什么"><a href="#学什么" class="headerlink" title="学什么"></a>学什么</h2><p> 简化开发: Spring框架中提供了两个大的核心技术</p><ul><li>IOC</li><li>AOP</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="IOC-IOC容器-Bean"><a href="#IOC-IOC容器-Bean" class="headerlink" title="IOC &amp; IOC容器 &amp; Bean"></a>IOC &amp; IOC容器 &amp; Bean</h3><ul><li>IOC（Inversion of Control）控制反转</li><li>不自己new对象，交给容器new – 解耦</li><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为Bean</li></ul><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><ul><li>（Dependency Injection）依赖注入</li><li>建立容器中对象与对象之间的绑定关系</li><li>service运行需要依赖dao对象</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="解耦BookDao"><a href="#解耦BookDao" class="headerlink" title="解耦BookDao"></a>解耦<strong>BookDao</strong></h3><ol><li><p>pom.xml添加依赖</p></li><li><p>添加案例中需要的类</p></li><li><p>添加spring配置文件applicationContext.xml   </p>  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--1.导入spring的坐标spring-context--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.配置bean--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">    注意class不要写成接口类而是实现类，因为bean要找对象</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>获取IOC容器、从容器中获取对象进行方法调用</p><pre><code>   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>); </span><br><span class="line"><span class="comment">//getBean() 方法获取的 Bean 的标识符（id 或 name 属性的值），返回的是一个通用的 Object 类型，我们需要将其转换为 BookService 类型</span></span><br><span class="line"><span class="comment">//        BookDao bookDao = (BookDao) ctx.getBean("bookDao");</span></span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">"bookService"</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> </code></pre></li><li><p>运行程序测试</p></li></ol><h3 id="解耦BookService"><a href="#解耦BookService" class="headerlink" title="解耦BookService"></a>解耦<strong>BookService</strong></h3><ol><li><p>去除BookServiceImpl中的new，为属性提供setter方法</p>  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> {</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"book service save ..."</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> {</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改配置完成注入</p>  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">        name属性表示配置哪一个具体的属性/对象名称</span></span><br><span class="line"><span class="comment">        ref属性表示参照哪一个bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bookDao"</span> <span class="attr">ref</span>=<span class="string">"bookDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>运行程序</p></li></ol><h2 id="关于bean"><a href="#关于bean" class="headerlink" title="关于bean"></a>关于<strong>bean</strong></h2><h3 id="bean的基础配置"><a href="#bean的基础配置" class="headerlink" title="bean的基础配置"></a>bean的基础配置</h3><h4 id="配置别名-name"><a href="#配置别名-name" class="headerlink" title="配置别名   name"></a>配置别名   <code>name</code></h4> <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">name</span>=<span class="string">"service service4 bookEbi"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bookDao"</span> <span class="attr">ref</span>=<span class="string">"bookDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="配置范围（是否为单例）-scode"><a href="#配置范围（是否为单例）-scode" class="headerlink" title="配置范围（是否为单例）  scode"></a>配置范围（是否为单例）  <code>scode</code></h4> <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookDao"</span> <span class="attr">name</span>=<span class="string">"dao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="bean的实例化"><a href="#bean的实例化" class="headerlink" title="bean的实例化"></a>bean的实例化</h3><h4 id="构造方法实例化-—-无参构造方法"><a href="#构造方法实例化-—-无参构造方法" class="headerlink" title="构造方法实例化   —  无参构造方法"></a>构造方法实例化   —  无参构造方法</h4><p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果</p><h4 id="静态工厂实例化-—-了解即可"><a href="#静态工厂实例化-—-了解即可" class="headerlink" title="静态工厂实例化   — 了解即可"></a>静态工厂实例化   — 了解即可</h4><h4 id="实例工厂化-—-额额不太懂"><a href="#实例工厂化-—-额额不太懂" class="headerlink" title="实例工厂化   —  额额不太懂"></a>实例工厂化   —  <strong>额额不太懂</strong></h4><ol><li>准备一个Dao和DaoImpl类</li><li>创建一个工厂类OrderDaoFactory并提供一个普通方法  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> {</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li>创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; {</span><br><span class="line"><span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line"><span class="comment">//替代UseDaoFactory的getUserDao方法</span></span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//返回所创建类的Class对象</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getObjectType() {</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li></ul><ol><li><p>配置文件添加</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.factory.UserDaoFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>编写AppForInstanceUser运行类，在类中通过工厂获取对象</p> <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">        <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><h4 id="bean对象从创建到销毁的整体过程"><a href="#bean对象从创建到销毁的整体过程" class="headerlink" title="bean对象从创建到销毁的整体过程"></a>bean对象从创建到销毁的整体过程</h4><ul><li><p>初始化容器</p><ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)</li><li>4.执行bean初始化方法</li></ul></li><li><p>使用bean</p><ul><li>执行业务操作</li></ul></li><li><p>关闭/销毁容器</p><ul><li>执行bean销毁方法</li></ul></li><li><p>代码实现</p><ul><li>1.init＆destory</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//添加两个接口`InitializingBean`， `DisposableBean`并实现接口中的两个方法`afterPropertiesSet`和`destroy`</span></span><br><span class="line"><span class="comment">//这样就不用在配置文件里面配置`init-method`和`destroy-method`</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean {</span><br><span class="line">        <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> {</span><br><span class="line">           <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"book service save ..."</span>);</span><br><span class="line">           bookDao.save(); </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">           System.out.println(<span class="string">"service destroy"</span>);</span><br><span class="line">         }</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">           System.out.println(<span class="string">"service init"</span>);</span><br><span class="line">         }</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure><ul><li>2.close  —执行destroy方法的内容</li></ul>  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//ApplicationContext中没有close方法，需要将ApplicationContext更换成ClassPathXmlApplicationContext</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line"><span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//运行程序，就能执行destroy方法的内容</span></span><br><span class="line">ctx.close();</span><br></pre></td></tr></tbody></table></figure><ul><li><p>3.注册钩子关闭容器    —  执行destroy方法的内容</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="DI-1"><a href="#DI-1" class="headerlink" title="DI"></a>DI</h2><h3 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h3><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><ul><li>简单类型<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><strong>引用类型</strong><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><ul><li>简单类型<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">index</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li>引用类型<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">index</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><ul><li>不用写配置文件了</li><li>类型</li></ul><h4 id="按类型（常用）"><a href="#按类型（常用）" class="headerlink" title="按类型（常用）"></a><strong>按类型（常用）</strong></h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="按名称-—-有多个相同类型的对象"><a href="#按名称-—-有多个相同类型的对象" class="headerlink" title="按名称   —   有多个相同类型的对象"></a>按名称   —   有多个相同类型的对象</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.BookDaoImpl"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.BookServiceImpl"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="按构造方法"><a href="#按构造方法" class="headerlink" title="按构造方法"></a>按构造方法</h4><h3 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h3><h4 id="数组类型数据"><a href="#数组类型数据" class="headerlink" title="数组类型数据"></a>数组类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"array"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="注入List类型数据"><a href="#注入List类型数据" class="headerlink" title="注入List类型数据"></a>注入List类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>chuanzhihui<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="注入Set类型数据"><a href="#注入Set类型数据" class="headerlink" title="注入Set类型数据"></a>注入Set类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="注入Map类型数据"><a href="#注入Map类型数据" class="headerlink" title="注入Map类型数据"></a>注入Map类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"country"</span> <span class="attr">value</span>=<span class="string">"china"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"henan"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"kaifeng"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="注入Properties类型数据"><a href="#注入Properties类型数据" class="headerlink" title="注入Properties类型数据"></a>注入Properties类型数据</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"country"</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"province"</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"city"</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/3eeb/"/>
      <url>/posts/3eeb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
